# React. Introducci√≥n y entorno de desarrollo

- [React. Introducci√≥n y entorno de desarrollo](#react-introducci√≥n-y-entorno-de-desarrollo)
  - [Introducci√≥n a React. Que es React](#introducci√≥n-a-react-que-es-react)
    - [Librer√≠a de JavaScript](#librer√≠a-de-javascript)
      - [Librer√≠a vs Framework](#librer√≠a-vs-framework)
      - [Sitio web y Documentaci√≥n oficial](#sitio-web-y-documentaci√≥n-oficial)
    - [Principios b√°sicos](#principios-b√°sicos)
    - [Elementos del DOM. React en un script](#elementos-del-dom-react-en-un-script)
      - [üï∏Ô∏èP√°gina Web index.html con React](#Ô∏èp√°gina-web-indexhtml-con-react)
    - [Componentes funcionales y JSX](#componentes-funcionales-y-jsx)
      - [üßøComponente App: componente funcional sin JSX en un script](#componente-app-componente-funcional-sin-jsx-en-un-script)
      - [üßøComponente App: componente funcional con JSX en un script](#componente-app-componente-funcional-con-jsx-en-un-script)
      - [JSX (JavaScript XML)](#jsx-javascript-xml)
      - [Sintaxis de JSX](#sintaxis-de-jsx)
      - [üßøComponente App: versi√≥n final](#componente-app-versi√≥n-final)
  - [Entorno de desarrollo con Vite](#entorno-de-desarrollo-con-vite)
    - [Construcci√≥n de un proyecto real. Vite](#construcci√≥n-de-un-proyecto-real-vite)
      - [Herramientas de construcci√≥n (build tools) y empaquetadores (bundlers)](#herramientas-de-construcci√≥n-build-tools-y-empaquetadores-bundlers)
      - [Vite](#vite)
        - [Caracter√≠sticas de Vite](#caracter√≠sticas-de-vite)
        - [Modos de trabajo de Vite](#modos-de-trabajo-de-vite)
          - [Desarrollo](#desarrollo)
          - [Producci√≥n](#producci√≥n)
        - [Ecosistema de plugins](#ecosistema-de-plugins)
        - [Vite y React](#vite-y-react)
    - [Requisitos previos](#requisitos-previos)
    - [Instalaci√≥n de React y TypeScript con Vite](#instalaci√≥n-de-react-y-typescript-con-vite)
      - [Mono-repositorio multi-paquete para React con TypeScript](#mono-repositorio-multi-paquete-para-react-con-typescript)
      - [Herramientas de edici√≥n de c√≥digo](#herramientas-de-edici√≥n-de-c√≥digo)
        - [Prettier](#prettier)
        - [.editorconfig para la configuraci√≥n del editor](#editorconfig-para-la-configuraci√≥n-del-editor)
      - [Creaci√≥n de un nuevo proyecto con Vite](#creaci√≥n-de-un-nuevo-proyecto-con-vite)
        - [Instalaci√≥n de dependencias](#instalaci√≥n-de-dependencias)
        - [Configuraci√≥n de ESLint](#configuraci√≥n-de-eslint)
        - [Alias de importaci√≥n](#alias-de-importaci√≥n)
  - [Estructura del proyecto creado con Vite](#estructura-del-proyecto-creado-con-vite)
    - [Single PAge Application (SPA)](#single-page-application-spa)
    - [Archivos principales](#archivos-principales)
      - [Fichero index.html](#fichero-indexhtml)
      - [‚öôÔ∏èEl fichero main.tsx](#Ô∏èel-fichero-maintsx)
      - [üßøComponente App en el proyecto inicial](#componente-app-en-el-proyecto-inicial)
    - [Comandos (scripts) disponibles](#comandos-scripts-disponibles)

## Introducci√≥n a React. Que es React

### Librer√≠a de JavaScript

[React](https://es.reactjs.org/)

- se define a si mismo como una **librer√≠a** (**biblioteca**) de JavaScript para construir **interfaces de usuario** tanto Web como nativas de dispositivos m√≥viles.
- permite crear **componentes** reutilizables: piezas independientes de la interfaz de usuario que pueden tener su propio estado y propiedades.
- permite gestionar el **estado** de la aplicaci√≥n de manera eficiente. El estado es un objeto que contiene datos que pueden cambiar con el tiempo y que afectan a la apariencia y el comportamiento de la aplicaci√≥n.

Su origen se remonta a 2011, cuando fue desarrollado por **Jordan Walke**, un ingeniero de software de **Facebook**. Fue lanzado como un proyecto de c√≥digo abierto en mayo de 2013 y desde entonces ha ganado una gran popularidad en la comunidad de desarrollo web. Su historia se recoge en la [Wikipedia](https://es.wikipedia.org/wiki/React) y en el documental [How A Small Team of Developers Created React at Facebook | React.js: The Documentary](https://www.youtube.com/watch?v=8pDqJVdNa44).

Ventajas de las librer√≠as/frameworks modernos del frontend (React, Angular, Vue, Svelte, Solid, etc):

- **Declarativo**: Describes QU√â quieres mostrar, no C√ìMO hacerlo, generalmente a nivel del HTML
- **Componentes reutilizables**: Escribe una vez, usa en cualquier lugar
- **Estado reactivo**: Los datos y la UI se mantienen sincronizados autom√°ticamente, mediante diferentes mecanismos. En el caso de React, mediante el **Virtual DOM** y el re-renderizado eficiente, que actualiza solo lo que cambia de forma muy r√°pida
- **Documentaci√≥n** oficial completa y bien mantenida

En el caso de React, otras ventajas son:

- **Ecosistema enorme**: Miles de librer√≠as y herramientas disponibles
- **Comunidad gigante**: Usado por Facebook, Instagram, Netflix, Airbnb
- **Aprendizaje sencillo**: Basado en JavaScript, f√°cil de aprender para desarrolladores web
- **Rendimiento**: Virtual DOM y actualizaciones eficientes
- **Ofertas de empleo** abundantes

#### Librer√≠a vs Framework

Una librer√≠a es un conjunto de funciones y herramientas que puedes usar para resolver problemas espec√≠ficos, mientras que un **framework** es una estructura completa que dicta c√≥mo debes organizar y escribir tu c√≥digo.

En el caso de React, existen varias **librer√≠as**, como se muestra en las dependencias despu√©s de crear un proyecto con Vite y React:

- **react**: los elementos b√°sicos de React.
- **react-dom**: la integraci√≥n de React con el DOM del navegador.

A ellas se a√±ade

- **react-native**: para construir aplicaciones m√≥viles con React.

Junto a React, existen otras librer√≠as que complementan su funcionalidad, en aspectos como

- Enrutamiento (navegaci√≥n entre p√°ginas)
- Gesti√≥n de estado global
- Peticiones HTTP
- Animaciones
- Pruebas unitarias y de integraci√≥n

Este conjunto de librer√≠as y herramientas se utilizan habitualmente junto a React, dando lugar a la **plataforma** o **ecosistema** React:

- [**react-router**](https://reactrouter.com/): para el enrutamiento en aplicaciones de una sola p√°gina.
- [**redux**](https://redux.js.org/): para la gesti√≥n del estado global de la aplicaci√≥n.
- [**axios**](https://axios-http.com/): para realizar solicitudes HTTP.
- [**Jest**](https://jestjs.io/): un framework de pruebas para JavaScript que se integra bien con React.
- [**vitest**](https://vitest.dev/): reciente alternativa r√°pida y ligera para pruebas de aplicaciones de JavaScript.
- [**React Testing Library**](https://testing-library.com/docs/react-testing-library/intro): una biblioteca para probar componentes de React de manera m√°s efectiva.

Por otra parte existen diversos **meta-frameworks** basados en React que proporcionan una estructura m√°s completa para el desarrollo de aplicaciones, como:

- [**Next.js**](https://nextjs.org/): un framework para aplicaciones React que permite la renderizaci√≥n del lado del servidor y la generaci√≥n de sitios est√°ticos.
- [**Gatsby**](https://www.gatsbyjs.com/): un generador de sitios est√°ticos basado en React que utiliza GraphQL para obtener datos.
- [**Remix**](https://remix.run/): un framework para construir aplicaciones web con React, centrado en la experiencia del desarrollador y el rendimiento.

Cuando no se utiliza un framework, existen diversas herramientas o **starters** para crear y gestionar proyectos con React, como:

- **Create React App (CRA)**: la que fue herramienta oficial para crear aplicaciones React con una configuraci√≥n predeterminada, actualmente en desuso.
- [**Vite**](https://vite.dev/): una herramienta de construcci√≥n r√°pida y ligera que soporta React y otras

Junto a las herramientas de construcci√≥n, existen diversas librer√≠as y herramientas para analizar las aplicaciones de react durante su ejecuci√≥n, como:

- [**React Developer Tools**](https://reactjs.org/blog/2019/08/15/new-react-devtools.html): una extensi√≥n del navegador que permite inspeccionar la jerarqu√≠a de componentes de React y su estado.
- [**ESLint**](https://eslint.org/): una herramienta de an√°lisis est√°tico de c√≥digo que ayuda a identificar y corregir problemas en el c√≥digo JavaScript y React.
- [**Prettier**](https://prettier.io/): una herramienta de formateo de c√≥digo que asegura un estilo consistente en todo el proyecto.

#### Sitio web y Documentaci√≥n oficial

Podemos acceder a su web oficial en [https://reactjs.org/](https://reactjs.dev/) o a su versi√≥n en espa√±ol en [React.es](https://es.react.dev/), aunque esta versi√≥n puede ser algo anterior a la √∫ltima versi√≥n en ingl√©s.

En ambos casos podemos encontrar una completa documentaci√≥n oficial, tutoriales y ejemplos para aprender a usar React. Para la documentaci√≥n los enlaces y versiones (en octubre de 2025) ser√≠an

- [Documentaci√≥n oficial de React (ingl√©s)](https://react.dev/reference/react) - v. 19.2
- [Documentaci√≥n oficial de React (espa√±ol)](https://es.react.dev/reference/react) - v. 19.1

La **versi√≥n 19** de React, lanzada en agosto de 2023, introdujo varias mejoras y nuevas caracter√≠sticas, incluyendo la completa reconstrucci√≥n del sitio Web y de la documentaci√≥n oficial, adem√°s de mejoras en el rendimiento y nuevas APIs, entre otra cosas para manejar el estado y los efectos secundarios.

### Principios b√°sicos

React se basa en varios principios fundamentales que facilitan la construcci√≥n de interfaces de usuario:

- **Basado en JavaScript**: React est√° construido sobre JavaScript, lo que permite a los desarrolladores utilizar todo el poder y la flexibilidad de este lenguaje para crear aplicaciones complejas.

- **Declarativo**: React permite describir c√≥mo deber√≠a lucir la interfaz de usuario en funci√≥n del estado de la aplicaci√≥n, y se encarga de actualizar el DOM de manera eficiente cuando el estado cambia. Se dise√±a la vista para cada estado, React actualiza de modo eficiente el DOM cuando cambia el estado.

- **Componentes**: React utiliza componentes encapsulados y reutilizables para construir la interfaz de usuario. Cada componente es una pieza independiente de la interfaz que puede tener su propio estado y propiedades.

- **Composici√≥n de componentes**: los componentes pueden combinarse para crear interfaces de usuario complejas a partir de piezas m√°s peque√±as y manejables.

- **Basado en funciones**: los componentes funcionales son la forma preferida de crear componentes en React, utilizando funciones de JavaScript para definir la l√≥gica y la estructura de la interfaz de usuario.

- **Unidireccional**: el flujo de datos en React es unidireccional, lo que significa que los datos fluyen de los componentes padres a los componentes hijos a trav√©s de las props.

- **Virtual DOM**: React utiliza un Virtual DOM para mejorar el rendimiento. En lugar de actualizar el DOM real directamente, React crea una representaci√≥n en memoria del DOM y realiza actualizaciones eficientes comparando las diferencias entre el Virtual DOM y el DOM real.

- **JSX**: React utiliza JSX, una extensi√≥n de sintaxis que permite escribir HTML dentro de JavaScript. JSX facilita la creaci√≥n de componentes y la definici√≥n de la estructura de la interfaz de usuario.

- **Multiples plataformas**: React se puede utilizar para construir aplicaciones web (React), aplicaciones m√≥viles (React Native) y aplicaciones de escritorio (con herramientas como Electron).

### Elementos del DOM. React en un script

En su forma m√°s simple, se puede utilizar la librer√≠a React desde un script de JS en una p√°gina HTML, como se muestra en el siguiente ejemplo sin utilizar herramientas de construcci√≥n o frameworks ni JSX

#### üï∏Ô∏èP√°gina Web index.html con React

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React Basic Example</title>
    <script
      src="https://unpkg.com/react@17/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"
      crossorigin
    ></script>

    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      #root {
        border: 1px solid #ccc;
        padding: 20px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script>
      const element = React.createElement(
        'div',
        null,
        React.createElement('h1', null, 'Hello, React!'),
        React.createElement(
          'p',
          { className: 'info' },
          'This is a simple React example without JSX.'
        )
      );

      ReactDOM.render(element, document.getElementById('root'));
    </script>
  </body>
</html>
```

En este ejemplo

- se incluyen las librer√≠as React y ReactDOM desde un CDN.
  - **react** es la biblioteca principal con la l√≥gica de componentes
  - **react-dom/client** es el encargado de renderizar React en el navegador
- se crea un elementos del DOM utilizando `React.createElement`.
  Esta funci√≥n tiene tres par√°metros:
  - **Tipo de elemento** - El tag HTML que queremos crear ('h1', 'div', 'button', etc.)
  - **Props (propiedades)** - Un objeto con los atributos del elemento (className, style, onClick, etc.) En nuestro ejemplo es `null` si no tiene atributos. pero vemos tambi√©n que puede ser un objeto con propiedades ({ className: 'info' }).
  - **Children (hijos)** - El contenido del elemento (texto, otros elementos, etc.)
- finalmente, gracias a la funci√≥n `ReactDOM.render`, se renderiza el elemento creado dentro de otro elemento con id `root`.

Los elementos 'children ' pueden ser otros elementos creados con `React.createElement`, permitiendo crear √°rboles de elementos anidados.

La funci√≥n clave es `React.createElement`, que crea un objeto que representa un elemento del DOM. M√°s adelante usaremos JSX para simplificar la creaci√≥n de estos elementos, pero JSX se compila a llamadas a `React.createElement` bajo el cap√≥.

En las herramientas del navegador se puede ver que `element` es un objeto JavaScript que representa el √°rbol de elementos del DOM (un div que contiene un h1 y un p) que React ha creado en memoria (**Virtual DOM**):

```json
{
  "type": "div",
  "key": null,
  "ref": null,
  "props": {
    "children": [
      {
        "type": "h1",
        "key": null,
        "ref": null,
        "props": {
          "children": "Hello, React!"
        },
        "_owner": null,
        "_store": {}
      },
      {
        "type": "p",
        "key": null,
        "ref": null,
        "props": {
          "className": "info",
          "children": "This is a simple React example without JSX."
        },
        "_owner": null,
        "_store": {}
      }
    ]
  },
  "_owner": null,
  "_store": {}
}
```

La funci√≥n `ReactDOM.render` se encarga de actualizar el DOM real del navegador para que coincida con el Virtual DOM creado por React.

### Componentes funcionales y JSX

Los componentes son la base de React. Un componente es una funci√≥n o clase que devuelve un fragmento de c√≥digo HTML. Los componentes pueden ser de clase o funcionales.

- Los componentes funcionales son funciones de JavaScript que devuelven JSX. Son la forma habitual de crear componentes en proyectos de React de los √∫ltimos a√±os.
- Los componentes de clase son clases de JavaScript que extienden la clase `React.Component` y tienen un m√©todo `render()` que devuelve JSX.

El mismo Script anterior se puede reescribir como una **funci√≥n**, escribiendo su nombre con may√∫scula inicial para que React lo reconozca como un **componente**.

#### üßøComponente App: componente funcional sin JSX en un script

```html
<script>
  function App() {
    return React.createElement(
      'div',
      null,
      React.createElement('h1', null, 'Hello, React!'),
      React.createElement(
        'p',
        { className: 'info' },
        'This is a simple React example without JSX.'
      )
    );
  }
  ReactDOM.render(React.createElement(App), document.getElementById('root'));
</script>
```

#### üßøComponente App: componente funcional con JSX en un script

El problema es que resulta algo engorroso escribir c√≥digo HTML utilizando `React.createElement`. Para solucionar este problema, React utiliza **JSX**, una extensi√≥n de sintaxis que permite escribir HTML dentro de JavaScript.

```html
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
<script type="text/babel">
  const App = () => {
    return (
      <div>
        <h1>Hello, React!</h1>
        <p className="info">This is a simple React example with JSX.</p>
      </div>
    );
  };
  ReactDOM.render(<App />, document.getElementById('root'));
</script>
```

#### JSX (JavaScript XML)

**JSX** es una **extensi√≥n de sintaxis** para JavaScript basada en XML que permite escribir HTML dentro de JavaScript.

- se **compila** a **JavaScript** puro antes de ser ejecutado en el navegador.
  - Para ello se utiliza alguna herramienta de transpilaci√≥n como **Babel**, incluida entre los scripts cargados desde un CDN en nuestro ejemplo. Por eso es necesario a√±adir el atributo `type="text/babel"` en la etiqueta `<script>`.
  - Una herramienta m√°s moderna y r√°pida es **SWC** (Speedy Web Compiler), que incluiremos cuando utilicemos Vite.
- permite escribir HTML de manera m√°s legible y f√°cil de entender.
- se utiliza para describir c√≥mo deber√≠a lucir la interfaz de usuario, por lo que es m√°s intuitivo
- reduce los errores y es f√°cil de mantener.

#### Sintaxis de JSX

La sintaxis de JSX es similar a la del HTML, pero tiene algunas diferencias importantes:

- **Atributos**: en JSX, si los atributos coinciden con palabras reservadas de JS cambian de nombre: por ejemplo, `class` se escribe como `className`, `for` se escribe como `htmlFor`, etc. En estos casos se escriben en camelCase en lugar de en min√∫sculas.
- **Cierre de etiquetas**: en JSX, todas las etiquetas deben cerrarse, incluso las etiquetas que no tienen contenido, como `<img />`, `<input />`, etc. or ejemplo, `<img src="image.jpg" />` en lugar de `<img src="image.jpg">`.
- **Expresiones**: en JSX, se pueden utilizar expresiones de JavaScript dentro de llaves `{}` para insertar valores din√°micos en el HTML. Por ejemplo, `<h1>{title}</h1>` donde `title` es una variable de JavaScript. Se puede insertar cualquier expresi√≥n v√°lida de JavaScript dentro de las llaves, incluyendo operaciones matem√°ticas, llamadas a funciones, operadores ternarios, etc. No se admiten sentencias completas como `if`, `for`, `while`, etc.
- **Comentarios**: en JSX, los comentarios se escriben dentro de llaves `{/* comentario */}` en lugar de `<!-- comentario -->`. Por ejemplo, `<div>{/* This is a comment */}</div>`.
- **Estilos en l√≠nea**: en JSX, los estilos en l√≠nea se definen como un objeto JavaScript, utilizando camelCase para las propiedades CSS. Por ejemplo, `<div style={{ backgroundColor: 'red', fontSize: '16px' }}>Hello</div>`. La doble llave `{{ }}` indica que estamos pasando un objeto JavaScript como valor del atributo `style`.

Un bloque de JSX siempre tiene que devolver un **√∫nico elemento ra√≠z**. Si necesitamos devolver m√∫ltiples elementos, podemos envolverlos en un contenedor, como un `<div>`, o utilizar **fragmentos**.

- **Fragmentos**: en JSX, se pueden utilizar fragmentos para agrupar varios elementos sin a√±adir un nodo extra al DOM. Los fragmentos se escriben como `<>...</>` o `<React.Fragment>...</React.Fragment>`. Por ejemplo,

```jsx
<>
  <h1>Hello</h1>
  <p>World</p>
</>
```

En el siguiente ejemplo se muestran algunas de estas diferencias:

#### üßøComponente App: versi√≥n final

En circunstancias reales, los componentes se crean en archivos separados con la extensi√≥n `.jsx` o `.tsx` y se importan cuando es necesario. Por ejemplo, podemos crear un archivo `App.js` con el siguiente contenido:

```jsx
export const App: React.FC = () => {
  const title = 'Hello, React!';
  const description = 'This is a simple React example with JSX.';
  const imageUrl = 'https://picsum.photos/200';

  return (
    <>
      <h1 className="h1">{title}</h1>
      <p>{description}</p>
      <img src={imageUrl} alt={title} />
      {/* This is a comment */}
    </>
  );
};
```

## Entorno de desarrollo con Vite

### Construcci√≥n de un proyecto real. Vite

#### Herramientas de construcci√≥n (build tools) y empaquetadores (bundlers)

Para facilitar el uso de JSX, de typescript y el proceso de importaci√≥n y exportaci√≥n de m√≥dulos, es necesario utilizar herramientas de construcci√≥n o **build tools**. Estas herramientas permiten configurar un entorno de desarrollo adecuado para trabajar con React y otras tecnolog√≠as modernas del frontend.

Un **empaquetador** (bundler) es una herramienta que toma todos los archivos (JavaScript, CSS, im√°genes, etc.) y los procesa, optimiza y empaqueta para que funcionen perfectamente en el navegador.

- **Combina** m√∫ltiples archivos en uno o pocos archivos
- **Transforma** c√≥digo moderno a c√≥digo compatible con navegadores antiguos,
  **transpilando** TS, TSX o JSX a JavaScript
- **Elimina** c√≥digo no utilizado (tree shaking)
- **Minifica** (minify) el c√≥digo (lo hace m√°s peque√±o, eliminando caracteres innecesarios del c√≥digo fuente, como espacios, comentarios y saltos de l√≠nea)
- **Ofusca** (uglify) el c√≥digo (e.g renombra las variables y hace el c√≥digo m√°s dif√≠cil de leer para proteger la propiedad intelectual)
- **Optimiza** im√°genes
- Gestiona **dependencias** autom√°ticamente

Algunas de las herramientas de construcci√≥n m√°s populares son **Vite**, **Webpack** o **Parcel** que crean bundles optimizados con el c√≥digo de la aplicaci√≥n, encarg√°ndose de la transpilaci√≥n de JSX a HTML y el empaquetado de los m√≥dulos.

#### Vite

Vite (se lee [Vit], del franc√©s r√°pido) es seg√∫n su p√°gina Web <https://vite.dev/>:

> Vite es una herramienta de creaci√≥n de frontend incre√≠blemente r√°pida que impulsa la pr√≥xima generaci√≥n de aplicaciones web

Fue creada en 2020por **Evan You**, el mismo desarrollador que cre√≥ Vue.js, porque los empaquetadores tradicionales como Webpack eran lentos en proyectos grandes.

Vite ofrece:

- Un **servidor de desarrollo** que ofrece mejoras de funciones enriquecidas con respecto a los m√≥dulos ES nativos, por ejemplo, un reemplazo de m√≥dulo en caliente (HMR) extremadamente r√°pido .

- Un **comando de compilaci√≥n** (builder) que agrupa su c√≥digo con Rollup , pre-configurado para generar activos est√°ticos altamente optimizados para producci√≥n. Vite puede incorporar en esta fase herramientas como PostCSS, Sass, TypeScript, etc.

La compatibilidad con frameworks y la integraci√≥n con otras herramientas se pueden realizar mediante **plugins**, como sucede en el caso de React

##### Caracter√≠sticas de Vite

- Extremadamente **r√°pido**
  - Arranca el servidor de desarrollo en milisegundos
  - Recarga instant√°nea al hacer cambios -**Hot Module Replacement** (HMR)
  - Cuando cambias el c√≥digo, solo actualiza lo que cambi√≥
  - No recarga toda la p√°gina
  - El estado de tu aplicaci√≥n se mantiene
- Empaquetado **optimizado**
  - C√≥digo minificado
  - Tree shaking (elimina c√≥digo no usado)
  - Code splitting (divide el c√≥digo en chunks)
  - Assets optimizados (im√°genes, fuentes, etc.)
- **Modos** diferentes para desarrollo y producci√≥n
  - Usa esbuild para el desarrollo (escrito en Go, muy r√°pido)
  - Usa Rollup para producci√≥n (mejor optimizaci√≥n)
- **Configuraci√≥n** m√≠nima
  - Funciona out-of-the-box (sin configuraci√≥n)
  - Soporte para React, Vue y otros frameworks por defecto
- **Ecosistema** moderno
  - Soporte para CSS Modules, PostCSS, Sass
  - Importaci√≥n de im√°genes, JSON, etc.
  - Plugins para extender funcionalidad

##### Modos de trabajo de Vite

###### Desarrollo

En **desarrollo**, la compilaci√≥n es on-demand (just-in-time, **JIT**) y r√°pida, transformando solo los m√≥dulos que se solicitan en cada momento. Esto permite tiempos de arranque y recarga muy r√°pidos. La compilaci√≥n se realiza utilizando **esbuild**, que est√° escrito en Go y es extremadamente r√°pido.

Navegador solicita index.html
‚Üì
Vite env√≠a index.html
‚Üì
Navegador pide App.jsx
‚Üì
Vite transforma App.jsx on-demand
‚Üì
Navegador pide componentes importados
‚Üì
Vite transforma solo lo necesario

Para entregar los componentes solicitados, Vite act√∫a como un servidor de desarrollo que sirve los archivos transformados al navegador bajo demanda aprovechando la tecnolog√≠a de **m√≥dulos ES nativos**. Cuando se realizan cambios en el c√≥digo fuente, Vite utiliza **Hot Module Replacement** (HMR) para actualizar solo los m√≥dulos afectados sin recargar toda la p√°gina, manteniendo el estado de la aplicaci√≥n.

###### Producci√≥n

En **producci√≥n**, Vite utiliza **Rollup** para crear un bundle optimizado y minificado. La construcci√≥n es m√°s lenta que en desarrollo y se completa en el momento de hacer el build (ahead-of-time, **AOT**), incluyendo todas las dependencias y optimizaciones avanzadas como tree-shaking y code-splitting para reducir el tama√±o del bundle final. El resultado es un conjunto de archivos est√°ticos altamente optimizados para su despliegue.

Vite usa Rollup
‚Üì
Procesa y optimiza TODO
‚Üì
Genera archivos est√°ticos optimizados
‚Üì
dist/
‚îú‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ assets/
‚îÇ ‚îú‚îÄ‚îÄ index-a1b2c3d4.js (minificado)
‚îÇ ‚îî‚îÄ‚îÄ index-e5f6g7h8.css (minificado)

##### Ecosistema de plugins

Vite tiene un ecosistema de plugins que permite extender su funcionalidad. Existen plugins oficiales y de terceros para a√±adir soporte para diferentes frameworks, lenguajes y herramientas. Algunos ejemplos son:

- `@vitejs/plugin-react`: soporte para React y JSX
- `@vitejs/plugin-vue`: soporte para Vue.js
- `vite-plugin-svelte`: soporte para Svelte
- `vite-plugin-eslint`: integraci√≥n con ESLint
- `vite-plugin-pwa`: soporte para aplicaciones web progresivas (PWA)
- `vite-imagetools`: optimizaci√≥n de im√°genes

##### Vite y React

Vite incluye un plugin oficial para React llamado `@vitejs/plugin-react`, que proporciona:

- soporte para JSX
- Fast Refresh (HMR mejorado para React)
- otras caracter√≠sticas espec√≠ficas de React.

El Hot Module Replacement (HMR) en general permite actualizar m√≥dulos en tiempo real sin recargar toda la p√°gina, pero con React se mejora a√∫n m√°s gracias a **Fast Refresh**, que preserva el estado de los componentes durante las actualizaciones y re-renderiza solo los componentes que cambiaron.

### Requisitos previos

- **Git** instalado y configurado con tu usuario y correo electr√≥nico

- Editor de c√≥digo: **Visual Studio Code**

  - **Extensiones** recomendadas para Visual Studio Code:
    - EditorConfig for VS Code
    - ES7+ React/Redux/React-Native snippets (opcional)
    - ESLint
    - GitHub Copilot (opcional)
    - Prettier - Code formatter
    - Pretty TypeScript Errors (opcional)
    - TwoSlash Query Commands (opcional)
    - Thunder Client (opcional)
  - **Extensiones** para Visual Studio Code para Git
    - Git Graph (o GitLens)
    - gitignore
  - **Extensiones** para Visual Studio Code opcionales y espec√≠ficas de este proyecto:
    - Code Spell Checker / Spanish - Code Spell Checker
    - Dracula Official Theme
    - Image preview
    - Live Server
    - Markdown All in One / Markdown shortcuts / MarkdownLint
    - Material Icon Theme
    - Peacock
    - Reload
    - Spanish Language Pack for Visual Studio Code
    - Versions Lens#

- **Node.js** y **npm** instalados en una versi√≥n estable reciente (LTS)
  La √∫ltima en este momento es la 24.x
  Opcionalmente, puedes utilizar **nvm** (Node Version Manager) para gestionar m√∫ltiples versiones de Node.js en tu m√°quina.

Las herramientas de desarrollo (e.g. Vite, ESLint, Prettier, etc.) est√°n escritas en JS/TS y se ejecutan sobre Node.js, por lo que es necesario tenerlo instalado.

Como gestor de paquetes utilizaremos **npm**, que viene incluido con Node.js y nos permitir√° instalar las dependencias necesarias para nuestro proyecto, incluyendo las propias herramientas de desarrollo.

Usaremos algunos comandos b√°sicos de npm:

- `npm init`: para inicializar un nuevo proyecto y crear un archivo package.json
- `npm install` o `npm i`: para instalar dependencias definidas en el package.json
- `npm i <paquete>`: para instalar un paquete espec√≠fico
- `npm i -D <paquete>`: para instalar un paquete como dependencia de desarrollo
- `npm i -g <paquete>`: para instalar un paquete globalmente
- `npm uninstall <paquete>`: para desinstalar un paquete
- `npm run <script>`: para ejecutar scripts definidos en el package.json
- `npx <paquete>`: para ejecutar paquetes ya disponibles en node_modules o sin instalarlos localmente
- `npm create <paquete>`: para crear un nuevo proyecto utilizando un paquete generador (e.g. Vite, Create React App, etc.)

### Instalaci√≥n de React y TypeScript con Vite

Para instalar React y TypeScript, utilizaremos Vite, un generador de proyectos y empaquetador de c√≥digo.

Lo incluiremos en un mono-repositorio multi-paquete, que nos permitir√° gestionar m√∫ltiples proyectos (paquetes) de React dentro de un mismo repositorio Git.

#### Mono-repositorio multi-paquete para React con TypeScript

Se crea en la ra√≠z del proyecto:

- un **repositorio Git**
- un **package.json**

- la configuraci√≥n del mono-repo se incluye en el **package.json**, indicando que los proyectos (paquetes) se encuentran en la carpeta projects

```json
{
  "name": "react-typescript-monorepo",
  "private": true,
  "workspaces": ["packages/*"]
}
```

Se a√±ade tambi√©n un archivo **.gitignore** para ignorar la carpeta node_modules

```ini gitignore
node_modules
coverage
*.lcov
lib-cov
.env
logs
...
```

#### Herramientas de edici√≥n de c√≥digo

##### Prettier

- la configuraci√≥n de Prettier se incluye en el package.json

Algunos de los par√°metros m√°s habituales son:

```json
{
  "prettier": {
    "singleQuote": true,
    "semi": false,
    "trailingComma": "all",
    "tabWidth": 2,
    "printWidth": 80
  }
}
```

En nuestro caso, hemos optado por utilizar comillas simples, dejando el resto de par√°metros con sus valores por defecto:

```json
"singleQuote": true
```

En algunos casos, es preferible disponer de una copia local de Prettier en lugar de utilizar la que viene instalada con VSC. Para ello, puedes instalar Prettier como una dependencia de desarrollo:

```shell
npm i -D prettier
```

##### .editorconfig para la configuraci√≥n del editor

Junto a Prettier, es frecuente definir el comportamiento del editor desde el fichero .editorconfig, que es un est√°ndar de configuraci√≥n de editores de texto. Puedes crear un archivo `.editorconfig` en la ra√≠z de tu proyecto con el siguiente contenido:

```ini
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 4
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = false

[*.html]
indent_size = 2

[*.md]
indent_size = 2

[*.yml]
indent_size = 2

[*.yaml]
indent_size = 2

[*.json]
indent_size = 2
...
```

#### Creaci√≥n de un nuevo proyecto con Vite

Para crear un nuevo proyecto con Vite, se puede utilizar el siguiente comando:

```shell
npm create vite@latest \<nombre-del-proyecto\>
```

Esto iniciar√° un asistente que te guiar√° a trav√©s de la creaci√≥n del proyecto. Puedes elegir entre diferentes plantillas, como React, Vue, Svelte, etc.

Otra opci√≥n es indicar directamente el nombre del proyecto y la plantilla que deseas utilizar. Por ejemplo, para crear un proyecto de React con TypeScript, puedes usar el siguiente comando:

```shell
npm create vite@latest \<nombre-del-proyecto\> -- --template react-ts
```

En nuestro caso, seguiremos la **creaci√≥n guiada**, indicando:

- Nombre del proyecto: `demo1`
- Framework: `React`
- Variant: `TypeScript + SWC`
- Use rolldown-vite (Experimental)?: `No`
- Install with npm and start now?: `Yes`

[SWC (Speedy Web Compiler)](https://swc.rs/) es un compilador super r√°pido para JavaScript y TypeScript basado en Rust. Es una alternativa a Babel y es compatible con la mayor√≠a de las caracter√≠sticas modernas de JavaScript y TypeScript.

El resultado incluye las siguientes dependencias:

```json
 "dependencies": {
    "react": "^19.1.1",
    "react-dom": "^19.1.1"
  },
  "devDependencies": {
   "@eslint/js": "^9.36.0",
    "@types/node": "^24.6.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react-swc": "^4.1.0",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7"
  }
```

Como se ve, se han instalado

- TypeScript
- React
- ESLint
- Vite, como builder.

Con sus correspondientes ficheros de configuraci√≥n

- El archivo `tsconfig.json` se crea autom√°ticamente y contiene la configuraci√≥n b√°sica para TypeScript. Puedes personalizarlo seg√∫n tus necesidades.

- el archivo de configuraci√≥n de ESLint, `eslint.config.js`. Este archivo puede ubicarse en la ra√≠z del monorepo, para compartir la configuraci√≥n en todos los proyectos (paquetes).

- el del propio `vitest.config.ts`.

##### Instalaci√≥n de dependencias

Si no hemos indicado que lo haga al instalador, debemos instalar las dependencias del proyecto manualmente, utilizando el siguiente comando:

```shell
npm i
```

Esto instalar√° todas las dependencias necesarias para el proyecto, incluyendo React, ReactDOM y TypeScript.

Al ser un monorepo, las dependencias se instalan en la ra√≠z del proyecto, en la carpeta `node_modules`.

##### Configuraci√≥n de ESLint

Para completar el conjunto de reglas utilizadas con React instalamos eslint-plugin-react

```shell
npm i -D eslint-plugin-react
```

De acuerdo con el Readme del proyecto generado por Vite, la recomendaci√≥n respecto a la configuraci√≥n de ESLint es sustituir tseslint.configs.recommended por conjuntos de reglas m√°s restrictivos, como

- tseslint.configs.strict
- tseslint.configs.stylistic,

En nuestro caso, al instalar React, la configuraci√≥n incluye los plugins para React Hooks(`eslint-plugin-react-hooks`) y React Refresh(`eslint-plugin-react-refresh`), y la configuraci√≥n completa que estamos utilizada es la siguiente:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      ...tseslint.configs.strict,
      ...tseslint.configs.stylistic,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    plugins: {
      react,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      '@typescript-eslint/consistent-type-definitions': 'off',
      '@typescript-eslint/explicit-function-return-type': 'warn',
      'react/prefer-read-only-props': 'warn',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]);
```

Se han a√±adido algunas reglas adicionales para personalizar el comportamiento de ESLint en nuestro proyecto, y como ejemplo del uso de reglas con ESLint.

Para comprobar el correcto funcionamiento de ESLint, puedes ejecutar el siguiente comando:

```shell
npm run lint
```

##### Alias de importaci√≥n

Para facilitar las importaciones en los archivos TypeScript, se pueden definir alias de importaci√≥n en el archivo `tsconfig.json`.

- `paths` permiten alias de importaci√≥n.

Por ejemplo, para facilitar el acceso a componentes, hooks y tipos, se pueden definir alias como `@components`, `@hooks`, `@types`, etc.

```json
{
  "compilerOptions": {
    "paths": {
      "@assets/*": ["./src/assets/*"],
      "@core/*": ["./src/core/*"],
      "@features/*": ["./src/features/*"]
    }
  }
}
```

Al utilizar vite es necesario actualizar el archivo `vite.config.ts` para que reconozca estos alias:

```ts
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@assets': '/src/assets',
      '@core': '/src/core',
      '@features': '/src/features',
    },
  },
});
```

## Estructura del proyecto creado con Vite

```plaintext
demo1/
‚îú‚îÄ‚îÄ node_modules/       # Dependencias instaladas (no tocar)
‚îú‚îÄ‚îÄ public/             # Archivos est√°ticos (im√°genes, etc.)
‚îÇ   ‚îî‚îÄ‚îÄ vite.svg
‚îú‚îÄ‚îÄ src/                # Tu c√≥digo fuente
‚îÇ   ‚îú‚îÄ‚îÄ assets/         # Recursos (im√°genes, CSS, etc.)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ react.svg
‚îÇ   ‚îú‚îÄ‚îÄ App.css         # Estilos del componente App
‚îÇ   ‚îú‚îÄ‚îÄ App.tsx         # Componente principal
‚îÇ   ‚îú‚îÄ‚îÄ index.css       # Estilos globales
‚îÇ   ‚îî‚îÄ‚îÄ main.tsx        # Punto de entrada de la aplicaci√≥n
‚îú‚îÄ‚îÄ index.html          # HTML principal
‚îú‚îÄ‚îÄ package.json        # Configuraci√≥n del proyecto y dependencias
‚îú‚îÄ‚îÄ README.md           # Documentaci√≥n del proyecto
‚îú‚îÄ‚îÄ tsconfig.json       # Configuraci√≥n de TypeScript
‚îú‚îÄ‚îÄ tsconfig.app.json
‚îú‚îÄ‚îÄ tsconfig.node.json
‚îî‚îÄ‚îÄ vite.config.js      # Configuraci√≥n de Vite
```

Hemos elevado al mono-repo :

```plaintext
‚îú‚îÄ‚îÄ eslint.config.js    # configuraci√≥n de ESLint
‚îú‚îÄ‚îÄ .gitignore          # Archivos que Git debe ignorar
‚îú‚îÄ‚îÄ package.json        # Configuraci√≥n del monorepo y dependencias
‚îú‚îÄ‚îÄ package-lock.json   # Versiones exactas de dependencias
```

### Single PAge Application (SPA)

Tradicionalmente, las aplicaciones web se constru√≠an **cargando p√°ginas** completas desde el servidor cada vez que el usuario navegaba a una nueva p√°gina. Exactamente igual que los sitios web tradicionales. Estas **aplicaciones de multiples p√°ginas** (MPA o Multi-Page Application) resultaban en una experiencia de usuario lenta y fragmentada, ya que cada navegaci√≥n implicaba una recarga completa de la p√°gina.

Los **frameworks modernos de frontend**, como React, Angular o Vue, permiten construir **aplicaciones de una sola p√°gina** (SPA o Single Page Application).

En una SPA, toda la aplicaci√≥n se carga inicialmente en una sola p√°gina HTML, y luego en respuesta a las interacciones del usuario, el contenido se actualiza din√°micamente mediante JavaScript sin necesidad de recargar la p√°gina completa. Esto proporciona una experiencia de usuario m√°s fluida y r√°pida, similar a la de una aplicaci√≥n de escritorio.

La estructura que veremos en el proyecto creado con Vite y React est√° dise√±ada para construir una SPA.

- un √∫nico fichero HTML (`index.html`)
- un punto de entrada JavaScript/TypeScript (`src/main.tsx`)
- un componente ra√≠z (`src/App.tsx`)

M√°s adelante veremos la importancia de los **routers** para gestionar la navegaci√≥n dentro de una SPA. En React, la librer√≠a m√°s habitual para este prop√≥sito es **React Router**.

### Archivos principales

- `index.html`: el archivo HTML principal de la aplicaci√≥n. Aqu√≠ es donde se monta el componente ra√≠z de React.
- `src/main.tsx`: el punto de entrada de la aplicaci√≥n. Aqu√≠ se importa React, ReactDOM y el componente `App`, y se monta el componente `App` en el DOM.
- `src/App.tsx`: el componente principal de la aplicaci√≥n. Aqu√≠ es donde se define la estructura y l√≥gica de la aplicaci√≥n.
- `src/index.css`: los estilos globales de la aplicaci√≥n.

El resto son principalmente archivos de configuraci√≥n y dependencias o recursos est√°ticos.

#### Fichero index.html

El archivo `index.html` es el punto de entrada HTML de la aplicaci√≥n. Contiene la estructura b√°sica de la p√°gina y un elemento `<div>` con el id `root`, donde se montar√° la aplicaci√≥n React.

```html
<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>demo01</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

Ya se incluyen elementos de accesibilidad y optimizaci√≥n b√°sicos:

- `<meta charset="UTF-8" />`: define la codificaci√≥n de caracteres como UTF-8.
- `<link rel="icon" type="image/svg+xml" href="/vite.svg" />`: establece el icono de la p√°gina (favicon).
- `<meta name="viewport" content="width=device-width, initial-scale=1.0" />`: asegura que la p√°gina se vea bien en dispositivos m√≥viles ajustando el ancho de la ventana gr√°fica al ancho del dispositivo y estableciendo el nivel de zoom inicial.
- `<title>demo01</title>`: define el t√≠tulo de la p√°gina que se muestra en la pesta√±a del navegador.

Se pueden a√±adir otros elementos en el `<head>`, como meta-etiquetas para SEO (descripci√≥n, palabras clave, autor, etc.)

No hay enlaces a hojas de estilo, ya que los estilos se importan directamente en el proceso de construcci√≥n, combinando los estilos globales del archivo `src/index.css` con todos los estilos de los componentes.

#### ‚öôÔ∏èEl fichero main.tsx

En un proyecto creado con Vite y React, el punto de entrada de la aplicaci√≥n es el archivo `main.tsx` (o `main.jsx` si no se utiliza TypeScript) que se encuentra en la carpeta `src`. Este archivo es responsable de renderizar el componente ra√≠z de la aplicaci√≥n dentro del elemento del DOM con id `root`. Por ejemplo, el contenido t√≠pico de este archivo es:

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

En este archivo se importan las librer√≠as `react` y `react-dom`, el componente `App` que es el componente ra√≠z de la aplicaci√≥n, y un archivo CSS para los estilos globales. Luego, se utiliza `ReactDOM.createRoot` para crear una ra√≠z de React en el elemento del DOM con id `root`, y se renderiza el componente `App` dentro de un `React.StrictMode`, que es una herramienta para destacar problemas potenciales en la aplicaci√≥n durante el desarrollo.

El uso del operador `!` (**non-null assertion operator**) despu√©s de `getElementById("root")` es una caracter√≠stica de TypeScript que indica al compilador que estamos seguros de que el elemento con id `root` existe en el DOM y no es `null`. Esto evita errores de compilaci√≥n relacionados con la posibilidad de que `getElementById` devuelva `null` si no encuentra el elemento.

El operador **non-null assertion operator** se considera una mala pr√°ctica en TypeScript, ya que puede llevar a errores en tiempo de ejecuci√≥n si el elemento no existe realmente. Una alternativa m√°s segura ser√≠a verificar si el elemento existe antes de intentar renderizar la aplicaci√≥n, o en este caso, en el que sabemos que existe, hacer un **type assertion** o **type casting**:

```tsx
const root = document.getElementById('root') as HTMLElement;

ReactDOM.createRoot(root).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

El componente **React.StrictMode** es un componente especial que no se renderiza en el DOM, pero activa comprobaciones y advertencias adicionales para sus componentes hijos durante el desarrollo. Ayuda a identificar problemas potenciales en la aplicaci√≥n, como el uso de APIs obsoletas, efectos secundarios inesperados y otros problemas relacionados con el ciclo de vida de los componentes.

Como consecuencia de su uso, veremos que algunos hooks, como `useEffect`, se ejecutan dos veces en modo desarrollo para ayudar a identificar efectos secundarios no deseados. Tendremos por tanto que el componente se renderiza 2 veces.

Esto no ocurre en el modo producci√≥n, donde se elimina el componente `React.StrictMode` durante el proceso de construcci√≥n (build).

#### üßøComponente App en el proyecto inicial

El componente `App` es el componente ra√≠z de la aplicaci√≥n React. En el proyecto creado con Vite y React, este componente se encuentra en el archivo `src/App.tsx` (o `src/App.jsx` si no se utiliza TypeScript). El contenido t√≠pico de este archivo es:

```tsx
import { useState } from 'react';
import reactLogo from './assets/react.svg';
import './App.css';

export const App: React.FC = () => {
  const [count, setCount] = useState(0);

  return (
    <div className="App">
      <div>
        <a href="https://vitejs.dev" target="_blank" rel="noreferrer">
          <img src="/vite.svg" className="logo" alt="Vite logo" />
        </a>
        <a href="https://react.dev" target="_blank" rel="noreferrer">
          <img src={reactLogo} className="logo react" alt="React logo" />
        </a>
      </div>
      <h1>Vite + React + TypeScript</h1>
      <div className="card">
        <button onClick={() => setCount((count) => count + 1)}>
          Count is {count}
        </button>
        <p>
          Edit <code>src/App.tsx</code> and save to test HMR
        </p>
      </div>
      <p className="read-the-docs">
        Click on the Vite and React logos to learn more
      </p>
    </div>
  );
};
```

### Comandos (scripts) disponibles

En el archivo `package.json` del proyecto creado con Vite, se incluyen varios scripts √∫tiles para el desarrollo y la construcci√≥n de la aplicaci√≥n. Estos scripts se pueden ejecutar utilizando el comando `npm run <script>`.

```json
"scripts": {
  "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext .ts,.tsx"
  }
```

- `dev`: inicia el servidor de desarrollo de Vite. Puedes acceder a la aplicaci√≥n en tu navegador en `http://localhost:5173` (o el puerto que indique la consola).
- `build`: crea una versi√≥n optimizada de la aplicaci√≥n para producci√≥n. Los archivos generados se colocan en la carpeta `dist`.
- `preview`: sirve la versi√≥n de producci√≥n de la aplicaci√≥n para que puedas probarla localmente antes de desplegarla.
- `lint`: ejecuta ESLint para analizar el c√≥digo en busca de errores y problemas de estilo.
