# Rutas con React. Single Page Applications

- [Rutas con React. Single Page Applications](#rutas-con-react-single-page-applications)
  - [Rutas nativas en React](#rutas-nativas-en-react)
    - [游쮺omponente Router: Presentaci칩n de las Vistas (p치ginas)](#componente-router-presentaci칩n-de-las-vistas-p치ginas)
      - [游쮺omponente Router.v2: Las p치ginas como objeto de mapeo](#componente-routerv2-las-p치ginas-como-objeto-de-mapeo)
      - [Rutes: un array de objetos Route](#rutes-un-array-de-objetos-route)
      - [游쮺omponente Router.v2: Las p치ginas como array de Route](#componente-routerv2-las-p치ginas-como-array-de-route)
    - [游쮺omponente Link: Navegaci칩n entre p치ginas](#componente-link-navegaci칩n-entre-p치ginas)
    - [Uso del componente Link](#uso-del-componente-link)
    - [Escuchar cambios en la URL](#escuchar-cambios-en-la-url)
    - [Diferencias con librer칤as de routing](#diferencias-con-librer칤as-de-routing)
  - [Custom Hooks](#custom-hooks)
    - [丘뙖잺Hook useRouter](#勇끋ook-userouter)
  - [React Router](#react-router)
    - [Modos de React Router](#modos-de-react-router)
    - [Instalaci칩n](#instalaci칩n)
    - [游쯇치ginas](#p치ginas)
    - [React Router Declarativo](#react-router-declarativo)
      - [Uso b치sico de rutas declarativas](#uso-b치sico-de-rutas-declarativas)
        - [(1) Provider](#1-provider)
        - [(2) Rutas o Fichero de rutas](#2-rutas-o-fichero-de-rutas)
        - [(3) SPA: Link (NavLink)](#3-spa-link-navlink)
      - [Rutas Anidadas: Outlet](#rutas-anidadas-outlet)
      - [Carga diferida (Lazy loading) de las p치ginas](#carga-diferida-lazy-loading-de-las-p치ginas)
    - [React Router Modo Data (Program치tico)](#react-router-modo-data-program치tico)
      - [Rutes: un array de objetos RouteObject](#rutes-un-array-de-objetos-routeobject)
      - [Provider y Rutas](#provider-y-rutas)
      - [Opciones del men칰](#opciones-del-men칰)
      - [Carga diferida (Lazy loading) de las p치ginas em el modo data](#carga-diferida-lazy-loading-de-las-p치ginas-em-el-modo-data)
  - [Patr칩n contenedor/presentador. Rutas din치micas](#patr칩n-contenedorpresentador-rutas-din치micas)
    - [游쯇치gina de Productos y su ruta en el array de rutas](#p치gina-de-productos-y-su-ruta-en-el-array-de-rutas)
    - [Entidad, servicio y datos](#entidad-servicio-y-datos)
    - [CRUD de productos: ProductsList, ProductCard y ProductForm](#crud-de-productos-productslist-productcard-y-productform)
      - [游쮺omponente ProductsList](#componente-productslist)
      - [游쮺omponente ProductCard: botones editar y borrar](#componente-productcard-botones-editar-y-borrar)
      - [游쮺omponente ProductList: L칩gica del estado](#componente-productlist-l칩gica-del-estado)
      - [游쮺omponente ProductForm: edici칩n de productos](#componente-productform-edici칩n-de-productos)
      - [游쮺omponente ProductList: editando productos](#componente-productlist-editando-productos)
      - [游쮺omponente ProductList: a침adir productos](#componente-productlist-a침adir-productos)
      - [游쮺omponente ProductForm: editar y a침adir productos](#componente-productform-editar-y-a침adir-productos)
    - [Rutas din치micas](#rutas-din치micas)
      - [游쮺omponente ProductCard: acceso a una ruta din치mica](#componente-productcard-acceso-a-una-ruta-din치mica)
      - [Uso de rutas din치micas en el componente: useParams y useNavigate](#uso-de-rutas-din치micas-en-el-componente-useparams-y-usenavigate)
      - [游쮺omponente ProductDetail](#componente-productdetail)
  - [Patrones de abstracci칩n de datos](#patrones-de-abstracci칩n-de-datos)
    - [Patr칩n layer](#patr칩n-layer)
      - [丘뙖잺Hook useProducts](#勇끋ook-useproducts)
    - [\[Avanzado\] Patr칩n repositorio](#avanzado-patr칩n-repositorio)
      - [丘뙖잺Servicio ProductsRepository: repositorio de productos](#勇끕ervicio-productsrepository-repositorio-de-productos)

## Rutas nativas en React

Sin ninguna librer칤a externa podemos programar el enrutamiento de una aplicaci칩n React usando el estado y renderizado condicional.

### 游쮺omponente Router: Presentaci칩n de las Vistas (p치ginas)

En el componente router, leemos `window.location.pathname` para determinar la p치gina actual, que guardamos en una variable de estado llamada currentPath. M치s adelante veremos la necesidad de tener un estado, para actualizar la vista cuando cambie la URL.

Las p치ginas disponibles, e.g. Home, Products, About, 404 se seleccionan en funci칩n del valor de currentPath (mediante if o switch).

El resultado se guarda en una variable CurrentPage, en PascalCase, ya que es de tipo React.FC.

Se renderiza el componente CurrentPage en el JSX del router, como cualquier otro componente.

```tsx
export const Router: React.FC = () => {
  const [currentPath, setCurrentPath] = useState<string>(
    window.location.pathname
  );

  let CurrentPage: React.FC = () => null;

  switch (currentPath) {
    case '/':
    case 'home':
      CurrentPage = HomePage;
      break;
    case '/products':
      CurrentPage = ProductsPage;
      break;
    default:
      CurrentPage = NotFound;
      break;
  }

  return <CurrentPage />;
};
```

#### 游쮺omponente Router.v2: Las p치ginas como objeto de mapeo

Para evitar una estructuras condicional (if o switch), podemos usar un objeto de mapeo (diccionario) entre rutas y componentes.

```tsx
const routesMap: Record<string, React.FC> = {
  '/': HomePage,
  '/products': ProductsPage,
  '*': NotFound,
};

export const Router: React.FC = () => {
  const [currentPath, setCurrentPath] = useState<string>(
    window.location.pathname
  );

  const CurrentPage = routesMap[currentPath] || routesMap['*'];

  return <CurrentPage />;
};
```

#### Rutes: un array de objetos Route

Podr칤amos ir un paso m치s a la adelante y definir las rutas en un array de objetos, cada uno con path y componente, creando un tipo y un fichero para definir la configuraci칩n de rutas.

```tsx
type Route = {
  path: string;
  component: React.FC;
  label?: string;
};

const routes: Route[] = [
  {
    path: '/',
    component: HomePage,
    label: 'Home',
  },
  {
    path: '/products',
    component: ProductsPage,
    label: 'Products',
  },
  {
    path: '*',
    component: NotFound,
  },
];
```

#### 游쮺omponente Router.v2: Las p치ginas como array de Route

El el Router, buscamos la ruta que coincida con currentPath usando Array.find y renderizamos su componente.

```tsx
export const Router: React.FC = () => {
  const [currentPath, setCurrentPath] = useState<string>(
    window.location.pathname
  );

  const validRoute =
    routes.find((route) => route.path === currentPath) ||
    routes.find((route) => route.path === '*');

  let CurrentPage: React.FC = validRoute!.component;

  return <CurrentPage />;
};
```

### 游쮺omponente Link: Navegaci칩n entre p치ginas

El problema de la navegaci칩n con enlaces \<a> normales es que se recarga la aplicaci칩n, perdiendo el estado de React y provocando una mala experiencia de usuario.

Para evitar la recarga, creamos un componente Link personalizado que previene el comportamiento por defecto del enlace y usa el History API para cambiar la URL sin recargar la p치gina.

```tsx
export const Link: React.FC<{ to: string; children: React.ReactNode }> = ({
  to,
  children,
}) => {
  const handleClick = (event: React.MouseEvent<HTMLAnchorElement>) => {
    event.preventDefault();
    window.history.pushState(null, '', to);
    const navEvent = new PopStateEvent('popstate');
    window.dispatchEvent(navEvent);
  };

  return (
    <a href={to} onClick={handleClick}>
      {children}
    </a>
  );
};
```

1. Previene la acci칩n por defecto del enlace con `event.preventDefault()`.
2. Usa `window.history.pushState` para cambiar la URL sin recargar.

   - Primer par치metro: objeto de estado (lo dejamos vac칤o)
   - Segundo par치metro: t칤tulo (obsoleto, lo dejamos vac칤o)
   - Tercer par치metro: la nueva URL

   Despu칠s de esto, la barra de direcciones muestra la nueva URL, pero la p치gina no se recarga.

3. Crea y despacha un evento `popstate` para notificar a la aplicaci칩n del cambio de URL.

### Uso del componente Link

En los componentes, e.g. Menu, usamos el componente Link para la navegaci칩n interna.

```tsx
export const Menu: React.FC = () => {
  return (
    <nav>
      <ul>
        <li>
          <Link to="/">Home</Link>
        </li>
        <li>
          <Link to="/products">Products</Link>
        </li>
        <li>
          <Link to="/about">About</Link>
        </li>
      </ul>
    </nav>
  );
};
```

### Escuchar cambios en la URL

HAsta ahora, aunque cambiemos la URL con el componente Link, el router no se entera del cambio y no actualiza la vista.

Para solucionar esto, en el componente Router usamos un useEffect para escuchar el evento nativo `popstate` y actualizar el estado currentPath cuando la URL cambia.

```tsx
useEffect(() => {
  const handlePopState = () => {
    setCurrentPath(window.location.pathname);
  };

  window.addEventListener('popstate', handlePopState);

  return () => {
    window.removeEventListener('popstate', handlePopState);
  };
}, []);
```

Con esto, cada vez que la URL cambie (mediante Link o con los botones de adelante/atr치s del navegador), el estado currentPath se actualizar치, provocando un nuevo renderizado del Router y mostrando la p치gina correcta.

Aunque siempre es recomendable usar funciones nombradas (handle...), en este caso es imprescindible para que la funci칩n sea la misma en el addEventListener y en el removeEventListener; solo as칤 funciona correctamente la limpieza del efecto.

### Diferencias con librer칤as de routing

Aunque este enfoque funciona para aplicaciones simples, tiene limitaciones.

- No maneja rutas anidadas ni par치metros de ruta.
- No soporta redirecciones ni rutas protegidas.
- No optimiza la carga de componentes (lazy loading).
- No ofrece utilidades avanzadas como hooks para navegaci칩n o acceso a la ubicaci칩n.
- No gestiona el historial de navegaci칩n de forma avanzada.

## Custom Hooks

Los hooks personalizados pueden encapsular la l칩gica de enrutamiento para reutilizarla f치cilmente en diferentes componentes. Es una de las caracter칤sticas m치s potentes de React, mejorando la organizaci칩n, mantenibilidad y composici칩n del c칩digo.

Un custom hook es una funci칩n de JavaScript que re칰ne las siguientes caracter칤sticas:

- Su nombre empieza con use (convenci칩n obligatoria)
- Puede usar otros hooks de React dentro
- Retorna valores que otros componentes pueden usar

Las ventajas de usar hooks personalizados son:

- **Encapsula l칩gica** al margen del UI, separando as칤 las **responsabilidades** de la l칩gica y de la presentaci칩n
- Se pueden **reutilizar** en m칰ltiples componentes o desde otros hooks (composici칩n de hooks)
- Mejora la **testeabilidad** y la **legibilidad** del c칩digo al abstraer detalles complejos
- Hace el c칩digo m치s **mantenible** al centralizar la l칩gica en un solo lugar

En el caso de las rutas, los hooks personalizados permiten abstraer la complejidad del enrutamiento.

### 丘뙖잺Hook useRouter

La l칩gica de enrutamiento del componente Router (v3) puede extraerse a un hook personalizado llamado useRouter.

```tsx
import { useEffect, useState } from 'react';
import { routes } from './routes';

export const useRouter = () => {
  const [currentPath, setCurrentPath] = useState<string>(
    window.location.pathname
  );

  const validRoute =
    routes.find((route) => route.path === currentPath) ||
    routes.find((route) => route.path === '*');

  let CurrentPage: React.FC = validRoute!.component;

  useEffect(() => {
    // Funci칩n que actualiza el estado con la nueva ruta
    const handlePopState = () => {
      setCurrentPath(window.location.pathname);
    };

    // Escuchar el evento popstate
    window.addEventListener('popstate', handlePopState);

    // Limpiar el event listener al desmontar
    return () => {
      window.removeEventListener('popstate', handlePopState);
    };
  }, []);

  return CurrentPage;
};
```

La l칩gica de la navegaci칩n, que hasta ahora usa Link se puede a침adir como una segunda funci칩n

```tsx
const navigate = (to: string) => {
  window.history.pushState(null, '', to);
  const navEvent = new PopStateEvent('popstate');
  window.dispatchEvent(navEvent);
};

return { CurrentPage, navigate };
```

A침adimos as칤 la funci칩n navigate al hook, que puede usarse en cualquier componente para cambiar la URL y navegar entre p치ginas (program치ticamente) y que utilizamos en el Link.

## React Router

Es una librer칤a especializada que soluciona estos problemas y facilita la gesti칩n de rutas en aplicaciones React complejas. Proporciona componentes y hooks espec칤ficos para definir rutas, navegar entre ellas y acceder a la informaci칩n de la ubicaci칩n de manera sencilla y eficiente.

[React Router](https://reactrouter.com/home) es una biblioteca de enrutamiento para aplicaciones React. Permite definir rutas y manejar la navegaci칩n entre diferentes vistas de la aplicaci칩n. Con TypeScript, se pueden definir tipos para las rutas y los par치metros, lo que mejora el autocompletado y la verificaci칩n de tipos al trabajar con rutas.

React Router es la evoluci칩n de react-router-dom, despu칠s de haber pasado por el meta-framework de [Remix](https://remix.run/) y en su actual versi칩n 7.x proporciona tres formas diferentes de trabajar (estrategias), incluyendo una API m치s sencilla y flexible para manejar el enrutamiento en aplicaciones React. Permite definir rutas anidadas, rutas din치micas y rutas protegidas, lo que facilita la creaci칩n de aplicaciones complejas con m칰ltiples vistas.

### Modos de React Router

El **modo declarativo** habilita funciones de enrutamiento b치sicas, como hacer coincidir URL con componentes, navegar por la aplicaci칩n y proporcionar estados activos con API como \<Link>, `useNavigate` y `useLocation`. Corresponde a la forma original de react-router-dom y probablemente siga siendo la forma m치s com칰n de usar React Router.

```ts
import { BrowserRouter } from 'react-router';

ReactDOM.createRoot(root).render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);
```

El **modo Datos**, al mover la configuraci칩n de ruta fuera de la representaci칩n de React, agrega carga de datos, acciones, estados pendientes y m치s con API como `loader`, `action`, y `useFetcher`.

```ts
import { createBrowserRouter, RouterProvider } from 'react-router';

let router = createBrowserRouter([
  {
    path: '/',
    Component: Root,
    loader: loadRootData,
  },
]);

ReactDOM.createRoot(root).render(<RouterProvider router={router} />);
```

El **modo Framework** envuelve el modo Data con un complemento Vite para agregar la experiencia completa de React Router con:

- tipo seguro `href`
- API de m칩dulo de ruta de tipo seguro
- divisi칩n inteligente de c칩digo
- Estrategias de SPA, SSR y renderizado est치tico

Seg칰n sus creadores, es la forma m치s avanzada de usar React Router y es la que se recomienda para aplicaciones nuevas, especialmente si son grandes y complejas. Permite una mayor flexibilidad y control sobre el enrutamiento y la carga de datos, lo que facilita la creaci칩n de aplicaciones escalables y mantenibles.

```ts
import { index, route } from '@react-router/dev/routes';

export default [index('./home.tsx'), route('products/:pid', './product.tsx')];
```

Luego tendr치 acceso a la API del m칩dulo de ruta con par치metros de tipos seguros, loaderData, divisi칩n de c칩digo, estrategias SPA/SSR/SSG y m치s.

```ts
import { Route } from '+./types/product.tsx';

export async function loader({ params }: Route.LoaderArgs) {
  let product = await getProduct(params.pid);
  return { product };
}

export default function Product({ loaderData }: Route.ComponentProps) {
  return <div>{loaderData.product.name}</div>;
}
```

### Instalaci칩n

Para poder usar los modos declarativo y de datos, primero hay que instalar la librer칤a:

```shell
npm install react-router
```

Para utilizar el modo framework, es necesario crear el proyecto con el template espec칤fico:

```shell
npm create vite@latest my-react-router-app -- --template react-router
```

O indicarlo interactivamente al crear el proyecto con Vite:

```shell
npm create vite@latest
```

### 游쯇치ginas

En React Router, las p치ginas se representan mediante componentes de React que se asocian a rutas espec칤ficas. Cada ruta define una URL y el componente que se debe renderizar cuando esa URL es accedida.

Creamos en cada una de las features el componente correspondiente a cada p치gina y distribuimos en ellos los componentes que hemos creado hasta ahora

```tsx
export const HomePage: React.FC = () => {
  return (
    <section>
      <h2>Demo 01</h2>
      <Greetings username="Pepe" />
      <PanicButton />
    </section>
  );
};

export const CountersPage: React.FC = () => {
  return (
    <section>
      <h2>Counters</h2>
      <section>
        <h3>Click Counters</h3>
        <CounterNS />
        <Counter />
        <CounterLogin />
      </section>
      <section>
        <h3>Time Counters</h3>
        <BasicTimer />
        <FullTimer />
      </section>
    </section>
  );
};

export const FormsPage: React.FC = () => {
  return (
    <section>
      <h2>Forms</h2>
      <SearchForm />
      <SearchFormPro />
      <LoginForm />
      <LoginFormRemember />
      <LoginFormValidation />
      <RegisterForm />
    </section>
  );
};
```

El componente App, de momento, cargar치 todas las p치ginas, una debajo de otra. Por tanto no veremos ninguna diferencia con lo que ten칤amos hasta ahora.

```tsx
export const App: React.FC = () => {
  const title = 'Vite + TS + React';

  const menuOptions: MenuOption[] = [
    { label: 'Home', path: '/' },
    { label: 'Counters', path: '/counters' },
    { label: 'Forms', path: '/forms' },
    { label: 'About', path: '/about' },
  ];

  return (
    <Layout appTitle={title} menuOptions={menuOptions}>
      <main>
        <HomePage />
        <CountersPage />
        <FormsPage />
      </main>
    </Layout>
  );
};
```

### React Router Declarativo

Para utilizar React Router en modo declarativo, se deben seguir los siguientes pasos:

- definir un provider de las rutas en el fichero main
- definir las rutas en el fichero App o en un fichero de rutas separado
- utilizar el componente Link para la navegaci칩n entre p치ginas

#### Uso b치sico de rutas declarativas

##### (1) Provider

En el fichero main se a침ade un provider de las rutas:

```tsx
import { createRoot } from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';

const container = document.getElementById('root')!;
const root = createRoot(container);
root.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);
```

##### (2) Rutas o Fichero de rutas

En el fichero App se definen las rutas:

```tsx
import { Routes, Route } from 'react-router-dom';
import Home from './pages/Home';
import About from './pages/About';
import NotFound from './pages/NotFound';
import Layout from './components/Layout';
import './App.css';
function App() {
  return (
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="/counters" element={<CountersPage />} />
      <Route path="/forms" element={<FormsPage />} />
      <Route path="*" element={<div>404 Not Found</div>} />
    </Routes>
  );
}
export default App;
```

Para evitar que el fichero `App.tsx` crezca, se pueden definir las rutas en un fichero separado:

```tsx
import { Navigate, Route, Routes } from 'react-router';

export const AppRoutes: React.FC = () => {
  return (
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="/home" element={<Navigate to="/" replace />} />
      <Route path="/counters" element={<CountersPage />} />
      <Route path="/forms" element={<FormsPage />} />
      <Route path="*" element={<div>404 Not Found</div>} />
    </Routes>
  );
};
```

Luego se importa en el fichero `App.tsx` como un componente m치s.

##### (3) SPA: Link (NavLink)

Al utilizar href en los enlaces del men칰, la navegaci칩n es una MPA, ya que recarga la p치gina al hacer clic en un enlace.

Para que sea una SPA, se debe utilizar el componente `Link` de React Router para navegar entre las diferentes rutas sin recargar la p치gina.

```tsx
import { Link } from 'react-router-dom';
...
<Link to={option.path} className="menu-link">
  {option.label}
</Link>;
```

Ahora, al hacer clic en un enlace del men칰, la navegaci칩n se realiza sin recargar la p치gina, manteniendo el estado de la aplicaci칩n y mejorando la experiencia del usuario.

#### Rutas Anidadas: Outlet

El componente Layout, puede integrarse en las rutas y anidar las rutas hijas. Para ello se sustituye el children por un elemento `Outlet` de React Router, que se encargar치 de renderizar las rutas hijas.

```tsx
type Props = {
  readonly appTitle: string;
  menuOptions: MenuOption[];
};

export const Layout: React.FC<Props> = ({ appTitle, menuOptions }) => {
  return (
    <>
      <Header appTitle={appTitle}>
        <Menu options={menuOptions} />
        <Logos />
      </Header>
      <main>
        {/* Aqu칤 se renderizan las rutas hijas */}
        <Outlet />
      </main>
      <Footer />
    </>
  );
};
```

Las rutas en el componente AppRoutes quedar칤an de la siguiente forma:

```tsx
type Props = {
  readonly appTitle: string;
  menuOptions: MenuOption[];
};

export const AppRoutes: React.FC<Props> = ({ appTitle, menuOptions }) => {
  return (
    <Routes>
      <Route element={<Layout appTitle={appTitle} menuOptions={menuOptions} />}>
        <Route path="/" element={<HomePage />} />
        <Route path="/home" element={<Navigate to="/" replace />} />
        <Route path="/counters" element={<CountersPage />} />
        <Route path="/forms" element={<FormsPage />} />
        <Route path="*" element={<div>404 Not Found</div>} />
      </Route>
    </Routes>
  );
};
```

Y el componente `App` solo cargar칤a las rutas, con lo que quedar칤a as칤:

```tsx
export const App: React.FC = () => {
  const title = 'Vite + TS + React';

  const menuOptions: MenuOption[] = [
    { label: 'Home', path: '/' },
    { label: 'Counters', path: '/counters' },
    { label: 'Forms', path: '/forms' },
    { label: 'About', path: '/about' },
  ];

  return <AppRoutes appTitle={title} menuOptions={menuOptions} />;
};
```

#### Carga diferida (Lazy loading) de las p치ginas

Se basa en la existencia en el est치ndar de JS de la posibilidad de importar **m칩dulos** de forma **as칤ncrona**, utilizando la funci칩n `import()`.

Para implementar el lazy loading en las rutas de React Router, se puede utilizar la funci칩n `lazy` de React, que permite cargar componentes de forma diferida. Para facilitar esta operaci칩n es conveniente que los componentes que se vayan a cargar de forma diferida est칠n exportados de forma `default`.

```tsx
const HomePage = React.lazy(() => import('@features/home/home-page'));
const CountersPage = React.lazy(
  () => import('@features/counters/counters-page')
);
const FormsPage = React.lazy(() => import('@features/forms/forms-page'));
```

Para ello, se importa el componente de forma diferida utilizando `React.lazy` y se envuelve en un `Suspense` para manejar el estado de carga.

```tsx
<Route
  index
  element={
    <React.Suspense>
      <Home />
    </React.Suspense>
  }
/>
```

Y as칤 con cada una de las rutas que se vayan a cargar de forma diferida.

Para que el componente `Suspense` muestre algo mientras se carga el componente, se le puede pasar una prop `fallback` con un elemento que se mostrar치 durante la carga:

```tsx
<React.Suspense fallback={<div>Loading...</div>}>
  <Home />
```

### React Router Modo Data (Program치tico)

React Router en modo Data (Program치tico) permite definir rutas y manejar la navegaci칩n de manera m치s estructurada y eficiente, especialmente en aplicaciones complejas. En este modo, las rutas se definen utilizando un objeto de configuraci칩n que especifica las rutas, los componentes asociados y otras propiedades como loaders y actions.

#### Rutes: un array de objetos RouteObject

Las rutas no se definen de forma declarativa, como componentes JSX dentro de un componente `Routes`, sino que se definen en un fichero de rutas separado, creando un array de objetos que representan las rutas

```tsx
import type { RouteObject } from 'react-router';

export const routes: RouteObject[] = [
  {
    path: '/',
    Component: App,
    children: [
      {
        // path: '/',
        index: true,
        Component: HomePage,
      },
      {
        path: '/home',
        loader: (): void => {
          throw redirect('/');
        },
      },
      {
        path: '/counters',
        Component: CountersPage,
      },
      {
        path: 'forms',
        Component: FormsPage,
      },
      {
        path: '*',
        Component: () => <div>404 Not Found</div>,
      },
    ],
  },
];
```

Las rutas se pueden definir de forma anidada, utilizando la propiedad `children`.
El componente por defecto puede indicarse con un `path: '\'` o con la propiedad `index: true`, que indica que es la ruta por defecto del padre.

#### Provider y Rutas

En el fichero main

- Con el array importado de las rutas como par치metro se crea un router
- se a침ade un provider de las rutas

```tsx
import { createRoot } from 'react-dom/client';
import { createBrowserRouter BrowserRouter} from 'react-router-dom';
import { appRoutes } from './core/routes/routes.ts';

const container = document.getElementById('root') as HTMLDivElement;
const root = createRoot(container);

const router = createBrowserRouter(routes);
root.render(
  <StrictMode>
    <RouterProvider router={appRouter} />
  </StrictMode>,
);
```

El nuevo formato del RouterProvider ya no encapsula ning칰n componente, sino que recibe un objeto `router` que contiene las rutas definidas.

El **componente App** contin칰a utilizando el Layout, con el Outlet como contenido, marcando donde se renderizar치 la p치gina activa.

```tsx
export const App: React.FC = () => {
  const title = 'Vite + TS + React';

  const menuOptions: MenuOption[] = [
    { label: 'Home', path: '/' },
    { label: 'Counters', path: '/counters' },
    { label: 'Forms', path: '/forms' },
    { label: 'About', path: '/about' },
  ];

  return (
    <Layout appTitle={title} menuOptions={menuOptions}>
      <main>
        <Outlet />
      </main>
    </Layout>
  );
};
```

En el **componente Menu**, no necesitamos hacer ning칰n cambio. El componente Link (o NavLink) de React Router se utiliza igual que en el modo declarativo.

#### Opciones del men칰

Lo que s칤 cambia es la forma de definir las opciones del men칰, que ahora se pueden extraer directamente del array de rutas.

En primer lugar, es necesario a침adir en cada ruta la informaci칩n que mostrar치 el men칰 (label), para lo cual podemos usar la propiedad `id`, disponible en el tipo RouteObject.

Las opciones del menu las extraemos de las rutas filtrando las que tienen 'id'.

```tsx
export const getMenuOptions = (routes: RouteObject[]): MenuOption[] => {
  const menuOptions: MenuOption[] = [];

  const menuOptions: MenuOption[] = routes[0].children
    ? routes[0].children
        .filter((route) => 'id' in route && route.id)
        .map((route) => ({
          label: route.id as string,
          path: route.index ? '/' : (route.path as string),
        }))
    : [];

  return menuOptions;
};
```

#### Carga diferida (Lazy loading) de las p치ginas em el modo data

Como ya vimos, la carga diferida Se basa en la existencia en el est치ndar de JS de la posibilidad de importar **m칩dulos** de forma **as칤ncrona**, utilizando la funci칩n `import()`.

Igual que en las rutas declarativas, se puede utilizar la funci칩n `lazy` de React, que permite cargar componentes de forma diferida. Para facilitar esta operaci칩n es conveniente que los componentes que se vayan a cargar de forma diferida est칠n exportados de forma `default`.

```tsx
const HomePage = React.lazy(() => import('@features/home/home-page'));
const CountersPage = React.lazy(
  () => import('@features/counters/counters-page')
);
const FormsPage = React.lazy(() => import('@features/forms/forms-page'));
```

De esta forma no es necesaria ninguna modificaci칩n en el array de rutas.

Una **alternativa** solo disponible en las rutas basadas en datos, es usar la propiedad **lazy** de los objetos de las rutas, que permite definir el componente a cargar de forma diferida. Al hacer async/await dentro de la funci칩n, se puede importar el m칩dulo y devolver el componente accediendo a su exportaci칩n con nombre.

```tsx
{
  path: 'forms',
  lazy: {
    Component: async () =>
        (await import('@features/forms/forms-page')).FormsPage,
  },
}
```

## Patr칩n contenedor/presentador. Rutas din치micas

El patr칩n **contenedor/presentador** (container/presenter) es una forma de estructurar los componentes en React para separar la l칩gica de negocio de la presentaci칩n visual.

En este patr칩n,

- los componentes contenedores (containers) se encargan de manejar la l칩gica, el estado y las interacciones con los servicios
- los componentes presentadores (presenters) se centran en la representaci칩n visual y la interfaz de usuario.

Con frecuencia se usa este patron para gestionar el listado de una serie de elementos:

- la lista es el componente contenedor
- cada item o elemento de la lista es un componente presentador

Adem치s, este patr칩n es especialmente 칰til para implementar rutas din치micas a partir de cada item, donde la URL contiene par치metros que determinan qu칠 datos se deben mostrar en una p치gina con los detalles de un item concreto.

Para desarrollar un ejemplo creamos la feature Products

- La p치gina ProductsPage
- La ruta correspondiente en el array de rutas
- La entidad correspondiente
- un Mock de productos almacenado como una constante
- Un componente Products que renderiza una lista de productos
- Un componente Product que renderiza un producto por id
- un componente ProductDetail que muestra los detalles de un producto

### 游쯇치gina de Productos y su ruta en el array de rutas

Como en casos anteriores, creamos el componente de la p치gina ProductsPage en la carpeta `features/products`. M치s adelante renderizar치 el componente contenedor Products.

```tsx
export const ProductsPage: React.FC = () => {
  return (
    <section className="products">
      <h2>Products</h2>
    </section>
  );
};

export default ProductsPage;
```

En el array de rutas se a침ade la ruta correspondiente, con la carga lazy de la p치gina (componente):

```tsx
  {
    path: '/products',
      lazy: {
        Component: async () =>
            (await import('@features/products/products-page')).ProductsPage,
    },
    id: 'Products',
  }
```

### Entidad, servicio y datos

En la carpeta `features/products/types` creamos el fichero `product.ts` para definir la entidad Product

```tsx
export type Product = {
  id: string;
  name: string;
  model: string;
  vehicleClass: string;
  manufacturer: string;
  length: number;
  costs: number;
  crew: number;
  passengers: number;
  maxSpeed: number;
  cargoCapacity: number;
  consumables: number;
};
```

En la carpeta `features/products/services` creamos el fichero `products.json` con un mock de productos y el fichero `products.ts` con una funci칩n para obtenerlos.

```tsx
import type { Product } from '../types/product';
import PRODUCTS from '../data/products.json';

export const getProducts = (): Product[] => {
  return PRODUCTS;
};

export const getProductById = (id: string): Product | undefined => {
  return PRODUCTS.find((product) => product.id === id);
};
```

### CRUD de productos: ProductsList, ProductCard y ProductForm

#### 游쮺omponente ProductsList

En la carpeta `features/products/components` incluimos los componentes Products y ProductItem, que se encargar치n de mostrar la lista de productos y los cada producto concreto en la lista, respectivamente.

El componente **ProductsList** es el **contenedor**, que obtiene los datos del servicio y los pasa a los componentes presentadores ProductItem.

```tsx
export const ProductsList: React.FC = () => {
  const [products, setProducts] = useState<Product[]>([]);

  useEffect(() => {
    const products = getProducts();
    // eslint-disable-next-line react-hooks/set-state-in-effect
    setProducts(products);
  }, []);

  return (
    <ul className="products-list">
      {products.map((item) => (
        <li key={item.id}>
          <ProductsCard item={item} />
        </li>
      ))}
    </ul>
  );
};
```

El servicio es de momento s칤ncrono, por lo que no necesitamos el llamarlo con useEffect. Incluso tenemos que deshabilitar una regla del linter que nos sugiere que no lo hagamos. Aun as칤, lo hacemos como si fuera as칤ncrono, que es lo que ocurrir치 en la realidad.

#### 游쮺omponente ProductCard: botones editar y borrar

El componente **ProductCard** es el **presentador**, que recibe los datos del producto por props y los renderiza. En este caso, incluye dos botones para editar y borrar el producto.

```tsx
type Props = {
  item: Product;
  onEdit: (item: Product) => void;
  onDelete: (id: string) => void;
};

export const ProductsCard: React.FC<Props> = ({ item, onEdit, onDelete }) => {
  const handleEdit = () => {
    console.log('Edit product');
    onEdit(item);
  };

  const handleDelete = () => {
    console.log('Delete product');
    onDelete(item.id);
  };

  return (
    <Card title={item.name}>
      <article className="product-card">
        <p>id: {item.id}</p>
        <p>Model: {item.model}</p>
        <p>Class: {item.vehicleClass}</p>
      </article>

      <button onClick={handleEdit}>Editar</button>
      <button onClick={handleDelete}>Borrar</button>
    </Card>
  );
};
```

La funcionalidad de los botones no puede depender s칩lo de este componente, que es un mero presentador. En lugar de eso, recibe desde el contenedor dos funciones por props, onEdit y onDelete, que se ejecutan al hacer clic en los botones. Al hablar de la asincron칤a veremos estas funciones en acci칩n.

Por convenio de React, las funciones que se pasan por props para manejar eventos suelen empezar por `on...` y las funciones que se definen en el componente para gestionar los eventos suelen empezar por `handle...`

#### 游쮺omponente ProductList: L칩gica del estado

El componente contenedor (ProductList) gestiona el estado de la lista de productos, define las funciones que lo gestionan y pasa los datos y funciones necesarias a los componentes presentadores.

En este caso, como el estado es un array de productos, las funciones se encargar치n de modificarlo empleando las funciones de array correspondientes.

```tsx
const [showForm, setShowForm] = useState<boolean>(false);
const [activeProduct, setActiveProduct] = useState<Product | null>(null);

const handleEdit = (item: Product): void => {
  setShowForm(true);
  setActiveProduct(item);
};

const handleDelete = (id: string): void => {
  setProducts((prevProducts) =>
    prevProducts.filter((product) => product.id !== id)
  );
};
```

Recordemos que, de momento, trabajamos con un mock de productos, por lo que sus modificaciones solo se producen en memoria y no tienen persistencia.

Para la edici칩n

- necesitamos tener un formulario y hacerlo visible cuando se invoque el proceso de edici칩n de un item concreto.
- que el formulario conozca el item que se va a editar.

Creamos

- un estado showForm que controla la visibilidad del formulario
- un estado activeProduct que contiene el producto que se va a editar
- una funci칩n handleEdit que lo activa. A continuaci칩n veremos el formulario.

En el renderizado del componente, mostramos condicionalmente

- el formulario de edici칩n, pas치ndole el producto activo y la funci칩n onClose que se ejecuta al cerrar el formulario.
- la lista de productos, pas치ndole las funciones de edici칩n y borrado a cada item.

```tsx
return showForm ? (
  activeProduct && (
    <ProductForm item={activeProduct} onClose={handleCloseEditForm} />
  )
) : (
  <ul className="products-list">
    {products.map((item) => (
      <li key={item.id}>
        <ProductsCard
          item={item}
          onDelete={handleDelete}
          onEdit={handleEditForm}
        />
      </li>
    ))}
  </ul>
);
```

#### 游쮺omponente ProductForm: edici칩n de productos

Creamos un formulario controlado de react para editar un producto. El formulario recibe por props el producto a editar y una funci칩n onClose que se ejecuta al cerrar el formulario.

Para controlar el estado del formulario, se crea un estado local product que se inicializa con el producto recibido por props.

```tsx
type Props = {
  item: Product;
  onClose: (product: Product | null) => void;
};

export const ProductForm: React.FC<Props> = ({ item, onClose }) => {
  // Estados locales para los campos del formulario
  const [product, setProduct] = useState<Product>(item || newProduct);

  return (
    <Card title={product?.name}>
      <form
        className="product-form"
        onSubmit={handleSave}
        onReset={handleReset}
      >
        {/* Controles del formulario */}
        <div className="buttons-group">
          <button type="submit">Guardar</button>
          <button type="reset">Cancelar</button>
        </div>
      </form>
    </Card>
  );
};
```

En el componente tendremos los m칠todos para

- gestionar los cambios en los campos del formulario, como en cualquier formulario controlado de React
- el evento submit
- el evento reset

```tsx
const handleReset = (): void => {
  onClose(null);
};

const handleSave = (event: React.FormEvent<HTMLFormElement>): void => {
  event.preventDefault();
  onClose(product);
};

const handleChange = (event: React.ChangeEvent<HTMLInputElement>): void => {
  const { value, name } = event.target;
  console.log('Change form', name, value);
  setProduct({
    ...product,
    [name]: value,
  });
};
```

La respuesta a los eventos submit y reset es llamar a la funci칩n onClose pasada por props, enviando el producto modificado o null si se ha cancelado la edici칩n.

#### 游쮺omponente ProductList: editando productos

En el componente contenedor ProductsList, ya vimos que se a침ad칤a el formulario de edici칩n, que se muestra u oculta seg칰n el estado showForm.

Nos falta definir la funci칩n que se pasa al formulario para gestionar el cierre y la actualizaci칩n del producto (`handleCloseEditForm`).

```tsx
const handleCloseEditForm = (product: Product | null): void => {
  setShowForm(false);
  setActiveProduct(null);
  if (product) {
    handleUpdateProducts(product);
  }
};

const handleUpdateProducts = (updatedProduct: Product): void => {
  setProducts((prevProducts) => {
    const index = prevProducts.findIndex((p) => p.id === updatedProduct.id);
    if (index !== -1) {
      const updatedProducts = [...prevProducts];
      updatedProducts[index] = updatedProduct;
      return updatedProducts;
    }
    return prevProducts;
  });
};
```

LA funci칩n `handleCloseEditForm` ser치 ejecutada en el formulario al cerrar. Se encarga de ocultar el formulario y, si se ha recibido un producto modificado, llama a la funci칩n `handleUpdateProducts`, que actualiza el array de productos en el estado.

En la actualizaci칩n del array, se busca el 칤ndice del producto modificado y se crea un nuevo array con el producto actualizado.

Una alternativa m치s habitual es usar `map` para crear el nuevo array:

```tsx
const handleUpdateProducts = (updatedProduct: Product): void => {
  setProducts((prevProducts) =>
    prevProducts.map((product) =>
      product.id === updatedProduct.id ? updatedProduct : product
    )
  );
};
```

#### 游쮺omponente ProductList: a침adir productos

El componente contenedor ProductsList tambi칠n puede gestionar la adici칩n de nuevos productos. Para ello, se a침ade un bot칩n "Add Product" que muestra el mismo formulario que al editar con un producto vac칤o.

- el estado showForm, en lugar de boolean, tendr치 el tipo '' | 'add' | 'edit' y se inicializa con una cadena vac칤a
- handleEditForm se adapta para establecer el estado a 'edit'
- handleCloseForm se adapta para llamar a
  - handleUpdateProducts si se ha modificado un producto existente
  - handleAddProduct si se ha a침adido un producto nuevo
- se crea la funci칩n handleAddForm que establece el estado a 'add' y el producto activo a un producto vac칤o
- se crea la funci칩n handleAddProduct que a침ade el nuevo producto al array de productos en el estado

```tsx
export const ProductsList: React.FC = () => {
    const [products, setProducts] = useState<Product[]>([]);
    const [showForm, setShowForm] = useState<'' | 'add' | 'edit'>('');
    const [activeProduct, setActiveProduct] = useState<Product | null>(null);


    const handleEditForm = (item: Product): void => {
        setShowForm('edit');
        setActiveProduct(item);
    };

    const handleAddForm = (): void => {
        setShowForm('add');
        if (activeProduct) {
            setActiveProduct(null);
        }
    };

    const handleCloseForm = (product: Product | null): void => {
        setShowForm('');
        setActiveProduct(null);
        if (product) {
            if (showForm === 'edit') {
                handleUpdateProduct(product);
            } else if (showForm === 'add') {
                handleAddProduct(product);
            }
        }
    };

    const handleUpdateProduct = (updatedProduct: Product): void => {
        setProducts((prevProducts) =>
            prevProducts.map((product) =>
                product.id === updatedProduct.id ? updatedProduct : product
            )
        );
    };

    const handleAddProduct = (newProduct: Product): void => {
        newProduct.id = crypto.randomUUID().slice(0, 4);
        setProducts((prevProducts) => [newProduct, ...prevProducts]);
    };
```

#### 游쮺omponente ProductForm: editar y a침adir productos

Modificamos el componente ProductForm para que pueda usarse tanto para editar como para a침adir productos.

- Si el producto recibido por props es null, se inicializa el estado local con un producto vac칤o
- si el estado local del producto tiene id, el formulario est치 en modo edici칩n; si no, est치 en modo a침adir
- el t칤tulo del formulario y el bot칩n de guardar cambian seg칰n el modo
- el campo id es de solo lectura en modo edici칩n y no se muestra en modo a침adir

```tsx
export const ProductForm: React.FC<Props> = ({ item, onClose }) => {
  const [product, setProduct] = useState<Product>(item || newProduct);

  const handleReset = (): void => {
    onClose(null);
  };

  const handleSave = (event: React.FormEvent<HTMLFormElement>): void => {
    event.preventDefault();
    onClose(product);
  };

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>): void => {
    const { value, name } = event.target;
    setProduct({
      ...product,
      [name]: value,
    });
  };

  return (
    <Card title={product.name || 'A침adir veh칤culo'}>
      <form
        className="product-form"
        onSubmit={handleSave}
        onReset={handleReset}
      >
        {product.id && (
          <div className="control-group">
            <label htmlFor="id">
              <span>ID:</span>
              <input type="text" id="id" value={product.id} readOnly />
            </label>
          </div>
        )}
        {/* resto  de controles del formulario*/}
        <div className="buttons-group">
          <button type="submit">
            {product.id === '' ? 'A침adir' : 'Guardar'}
          </button>
          <button type="reset">Cancelar</button>
        </div>
      </form>
    </Card>
  );
};
```

### Rutas din치micas

En las rutas se incluye una nueva, con el patron din치mico `/product/:id` Si estamos usando el modo declarativo, se a침ade en el componente AppRoutes:

```tsx
<Routes>
  <Route path="/" element={<Layout title={title} />}>
    ...
    <Route path="product/:id" element={<ProductDetail />} />
    ...
  </Route>
</Routes>
```

En el modo data, se a침ade en el array de rutas:

```tsx
{
  {
    path: 'product/:id',
    lazy: {
      Component: async () =>
        (await import('@features/products/products-page'))
          .ProductsPage,
    },
  },
}
```

En este caso, la ruta din치mica apunta a la misma p치gina ProductsPage, que montar치 diferentes componentes seg칰n el caso. La ruta din치mica podr칤a apuntar a un componente espec칤fico ProductDetail si se prefiere. En cualquier caso, la ruta no tiene la propiedad id. lo que evita que aparezca en el men칰.

#### 游쮺omponente ProductCard: acceso a una ruta din치mica

En al componente `ProductCard` se renderizan los datos b치sicos del producto. Se incluye un elemento (bot칩n) con un link con una **ruta din치mica**:

- parte fija: `/products/`
- segmento din치mica: el id de cada producto, que ser치 identificado como `:id`

```tsx
type Props = {
  item: Product;
};

export const ProductsCard: React.FC<Props> = ({ item }) => {
  return (
    <Card title={item.name}>
      <article className="product-card">
        <p>id: {item.id}</p>
        <p>Model: {item.model}</p>
        <p>Class: {item.vehicleClass}</p>
      </article>
      <Link to={'/product/' + item.id}>
        <button>Details</button>
      </Link>
    </Card>
  );
};
```

#### Uso de rutas din치micas en el componente: useParams y useNavigate

La pagina de productos, determina que componente montar obteniendo los par치metros de la ruta con el hook `useParams` de React Router.

```tsx
export const ProductsPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();

  return (
    <section className="products">
      <h2>Products</h2>
      {id ? <ProductsDetail id={id} /> : <ProductsList />}
    </section>
  );
};

export default ProductsPage;
```

#### 游쮺omponente ProductDetail

El componente `ProductDetail`

- recibe el id por props (podr칤a obtenerlo de la ruta con useParams si se cargara directamente)
- recupera el resto de los datos del producto usando la funci칩n `getProductById` del servicio

Como en el caso de ProductsList, actuamos como si el servicio fuera as칤ncrono, que es lo que ocurrir치 en la realidad

```tsx
useEffect(() => {
  const product = getProductById(id);
  // eslint-disable-next-line react-hooks/set-state-in-effect
  setProduct(product);
}, [id]);
```

Ademas se a침ade un bot칩n de volver a la lista de productos como ejemplo de navegaci칩n program치tica, que utiliza el hook `useNavigate` de React Router:

```tsx
const navigate = useNavigate();

const handleBack = (): void => {
  navigate('/products');
};
```

Finalmente, el JSX renderiza

- los detalles del producto
- un mensaje de aviso si no se ha encontrado el producto.

Esto 칰ltimo se puede probar f치cilmente poniendo un id inv치lido en la URL del navegador.

```tsx
 return (
        <article className='product-detail'>
            <Card title={product?.name}>
                {product ? (
                    <article className="product-card">
                        <dl>
                            <dt>ID:</dt>
                            <dd>{product.id}</dd>
                            <dt>Nombre:</dt>
                            <dd>{product.name}</dd>
                            <dt>Modelo:</dt>
                            <dd>{product.model}</dd>
                            <dt>Clase:</dt>
                            <dd>{product.vehicleClass}</dd>
                            <dt>Fabricante:</dt>
                            <dd>{product.manufacturer}</dd>
                            <dt>Costo en cr칠ditos:</dt>
                            <dd>{product.costs}</dd>
                            <dt>Longitud:</dt>
                            <dd>{product.length}</dd>
                            <dt>Tripulaci칩n:</dt>
                            <dd>{product.crew}</dd>
                            <dt>Pasajeros:</dt>
                            <dd>{product.passengers}</dd>
                            <dt>Velocidad atmosf칠rica m치xima:</dt>
                            <dd>{product.maxSpeed}</dd>
                            <dt>Capacidad de carga:</dt>
                            <dd>{product.cargoCapacity}</dd>
                            <dt>Consumibles:</dt>
                            <dd>{product.consumables}</dd>
                        </dl>
                    </article>
                ) : (
                    <p>Invalid product id [{id}]</p>
                )}
                <button onClick={handleBack}>Back to products list</button>
            </Card>
        </article>
    );
};
```

## Patrones de abstracci칩n de datos

### Patr칩n layer

El patr칩n layer (capa) es una forma de estructurar una aplicaci칩n dividi칠ndola en capas separadas, cada una con responsabilidades espec칤ficas. Esto ayuda a mantener el c칩digo organizado, facilita el mantenimiento y mejora la escalabilidad de la aplicaci칩n.

En React, podemos aplicar el patr칩n layer utilizando custom hooks, para separar la l칩gica de presentaci칩n (componente) y la l칩gica de negocio (hook que gestiona el estado).

#### 丘뙖잺Hook useProducts

En nuestro ejemplo, podr칤amos crear un custom hook `useProducts` que encapsule la l칩gica de obtenci칩n y gesti칩n de productos, mientras que el componente `ProductsList` se encargue 칰nicamente de la presentaci칩n.

```tsx
type UseProductsReturn = {
  products: Product[];
  handleAddProduct: (newProduct: Product) => void;
  handleUpdateProduct: (updatedProduct: Product) => void;
  handleDeleteProduct: (id: string) => void;
};

export const useProducts = (): UseProductsReturn => {
  const [products, setProducts] = useState<Product[]>([]);

  const handleAddProduct = (newProduct: Product): void => {
    newProduct.id = crypto.randomUUID().slice(0, 4);
    setProducts((prevProducts) => [newProduct, ...prevProducts]);
  };

  const handleUpdateProduct = (updatedProduct: Product): void => {
    setProducts((prevProducts) =>
      prevProducts.map((product) =>
        product.id === updatedProduct.id ? updatedProduct : product
      )
    );
  };
  const handleDeleteProduct = (id: string): void => {
    setProducts((prevProducts) =>
      prevProducts.filter((product) => product.id !== id)
    );
  };

  useEffect(() => {
    const products = getProducts();
    // eslint-disable-next-line react-hooks/set-state-in-effect
    setProducts(products);
  }, []);

  return {
    products,
    handleAddProduct,
    handleUpdateProduct,
    handleDeleteProduct,
  };
};
```

El componente `ProductsList` utilizar칤a el hook para obtener los productos y las funciones de gesti칩n:

```tsx
export const ProductsList: React.FC = () => {
  const [showForm, setShowForm] = useState<'' | 'add' | 'edit'>('');
  const [activeProduct, setActiveProduct] = useState<Product | null>(null);

  const { products, handleAddProduct, handleUpdateProduct, handleDelete } =
    useProducts();

  const handleEditForm = (item: Product): void => {
    setShowForm('edit');
    setActiveProduct(item);
  };

  const handleAddForm = (): void => {
    setShowForm('add');
    if (activeProduct) {
      setActiveProduct(null);
    }
  };

  const handleCloseForm = (product: Product | null): void => {
    setShowForm('');
    setActiveProduct(null);
    if (product) {
      if (showForm === 'edit') {
        handleUpdateProduct(product);
      } else if (showForm === 'add') {
        handleAddProduct(product);
      }
    }
  };

  return showForm ? (
    <ProductForm item={activeProduct} onClose={handleCloseForm} />
  ) : (
    <>
      <button onClick={handleAddForm}>A침adir veh칤culo</button>
      <ul className="products-list">
        {products.map((item) => (
          <li key={item.id}>
            <ProductsCard
              item={item}
              onDelete={handleDelete}
              onEdit={handleEditForm}
            />
          </li>
        ))}
      </ul>
    </>
  );
};
```

Los m칠todos de gesti칩n de productos se obtienen del hook, manteniendo el componente limpio y enfocado en la presentaci칩n, incluyendo los m칠todos para mostrar/ocultar el formulario para manejar la edici칩n y adici칩n de productos.

Se podr칤a incluso crear un segundo hook `useProductForm` para encapsular la l칩gica de mostrar/ocultar el formulario mencionada anteriormente.

```tsx
export const useProductForm = (initialProduct: Product | null) => {
  const [showForm, setShowForm] = useState<'' | 'add' | 'edit'>('');
  const [activeProduct, setActiveProduct] = useState<Product | null>(
    initialProduct
  );

  const handleEditForm = (item: Product): void => {
    setShowForm('edit');
    setActiveProduct(item);
  };

  const handleAddForm = (): void => {
    setShowForm('add');
    if (activeProduct) {
      setActiveProduct(null);
    }
  };

  const handleCloseForm = (product: Product | null): void => {
    setShowForm('');
    setActiveProduct(null);
    return product;
  };

  return {
    showForm,
    activeProduct,
    handleEditForm,
    handleAddForm,
    handleCloseForm,
  };
};
```

Este 칰ltimo hook no lo hemos implementado en el ejemplo, pero se deja aqu칤 como una posible mejora para quien quiera profundizar en el patr칩n layer.

### [Avanzado] Patr칩n repositorio

El patr칩n repositorio es una forma de estructurar el acceso a los datos en una aplicaci칩n, proporcionando una capa de abstracci칩n entre la l칩gica de negocio y la fuente de datos. En lugar de interactuar directamente con la base de datos o el servicio de datos, la l칩gica de negocio utiliza un repositorio para realizar operaciones CRUD (Crear, Leer, Actualizar, Borrar) sobre las entidades.

#### 丘뙖잺Servicio ProductsRepository: repositorio de productos

En nuestro ejemplo, podr칤amos crear un repositorio para gestionar los productos, encapsulando las funciones de acceso a los datos que ahora est치n en ProductsList en una clase o conjunto de funciones.

Como se trata de un concepto independiente de React, se suele decir que es agn칩stico al framework, por lo que el repositorio se puede implementar en una carpeta separada, por ejemplo `./services` y en un fichero `products-repository.ts`. La extensi칩n ts nos indica que es un m칩dulo independiente de React, que no utiliza ni hooks ni componentes.

```tsx
const products = getProducts();

export const productsRepository = {
  getAll: (): Product[] => {
    return products;
  },
  getById: (id: string): Product | null => {
    return products.find((product) => product.id === id) || null;
  },

  add: (newProduct: Product): Product => {
    newProduct.id = crypto.randomUUID().slice(0, 4);
    products.push(newProduct);
    return newProduct;
  },

  update: (updatedProduct: Product): Product | null => {
    const index = products.findIndex(
      (product) => product.id === updatedProduct.id
    );
    if (index !== -1) {
      products[index] = updatedProduct;
      return updatedProduct;
    }
    return null;
  },

  delete: (id: string): boolean => {
    const index = products.findIndex((product) => product.id === id);
    if (index !== -1) {
      products.splice(index, 1);
      return true;
    }
    return false;
  },
};
```

El servicio tiene un array con los datos, que se crea una sola vez, al importar el m칩dulo. El repositorio expone m칠todos para realizar las operaciones CRUD sobre los productos. Solo se incluye una l칩gica de manipulaci칩n de arrays en memoria con m칠todos de JS, sin dependencias con ning칰n framework, incluido React.

El hook `useProducts` se adapta para utilizar el repositorio en lugar del servicio directamente:

```tsx
type UseProductsReturn = {
  products: Product[];
  handleAddProduct: (newProduct: Product) => void;
  handleUpdateProduct: (updatedProduct: Product) => void;
  handleDelete: (id: string) => void;
};

export const useProducts = (): UseProductsReturn => {
  const [products, setProducts] = useState<Product[]>([]);

  const handleDelete = (id: string): void => {
    productsRepository.delete(id);
    setProducts(productsRepository.getAll());
  };

  const handleUpdateProduct = (updatedProduct: Product): void => {
    productsRepository.update(updatedProduct);
    setProducts(productsRepository.getAll());
  };

  const handleAddProduct = (newProduct: Product): void => {
    productsRepository.add(newProduct);
    setProducts(productsRepository.getAll());
  };

  useEffect(() => {
    // eslint-disable-next-line react-hooks/set-state-in-effect
    setProducts(productsRepository.getAll());
  }, []);

  return {
    products,
    handleAddProduct,
    handleUpdateProduct,
    handleDelete,
  };
};
```

En el hook se utilizan los m칠todos del repositorio para realizar las operaciones sobre los productos, manteniendo la l칩gica de acceso a los datos separada de la l칩gica de negocio, que corresponde al estado de React. Por su parte. la l칩gica de presentaci칩n sigue en el componente ProductsList, que no necesita hacer ning칰n cambio, ya que el hook no ha cambiado su interfaz..
