# Elementos b√°sicos de React: Componentes y Hooks

- [Elementos b√°sicos de React: Componentes y Hooks](#elementos-b√°sicos-de-react-componentes-y-hooks)
  - [Componentes](#componentes)
    - [Componentes y funciones](#componentes-y-funciones)
      - [Tipado de componentes en TypeScript](#tipado-de-componentes-en-typescript)
    - [Construcci√≥n de componentes: Componentizaci√≥n](#construcci√≥n-de-componentes-componentizaci√≥n)
      - [Scaffolding inicial](#scaffolding-inicial)
        - [üßøComponente Header](#componente-header)
        - [üßøComponente Footer](#componente-footer)
        - [üßøComponente Counter](#componente-counter)
        - [üßøComponente App despu√©s de la migraci√≥n](#componente-app-despu√©s-de-la-migraci√≥n)
      - [Componentizaci√≥n y responsabilidades](#componentizaci√≥n-y-responsabilidades)
        - [üßøComponente Logos](#componente-logos)
    - [Componentes y Props](#componentes-y-props)
      - [Props](#props)
        - [üßøComponente Header refactorizado: props](#componente-header-refactorizado-props)
        - [Props en TypeScript](#props-en-typescript)
      - [Children](#children)
        - [üßøComponente Card: children](#componente-card-children)
        - [Children, componentizaci√≥n y responsabilidades](#children-componentizaci√≥n-y-responsabilidades)
        - [üßøComposici√≥n: Logos, Header y App](#composici√≥n-logos-header-y-app)
    - [Estilos en los componentes](#estilos-en-los-componentes)
      - [CSS tradicional](#css-tradicional)
        - [Estilos en l√≠nea](#estilos-en-l√≠nea)
        - [Estilos en los componentes ya creados](#estilos-en-los-componentes-ya-creados)
        - [üßøComponente Menu](#componente-menu)
      - [CSS Modules](#css-modules)
        - [üßøComponente PanicButton (sin funcionalidad)](#componente-panicbutton-sin-funcionalidad)
    - [Componentizaci√≥n y composici√≥n de componentes](#componentizaci√≥n-y-composici√≥n-de-componentes)
      - [üßøComponente Layout](#componente-layout)
      - [Resultado final. Props drilling y children](#resultado-final-props-drilling-y-children)
        - [Props drilling](#props-drilling)
        - [üßøComponente App final](#componente-app-final)
        - [üßøComponente Layout final](#componente-layout-final)
  - [Componentes din√°micos. Eventos](#componentes-din√°micos-eventos)
    - [Condiciones en los componentes](#condiciones-en-los-componentes)
      - [üßøComponente Greetings: Renderizado condicional](#componente-greetings-renderizado-condicional)
    - [Iteraciones: renderizado de listas](#iteraciones-renderizado-de-listas)
      - [üßøComponente Menu refactorizado](#componente-menu-refactorizado)
    - [Manejo de Eventos](#manejo-de-eventos)
      - [üßøComponente PanicButton con funcionalidad](#componente-panicbutton-con-funcionalidad)
      - [Props funcionales](#props-funcionales)
      - [üßøComponente Button gen√©rico y su uso en PanicButton](#componente-button-gen√©rico-y-su-uso-en-panicbutton)
      - [El objeto evento como par√°metro en los manejadores de eventos](#el-objeto-evento-como-par√°metro-en-los-manejadores-de-eventos)
      - [Objetos de Eventos en React: SyntheticEvent](#objetos-de-eventos-en-react-syntheticevent)
        - [\[Avanzado\] Usos avanzados del tipado de eventos en React](#avanzado-usos-avanzados-del-tipado-de-eventos-en-react)
        - [Par√°metros adicionales](#par√°metros-adicionales)
  - [Hooks](#hooks)
    - [Reglas de los hooks](#reglas-de-los-hooks)
    - [Hooks y Estado: useState](#hooks-y-estado-usestate)
      - [Componentes sin estado](#componentes-sin-estado)
        - [üßøComponente CounterNoState](#componente-counternostate)
      - [Componentes con estado: useState](#componentes-con-estado-usestate)
        - [üßøComponente Counter: estado](#componente-counter-estado)
        - [La funci√≥n de estado](#la-funci√≥n-de-estado)
        - [Estado local y componentes](#estado-local-y-componentes)
        - [Caracter√≠sticas del estado en React](#caracter√≠sticas-del-estado-en-react)
        - [Tipado de estados en TypeScript](#tipado-de-estados-en-typescript)
      - [Estados y renderizaci√≥n](#estados-y-renderizaci√≥n)
        - [Renderizaci√≥n y virtual DOM](#renderizaci√≥n-y-virtual-dom)
        - [Props y renderizado](#props-y-renderizado)
      - [Multiples estados](#multiples-estados)
        - [üßøComponente CounterLogin con m√∫ltiples estados](#componente-counterlogin-con-m√∫ltiples-estados)
      - [Estados compartidos entre componentes](#estados-compartidos-entre-componentes)
        - [üßøComponente CounterContainer. Practica: Hooks, Estado y Eventos](#componente-countercontainer-practica-hooks-estado-y-eventos)
    - [Efectos secundarios: useEffect](#efectos-secundarios-useeffect)
      - [Ejecuci√≥n del efecto: el array de dependencias](#ejecuci√≥n-del-efecto-el-array-de-dependencias)
      - [üßøComponente BasicTimer](#componente-basictimer)
      - [Limpieza de efectos](#limpieza-de-efectos)
      - [üßøComponente Counter: useEffect con dependencias](#componente-counter-useeffect-con-dependencias)
      - [üßøComponente Counter: multiples useEffect](#componente-counter-multiples-useeffect)
      - [üßøComponente FullTimer: ejemplo final de useEffect](#componente-fulltimer-ejemplo-final-de-useeffect)
      - [Buenas practicas con los efectos](#buenas-practicas-con-los-efectos)
      - [Objetos (arrays, funciones) como dependencias](#objetos-arrays-funciones-como-dependencias)
    - [Referencias persistentes: useRef, useMemo, useCallback](#referencias-persistentes-useref-usememo-usecallback)
      - [Ref a elementos del DOM](#ref-a-elementos-del-dom)
        - [\[Avanzado\] Paso de referencias entre componentes: forwardRef](#avanzado-paso-de-referencias-entre-componentes-forwardref)
        - [\[Avanzado\] La prop `ref` en React 19](#avanzado-la-prop-ref-en-react-19)
      - [Referencias inmutables](#referencias-inmutables)
  - [Formularios](#formularios)
    - [Tipos de formularios en React](#tipos-de-formularios-en-react)
    - [Formularios controlados con un campo](#formularios-controlados-con-un-campo)
      - [üßø Componente SearchForm: formulario controlado](#-componente-searchform-formulario-controlado)
      - [\[Avanzado\] Ejemplos de useRef: foco y debounce](#avanzado-ejemplos-de-useref-foco-y-debounce)
        - [üßø Componente SearchFormPro: debounce y foco](#-componente-searchformpro-debounce-y-foco)
    - [Formularios controlados con m√∫ltiples campos](#formularios-controlados-con-m√∫ltiples-campos)
      - [üßø Componente LoginForm b√°sico: useId](#-componente-loginform-b√°sico-useid)
      - [üßø Componente LoginForm con otros controles](#-componente-loginform-con-otros-controles)
    - [Validaci√≥n de formularios](#validaci√≥n-de-formularios)
      - [üßø Componente LoginForm con validaci√≥n](#-componente-loginform-con-validaci√≥n)
    - [Formularios no controlados. FormData](#formularios-no-controlados-formdata)
      - [üßø Componente RegisterForm: JSX (casi HTML)](#-componente-registerform-jsx-casi-html)
      - [Accediendo a los valores del formulario](#accediendo-a-los-valores-del-formulario)
      - [FormData](#formdata)
      - [Funci√≥n para obtener los datos del formData](#funci√≥n-para-obtener-los-datos-del-formdata)
    - [Componentes creados](#componentes-creados)

## Componentes

Los componentes son la unidad b√°sica de construcci√≥n en React.

Como hemos visto, en React actual, un componente es una **funci√≥n** de JavaScript que devuelve un elemento JSX (JavaScript XML), que es una sintaxis similar a HTML que se utiliza para describir la estructura de la interfaz de usuario.

Los componentes pueden ser reutilizados en diferentes partes de la aplicaci√≥n, lo que facilita la creaci√≥n y el mantenimiento de interfaces de usuario complejas.

### Componentes y funciones

Para que una funci√≥n de JS sea considerada un componente de React, debe cumplir las siguientes reglas:

- El nombre del componente debe comenzar con una letra may√∫scula (**PascalCase**). Esto es importante porque React utiliza esta convenci√≥n para distinguir entre componentes y elementos HTML nativos.
- La funci√≥n debe devolver algo que React **pueda renderizar**:
  - un elemento JSX. Esto se hace utilizando la sintaxis JSX dentro del cuerpo de la funci√≥n.
  - un valor nulo, undefined o booleano (por ejemplo, `null` o `false`) para indicar que no se debe renderizar nada.
  - un string o un n√∫mero, que se renderizar√°n como texto.
- La funci√≥n puede recibir un objeto de props como primer par√°metro, que contiene los datos que se pasan al componente desde su padre.

Es importante no confundir:

- el componente: la funci√≥n que define el componente
- el elemento JSX que representa al componente, que es lo que devuelve la funci√≥n del componente.

A diferencia de otras funciones, los componentes se invocan de forma **declarativa** utilizando la sintaxis JSX, que es similar a HTML. Asi sucede ya desde el fichero main.tsx cuando se invoca el componente principal `App`:

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './App';
ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

Otros aspectos que definen al componente son:

- El componente puede utilizar hooks de React para manejar el estado y los efectos secundarios.
- El componente debe ser una funci√≥n pura, lo que significa que no debe modificar sus props ni tener efectos secundarios fuera de su √°mbito.
- El componente puede ser exportado e importado en otros archivos para su reutilizaci√≥n.
- El componente puede ser utilizado dentro de otros componentes, creando una jerarqu√≠a de componentes.
- El componente puede tener componentes hijos, que se pasan como props especiales llamadas `children`.

#### Tipado de componentes en TypeScript

En typescript, los componentes se pueden tipar como cualquier otra funci√≥n, indicando el tipo de dato que devuelve. Suele considerarse una buena pr√°ctica tipar expl√≠citamente el tipo de dato devuelto por cualquier funci√≥n, incluyendo componentes funcionales. En el caso de estos, se puede indicar el tipo de dato devuelto utilizando `JSX.Element`. Por ejemplo:

```tsx
import React from 'react';
export const App = (): JSX.Element => {
  return (
    <div>
      <h1>Hello, React!</h1>
      <p>This is a simple React example with JSX.</p>
    </div>
  );
};
```

Alternativamente, desde hace varias versiones, React ha sido reescrito en TypeScript e incluye tipos seguros para todos sus elementos, incluyendo un tipo gen√©rico `React.FC` (Functional Component) que puede utilizarse para tipar componentes funcionales. Por ejemplo:

```tsx
import React from 'react';
export const App: React.FC = () => {
  return (
    <div>
      <h1>Hello, React!</h1>
      <p>This is a simple React example with JSX.</p>
    </div>
  );
};
```

### Construcci√≥n de componentes: Componentizaci√≥n

La componentizaci√≥n es el proceso de dividir una interfaz de usuario en componentes m√°s peque√±os y reutilizables.

Cada componente debe tener una **√∫nica responsabilidad** o funci√≥n dentro de la aplicaci√≥n, lo que facilita su mantenimiento y reutilizaci√≥n. Esto se conoce como el principio de **single responsibility**, que junto con otros da lugar a los principios SOLID de dise√±o de software. La letra S de SOLID hace referencia a este principio.

El proceso de migraci√≥n de una aplicaci√≥n monol√≠tica a una basada en componentes implica identificar las partes de la interfaz de usuario que pueden ser convertidas en componentes independientes. Esto puede incluir elementos como botones, formularios, listas, tarjetas, men√∫s, etc. Cada uno de estos elementos puede ser convertido en un componente independiente que pueda ser reutilizado en diferentes partes de la aplicaci√≥n.

En nuestro caso haremos un sencillo ejercicio de componentizaci√≥n al migrar la aplicaci√≥n ejemplo de Vite, con un √∫nico componente App, dividiendo la interfaz de usuario en varios componentes independientes que se encargar√°n de renderizar diferentes partes de la aplicaci√≥n.

Podemos ver que App incluye tres elementos principales:

- la parte inicial con logotipos, enlaces desde los logotipos y titulo
- el contador, con un texto aclaratorio sobre el HMR
- una line final con instrucciones

Teniendo en cuenta que esto es s√≥lo un ejercicio did√°ctico, podemos dividir la interfaz de usuario en los siguientes componentes:

- `Header`: se encargar√° de renderizar la parte inicial con los logotipos y el t√≠tulo.
- `Counter`: se encargar√° de renderizar el contador y el texto aclaratorio sobre el HMR.
- `Footer`: se encargar√° de renderizar la l√≠nea final con las instrucciones.

#### Scaffolding inicial

El t√©rmino **scaffolding** (andamiaje) se refiere al proceso de crear la estructura b√°sica de un proyecto o aplicaci√≥n, incluyendo la creaci√≥n de archivos y carpetas necesarios para comenzar a trabajar en el proyecto. En el contexto de React, el scaffolding inicial implica crear la estructura de carpetas y archivos para una aplicaci√≥n React, incluyendo los componentes principales y los archivos de configuraci√≥n necesarios.

Uno de los enfoques comunes para organizar los componentes en un proyecto React es utilizar una estructura de carpetas que refleje la jerarqu√≠a de los componentes. Por ejemplo, se puede crear una carpeta `components` dentro de la carpeta `src`, y dentro de `components` crear subcarpetas para cada componente. Cada subcarpeta puede contener el archivo del componente, su archivo CSS (si es necesario) y cualquier otro archivo relacionado con el componente.

Otra alternativa de scaffolding, conocida como **feature-based structure** (estructura basada en caracter√≠sticas), es organizar los componentes seg√∫n las caracter√≠sticas o funcionalidades de la aplicaci√≥n. En este enfoque, se crean carpetas para cada caracter√≠stica o funcionalidad de la aplicaci√≥n, y dentro de cada carpeta se incluyen los componentes relacionados con esa caracter√≠stica.

En nuestro ejercicio, podemos distinguir los componentes comunes del proyecto y ubicarlos en una carpeta `core/components`, frente a los que representan caracter√≠sticas espec√≠ficas de la aplicaci√≥n, que se ubicar√°n en `features/components`. De este modo, la estructura de carpetas del proyecto quedar√° de la siguiente manera:

```plaintext
src
‚îú‚îÄ‚îÄ core
‚îÇ    ‚îî‚îÄ‚îÄ components
‚îÇ         ‚îú‚îÄ‚îÄ Header.tsx
‚îÇ         ‚îú‚îÄ‚îÄ Footer.tsx
‚îú‚îÄ‚îÄ features
‚îÇ    ‚îî‚îÄ‚îÄ home
‚îÇ         ‚îî‚îÄ‚îÄ Counter.tsx
‚îú‚îÄ‚îÄ App.tsx
‚îú‚îÄ‚îÄ main.tsx
‚îî‚îÄ‚îÄ index.css
```

En la carpeta feature crearemos una subcarpeta por cada feature o funcionalidad de la aplicaci√≥n. En este caso, al tratarse de un ejemplo sencillo, crearemos `home`, `counters`, `forms`, donde distribuiremos m√°s adelante los componentes relacionados con cada funcionalidad. Por ahora solo tenemos en la p√°gina de inicio (home) el componente Counter.

##### üßøComponente Header

```tsx
import React from 'react';
import reactLogo from '@assets/react.svg';
import viteLogo from '/vite.svg';
import './header.css';

export const Header: React.FC = () => {
  return (
    <header>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} className="logo" alt="Vite logo" />
        </a>
        <a href="https://react.dev" target="_blank">
          <img src={reactLogo} className="logo react" alt="React logo" />
        </a>
      </div>
      <h1>Vite + TS + React</h1>
    </header>
  );
};
```

Como vemos se incluye la importaci√≥n de los logos y el archivo CSS espec√≠fico para este componente.

A este √∫ltimo moveremos las reglas de estilo que afectan solo a este componente, para mejorar la organizaci√≥n del c√≥digo. Esto NO implica que los estilos tengan scope, es decir que afecten solo al componente ya que todos los estilos son globales.

##### üßøComponente Footer

```tsx
import React from 'react';
import './footer.css';

export const Footer: React.FC = () => {
  return (
    <footer>
      <p className="read-the-docs" id="footer">
        Click on the Vite and React logos to learn more
      </p>
    </footer>
  );
};
```

Adem√°s del CSS incluido en App, a√±adimos estilos para la etiqueta footer, todo ello en un archivo footer.css espec√≠fico para este componente.

```css
.read-the-docs {
  color: #888;
}
footer {
  text-align: center;
  padding: 1em;
  border-top: 1px solid #ddd;
  margin-top: 2em;
}
```

##### üßøComponente Counter

```tsx
import React, { useState } from 'react';

export const Counter: React.FC = () => {
  const [count, setCount] = useState(0);
  return (
    <>
      <button onClick={() => setCount((count) => count + 1)}>
        count is {count}
      </button>
      <p>
        Edit <code>src/App.tsx</code> and save to test HMR
      </p>
    </>
  );
};
```

##### üßøComponente App despu√©s de la migraci√≥n

```tsx
import React from 'react';
import { Header } from '@core/components/Header';
import { Footer } from '@core/components/Footer';
import { Counter } from '@features/home/Counter';

export const App: React.FC = () => {
  return (
    <div className="App">
      <Header />
      <Counter />
      <Footer />
    </div>
  );
};
```

#### Componentizaci√≥n y responsabilidades

Debemos plantear la componentizaci√≥n de una interfaz de usuario teniendo en cuenta no solo la reutilizaci√≥n de componentes, sino tambi√©n
siendo estrictos con la responsabilidad de cada componente.

Por ejemplo, al definir nuestro componente Header, lo definimos como:

- `Header`: se encargar√° de renderizar la parte inicial con los logotipos y el t√≠tulo.

Podemos ver que en realidad son dos responsabilidades diferentes:

- renderizar los logotipos
- renderizar el t√≠tulo

Podr√≠amos extraer la parte de los logotipos a un componente 'Logos', y dejar que Header se encargue solo de renderizar el t√≠tulo, y consumir (invocar) el componente con los logotipos. De este modo, cada componente tiene una √∫nica responsabilidad, lo que facilita su mantenimiento y reutilizaci√≥n.

##### üßøComponente Logos

```tsx
import React from 'react';
import reactLogo from '@assets/react.svg';
import viteLogo from '/vite.svg';
import './logos.css';

export const Logos: React.FC = () => {
  return (
    <div>
      <a href="https://vite.dev" target="_blank">
        <img src={viteLogo} className="logo" alt="Vite logo" />
      </a>
      <a href="https://react.dev" target="_blank">
        <img src={reactLogo} className="logo react" alt="React logo" />
      </a>
    </div>
  );
};
```

No olvidamos reubicar el css, que en este caso solo afecta a los logotipos y los imports de los recursos (im√°genes)

El componente Header quedar√≠a as√≠:

```tsx
export const Header: React.FC = () => {
  return (
    <header>
      <Logos />
      <h1>Vite + TS + React</h1>
    </header>
  );
};
```

### Componentes y Props

La ventaja de utilizar componentes es que permiten reutilizar c√≥digo y organizar la aplicaci√≥n en partes m√°s peque√±as y manejables. Como veremos, los componentes pueden recibir datos a trav√©s de las **props** (abreviatura de "properties" o propiedades), que son un mecanismo para pasar datos de un componente padre a un componente hijo.

Como hemos visto anteriormente, JSX es una extensi√≥n de sintaxis para JavaScript que permite escribir HTML dentro de JavaScript. JSX se compila a JavaScript puro antes de ser ejecutado en el navegador. Pero adem√°s, JSX tiene algunas diferencias con el HTML tradicional, para convertirlo en un c√≥digo m√°s declarativo y seguro.

#### Props

Las props (propiedades) son la forma en que se pasan datos a los componentes en React. Se pueden considerar como los par√°metros de un componente.

- se reciben como un objeto en el primer par√°metro de la funci√≥n del componente.
- son de solo lectura, lo que significa que un componente no puede modificar sus propias props.

##### üßøComponente Header refactorizado: props

Refactorizamos el componente `Header` para que reciba dos props: `title` y `content`. Estas props se utilizan para mostrar un t√≠tulo y un contenido dentro header, a modo de subt√≠tulo.

```tsx
export const Header: React.FC = (props) => {
  return (
    <header>
      <div>{/* logos... */}</div>
      <h1>{props.title}</h1>
      <p>{props.subtitle}</p>
    </header>
  );
};
```

Las props se pasan a los componentes como atributos en JSX. Para utilizar el componente `Header` y pasarle las props, se puede hacer de la siguiente manera:

```tsx
export const App: React.FC = () => {
  return (
    <div>
      <Header
        title="Vite + TS + React"
        subtitle="Ejemplo de React con props."
      />
    </div>
    <Counter />
    <Footer />
  );
};
```

Lo habitual es utilizar la **desestructuraci√≥n** de objetos para extraer las props directamente en la declaraci√≥n de los par√°metros de la funci√≥n, como se mostr√≥ en el primer ejemplo. Por lo tanto, tambi√©n se podr√≠a escribir el componente `Header` de la siguiente manera:

```tsx
export const Header: React.FC = ({ title, subtitle }) => {
  return (
    <header>
      <div>{/* logos... */}</div>
      <h1>Vite + TS + React</h1>
      <h1>{title}</h1>
      <p>{subtitle}</p>
    </header>
  );
};
```

Las props pueden tener valores por defecto, como cualquier par√°metro en JS

```tsx
export const Header: React.FC = ({
  title = 'T√≠tulo por defecto',
  subtitle = 'Subt√≠tulo por defecto',
}) => {
  return (
    <header>
      <div>{/* logos... */}</div>
      <h1>{title}</h1>
      <p>{subtitle}</p>
    </header>
  );
};
```

##### Props en TypeScript

En typescript, los componentes se suelen definir utilizando interfaces para tipar las props que reciben. Por ejemplo:

```tsx
interface Props {
  readonly title: string;
  readonly subtitle: string;
}

export const Header: React.FC<Props> = ({ title, subtitle }) => {
  return (
    <header>
      <div>{/* logos... */}</div>
      <h1>{title}</h1>
      <p>{subtitle}</p>
    </header>
  );
};
```

Una alternativa menos recomendable ser√≠a no utilizar el interface React.FC y tipar las props como un objeto gen√©rico:

```tsx
interface Props {
  readonly title: string;
  readonly content: string;
}

export const Header = ({ title, subtitle }: Props): JSX.Element => {
  return (
    <header>
      <div>{/* logos... */}</div>
      <h1>{title}</h1>
      <p>{subtitle}</p>
    </header>
  );
};
```

#### Children

En React, `children` es una prop especial que permite pasar elementos hijos a un componente aplicando la proyecci√≥n del contenido. Esto es √∫til cuando se desea crear componentes que puedan envolver otros elementos o componentes.

##### üßøComponente Card: children

Por ejemplo, podemos crear un componente `Card` que reciba un t√≠tulo como prop y utilice `children` para renderizar cualquier contenido que se le pase dentro de la tarjeta:

```tsx
interface Props {
  readonly title: string;
  readonly children: React.ReactNode;
}

export const Card: React.FC<Props> = ({ title, children }) => {
  return (
    <div className="card">
      <h2>{title}</h2>
      <div className="card-content">{children}</div>
    </div>
  );
};
```

El tipo `React.ReactNode` es un tipo especial que representa cualquier cosa que pueda ser renderizada en React, incluyendo elementos JSX, cadenas de texto, n√∫meros, fragmentos, arrays de elementos, etc.

Podemos utilizar utilizar el componente `Card` y pasarle elementos hijos, de la siguiente manera:

```tsx
import { Card } from './Card';
export const Counter: React.FC = () => {
  const [count, setCount] = useState(0);
  return (
    <Card>
      <button onClick={() => setCount((count) => count + 1)}>
        count is {count}
      </button>
      <p>
        Edit <code>src/App.tsx</code> and save to test HMR
      </p>
    </Card>
  );
};
```

Una alternativa en el tipado de las props con children es extender la interfaz de las props con `React.PropsWithChildren`, que a√±ade autom√°ticamente la prop `children` al tipo de las props. Por ejemplo:

```tsx
interface Props {
  readonly title: string;
}
export const Card: React.FC<React.PropsWithChildren<Props>> = ({
  title,
  children,
}) => {
  return (
    <div className="card">
      <h2>{title}</h2>
      <div className="card-content">{children}</div>
    </div>
  );
};
```

##### Children, componentizaci√≥n y responsabilidades

Conociendo el concepto de children, podemos plantear la componentizaci√≥n de una interfaz de usuario desde un enfoque conocido como **composici√≥n de componentes**, para facilitar la reutilizaci√≥n de componentes, y teniendo en cuenta la responsabilidad de cada componente. LA idea es qu, en lugar de incluir los componente en el interior de otros componentes, se utilicen children para proyectar los componentes hijos dentro de los componentes padres.

##### üßøComposici√≥n: Logos, Header y App

Por ejemplo, al definir nuestro componente Header, en lugar de incluir el componente Logos dentro de Header, podr√≠amos dejar que Header utilice children para proyectar los logotipos. De este modo, Header se encargar√≠a solo de renderizar el t√≠tulo, y cualquier componente que utilice Header podr√≠a pasarle los logotipos como children.:

El componente Header quedar√≠a as√≠:

```tsx
export const Header: React.FC<React.PropsWithChildren<{}>> = ({ children }) => {
  return (
    <header>
      {children}
      <h1>Vite + TS + React</h1>
    </header>
  );
};
```

Y en App lo utilizar√≠amos de la siguiente manera:

```tsx
export const App: React.FC = () => {
  return (
    <div className="App">
      <Header>
        <Logos />
      </Header>
      <Counter />
      <Footer />
    </div>
  );
};
```

### Estilos en los componentes

En React, existen varias formas de aplicar estilos a los componentes. Algunas de las m√°s comunes son:

- **CSS tradicional**: se pueden utilizar archivos CSS externos y aplicar clases CSS a los elementos JSX utilizando el atributo `className`.
- **CSS en l√≠nea**: se pueden aplicar estilos directamente a los elementos JSX utilizando el atributo `style`, que acepta un objeto con las propiedades CSS en camelCase. Por ejemplo: `<div style={{ color: 'red', fontSize: '16px' }}>Hello</div>`.
- **CSS Modules**: permiten escribir CSS que est√© scoped (aislado) a un componente espec√≠fico, evitando colisiones de nombres. Esto se logra mediante la importaci√≥n de archivos CSS como m√≥dulos. Por ejemplo: `import styles from './Button.module.css';` y luego se puede aplicar la clase como `className={styles.button}`.
- **Styled-components**: es una librer√≠a que permite escribir estilos CSS dentro de los componentes utilizando una sintaxis similar a las plantillas literales de JavaScript.

#### CSS tradicional

El m√©todo m√°s sencillo y com√∫n para aplicar estilos en React es utilizar archivos CSS tradicionales. Para ello, se crean las reglas de estilo en dos sitios posibles:

- el archivo index.css de la carpeta src, que se importa en el archivo main.tsx o main.jsx, y cuyos estilos se aplican a toda la aplicaci√≥n.
- un archivo CSS por componente (generalmente con el mismo nombre que el componente) que se importa en el archivo del componente donde se van a utilizar.

Gracias a Vite, se pueden importar archivos CSS directamente en los archivos de los componentes, y los estilos se aplicar√°n a los elementos correspondientes.

Sin embargo esto no significa que los estilos tengan **scope**, es decir, que se apliquen solo a ese componente, sino que **TODOS** los estilos son globales y pueden afectar a otros componentes si utilizan las mismas clases o selectores. Para evitar colisiones de nombres, se pueden utilizar convenciones de nombres para las clases CSS, como BEM (Block Element Modifier) o CSS Modules.

Hay que tener en cuenta la potencia del css actual, que permite anidamiento y variables sin necesidad de utilizar pre-procesadores como SASS o LESS. Por tanteo se puede definir el scope de los estilos utilizando selectores espec√≠ficos para cada componente.

##### Estilos en l√≠nea

Junto con los archivos CSS, se pueden utilizar **estilos en l√≠nea** para aplicar estilos espec√≠ficos a un elemento. La particularidad en React es que los estilos se agrupan en un objeto y los nombres de estilos con guiones se deben escribir en camelCase. Por ejemplo:

```tsx
<div style={{ backgroundColor: 'blue', color: 'white' }}>Hello</div>
```

Los estilos en l√≠nea tienen mayor prioridad que los estilos definidos en archivos CSS, por lo que no se recomiendan de forma generalizado, ya que har√≠an m√°s dif√≠cil el mantenimiento de los estilos en la aplicaci√≥n.

Sin embargo, pueden ser √∫tiles para

- estilos din√°micos basados en el estado del componente o en las props.
- estilos espec√≠ficos que no se reutilizan en otros lugares.

##### Estilos en los componentes ya creados

En los componentes que ya hemos hecho, a partir de la App inicial de Vite, hemos creado archivos CSS espec√≠ficos para cada componente (App, Footer, Card, Logos) y los hemos importado en los archivos de los componentes correspondientes. En otros casos, como Header no hemos necesitado estilos espec√≠ficos, pero podr√≠amos crear archivos CSS para ellos si fuera necesario.

##### üßøComponente Menu

Veamos un nuevo componente que utilice un archivo CSS tradicional para incorporar un menu en la aplicaci√≥n.

```tsx
import './menu.css';

type MenuOption = {
  label: string;
  path: string;
};

export const Menu: React.FC = () => {
  const menuOptions: MenuOption[] = [
    { label: 'Home', path: '/' },
    { label: 'Counters', path: '/counters' },
    { label: 'Forms', path: '/forms' },
    { label: 'About', path: '/about' },
  ];

  return (
    <nav className="menu">
      <ul>
        <li>
          <a href={menuOptions[0].path} className="menu-link">
            {menuOptions[0].label}
          </a>
        </li>
        <li>
          <a href={menuOptions[1].path} className="menu-link">
            {menuOptions[1].label}
          </a>
        </li>
        <li>
          <a href={menuOptions[2].path} className="menu-link">
            {menuOptions[2].label}
          </a>
        </li>
        <li>
          <a href={menuOptions[3].path} className="menu-link">
            {menuOptions[3].label}
          </a>
        </li>
      </ul>
    </nav>
  );
};
```

Utilizamos un array de objetos para definir las opciones del men√∫, cada una con una etiqueta y una ruta. Luego, renderizamos una lista desordenada (`<ul>`) con elementos de lista (`<li>`) que contienen enlaces (`<a>`) para cada opci√≥n del men√∫. Cada enlace utiliza la clase CSS `menu-link` para aplicar estilos espec√≠ficos. M√°s adelante veremos c√≥mo renderizar listas de forma din√°mica utilizando el m√©todo `map`.

```css
nav.menu {
  ul {
    list-style: none;
    padding: 0;
    margin: 0;
    margin-bottom: 1rem;
    display: flex;
    flex-direction: row;
    gap: 0.5rem;
    background-color: #f8f9fa;
    border-bottom: 1px solid #ccc;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  a {
    display: block;
    text-decoration: none;
    color: #333;
    padding: 1rem 1.5rem;
    transition: background-color 0.3s ease;

    &:hover {
      background-color: #f0f0f0;
    }
  }
  .active {
    background-color: #007bff;
    color: white;
  }
  .disabled {
    color: #ccc;
    pointer-events: none;
  }
}
```

El anidamiento permite definir un scope para los estilos nativo a nivel de css sin necesidad de utilizar pre-procesadores como SASS o LESS. En algunos caos puede ser suficiente para evitar colisiones de nombres. Si no es as√≠, una alternativa es utilizar CSS Modules.

#### CSS Modules

CSS Modules es una t√©cnica que permite escribir CSS que est√© scoped (aislado) a un componente espec√≠fico, evitando colisiones de nombres. Esto se logra mediante la importaci√≥n de archivos CSS como m√≥dulos.

Aunque Vite ya lo trae configurado por defecto, es necesario seguir ciertas convenciones para utilizar CSS Modules en un proyecto con typeScript.

- se crea el fichero de definici√≥n de los typos para los m√≥dulos CSS, `src/custom.d.ts`, con el siguiente contenido:

  ```ts
  declare module '*.module.css' {
    const classes: { [key: string]: string };
    export default classes;
  }
  ```

En el tsconfig.app.json del proyecto, se incluyen los tipos definidos:

¬¥¬¥¬¥json
"include": ["src", "src/**/*.d.ts"]
¬¥¬¥¬¥

##### üßøComponente PanicButton (sin funcionalidad)

En la carpeta `features/home`, creamos un nuevo componente `PanicButton`, que utiliza CSS Modules para aplicar estilos espec√≠ficos al bot√≥n y al mensaje de advertencia.

Para utilizar CSS Modules en un proyecto de React con Vite, se deben seguir los siguientes pasos:

1. Crear un archivo CSS con la extensi√≥n `.module.css`. Por ejemplo, `panic-button.module.css`:

   ```css
   .button {
     background-color: rgba(137, 46, 139, 0.553);
     color: white;
     padding: 10px 20px;
     border: none;
     border-radius: 5px;
     cursor: pointer;
   }
   .button:hover {
     background-color: rgb(78, 23, 78);
   }
   .message {
     margin-top: 10px;
     font-size: 14px;
     color: rgb(138, 57, 57);
   }
   ```

2. Importar el archivo CSS como un m√≥dulo en el archivo del componente donde se van a utilizar los estilos. Por ejemplo, en `panic-button.tsx`:

   ```tsx
   import styles from './panic-button.module.css';

   export const PanicButton: React.FC<Props> = () => {
     return (
       <Card>
         <button className={styles.button}>
           Haz click solo en caso de emergencia
         </button>
         <p className={styles.message}>
           ¬°No lo hagas a menos que sea realmente necesario!
         </p>
       </Card>
     );
   };
   ```

3. Utilizar las clases CSS importadas en el JSX del componente utilizando la sintaxis `className={styles.className}`. En este caso, `styles.button` se refiere a la clase `.button` definida en el archivo `Button.module.css`.

4. Vite se encarga de procesar los archivos CSS Modules y generar clases √∫nicas para cada componente, evitando colisiones de nombres.

### Componentizaci√≥n y composici√≥n de componentes

Como √∫ltima etapa de la componentizaci√≥n que hemos aplicado al proyecto inicial de Vite, vamos a crear una aplicaci√≥n m√°s completa que incluya un layout con componentes anidados, utilizando props y children para pasar datos y contenido entre ellos.

#### üßøComponente Layout

Define la estructura b√°sica de la p√°gina, incluyendo sus contenidos: `Header`, con `Logos`, y `Menu`, `main` y `Footer`

```plaintext
App
‚îú‚îÄ‚îÄ Layout
‚îÇ    ‚îú‚îÄ‚îÄ Header
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ Menu
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ Logos
‚îÇ    ‚îú‚îÄ‚îÄ main
‚îÇ    ‚îî‚îÄ‚îÄ Footer
```

```tsx
import { Header } from '../header/header';
import { Footer } from '../footer/footer';
import { Menu } from '../menu/menu';
import { Logos } from '../logos/logos';

type Props = {
  readonly appTitle: string;
};

export const Layout: React.FC<React.PropsWithChildren<Props>> = ({
  children,
  appTitle,
}) => {
  return (
    <>
      <Header appTitle={appTitle}>
        <Menu />
        <Logos />
      </Header>
      <main>{children}</main>
      <Footer />
    </>
  );
};
```

#### Resultado final. Props drilling y children

Hemos creado una aplicaci√≥n que incluir√° los componentes `App`, `Layout`, `Header`, `Footer`, `Main`, y `Menu`. La estructura de la aplicaci√≥n ser√° la siguiente:

Cada componente tendr√° una funci√≥n espec√≠fica:

- `App`: ser√° el componente ra√≠z que renderizar√° el componente `Layout`.
- `Layout`: ser√° un componente que definir√° la estructura b√°sica de la p√°gina, incluyendo sus contenidos: el `Header`, `main` y `Footer`. Como contenido de `Header` se incluir√°n los componentes `Logos` y `Menu`.
- `Header`: ser√° un componente que mostrar√° el t√≠tulo de la p√°gina y los elementos que contenga, en este caso los componente `Logos` y `Menu`.
- `Logos`: ser√° un componente que mostrar√° los logotipos de Vite y React.
- `Menu`: ser√° un componente que mostrar√° una lista de enlaces de navegaci√≥n.
- `Footer`: ser√° un componente que mostrar√° informaci√≥n de pie de p√°gina.

Vamos a redefinir como se pasan las props entre los componentes para que cada uno tenga la informaci√≥n necesaria para renderizar su contenido.

- `App` no recibir√° props, pero pasar√° las props necesarias a los elementos contenidos en `Layout`.
- `Header` recibir√° desde App la prop `title` para mostrar el t√≠tulo de la p√°gina. Contendr√° un componente hijo, `Menu`.
- `Menu` recibir√° desde App la prop `menuItems`, que ser√° un array de objetos con las propiedades `label` y `url` para mostrar los enlaces de navegaci√≥n.
- `Logos` y `Footer` no recibir√°n props.

Las variables que definen la aplicaci√≥n se declaran en el componente `App` y se pasan a los componentes hijos a trav√©s de las props:

- `title`: el t√≠tulo de la p√°gina.
- `menuItems`: un array de objetos con las propiedades `label` y `url` para los enlaces del men√∫.

Aplicamos el css necesario para que la aplicaci√≥n tenga un aspecto b√°sico y agradable, utilizando los estilos importados desde los componentes, siendo conscientes de que todos los estilos son globales.

##### Props drilling

El paso de props desde el componente `App` hasta los componentes `Header` y `Menu` se conoce como **props drilling**. Este t√©rmino se refiere al proceso de pasar datos a trav√©s de m√∫ltiples niveles de componentes, lo que puede volverse complicado en aplicaciones grandes con muchos niveles de anidamiento.

App --> Layout --> Header
App --> Layout --> Menu

Al haber usado composition para definir la estructura de la aplicaci√≥n, `Header` no necesita recibir las props `menuItems`, ya que Layout puede pasarlas directamente a Menu que es quien las utiliza directamente.

En general. la composici√≥n y el uso de children ayudan a reducir la necesidad de props drilling, ya que los componentes pueden recibir contenido directamente a trav√©s de children en lugar de tener que pasar props a trav√©s de m√∫ltiples niveles de componentes.

Aun as√≠ veremos otras estrategias para evitar el props drilling en aplicaciones m√°s complejas, como el uso de Context API o librer√≠as de gesti√≥n de estado como Redux o Zustand.

##### üßøComponente App final

```tsx
import { Layout } from './core/components/layout/layout';
import { Counter } from './features/home/counter/counter';
export const App: React.FC = () => {
  const appTitle = 'Vite + TS + React';
  const menuItems = [
    { label: 'Home', url: '/' },
    { label: 'Counters', url: '/counters' },
    { label: 'Forms', url: '/forms' },
    { label: 'About', url: '/about' },
  ];

  return (
    <Layout appTitle={appTitle} menuItems={menuItems}>
      <Counter />
    </Layout>
  );
};
```

##### üßøComponente Layout final

```tsx
import { Header } from '../header/header';
import { Footer } from '../footer/footer';
import { Menu } from '../menu/menu';
import { Logos } from '../logos/logos';

type Props = {
  readonly appTitle: string;
  readonly menuItems: { label: string; url: string }[];
};
export const Layout: React.FC<React.PropsWithChildren<Props>> = ({
  children,
  appTitle,
  menuItems,
}) => {
  return (
    <>
      <Header title={appTitle}>
        <Menu items={menuItems} />
        <Logos />
      </Header>
      <main>{children}</main>
      <Footer />
    </>
  );
};
```

La separaci√≥n de responsabilidades y la composici√≥n de componentes facilitan

- el mantenimiento de la aplicaci√≥n, con un c√≥digo m√°s organizado
- la escalabilidad de la aplicaci√≥n.
- la reutilizaci√≥n de componentes en diferentes partes de la aplicaci√≥n o en otros proyectos.
- la testeabilidad de los componentes de forma aislada.

## Componentes din√°micos. Eventos

En React, es com√∫n necesitar renderizar contenido de manera condicional o iterativa dentro de un componente. Esto se puede lograr utilizando expresiones JavaScript dentro del JSX.

Por otra parte, los componentes pueden responder a eventos de usuario, como clics de rat√≥n, pulsaciones de teclas, env√≠os de formularios, etc., mediante el uso de manejadores de eventos.

### Condiciones en los componentes

Las props o cualquier otra variable del componente pueden utilizarse para renderizar contenido de manera condicional dentro de un componente, como forma declarativa de aumentar su funcionalidad. Esto es √∫til cuando se desea mostrar u ocultar elementos en funci√≥n de ciertas condiciones.

#### üßøComponente Greetings: Renderizado condicional

Una de las formas m√°s comunes de renderizado condicional en React es utilizando el **operador ternario** dentro del JSX para crear una expresi√≥n condicional. Como ejemplo, creamos en la carpeta `features/home` un componente `Greetings`, que recibe una prop `username`. Si se proporciona un nombre de usuario, muestra un mensaje de bienvenida personalizado; de lo contrario, muestra un mensaje gen√©rico.

```tsx
import { Card } from '@core/components/card/card';

type Props = {
  readonly username?: string;
};

export const Greetings: React.FC<Props> = ({ username }) => {
  return (
    <Card>
      {username ? (
        <p>Welcome back, {username}!</p>
      ) : (
        <p>Welcome to our website!</p>
      )}
    </Card>
  );
};
```

Una alternativa para renderizar condicionalmente un elemento es utilizar el **operador l√≥gico** `&&` para mostrar un elemento solo si una condici√≥n es verdadera. En el caso de que la condici√≥n sea falsa, React ignora el valor boolean, por lo que no se renderiza nada. Por ejemplo:

```tsx
export const Greetings: React.FC<Props> = ({ username }) => {
  return (
    <div>
      {username && <p>Welcome back, {username}!</p>}
      {!username && <p>Welcome to our website!</p>}
    </div>
  );
};
```

Por lo que respecta a la **sentencia de control** `if`, no se puede utilizar directamente dentro de JSX, ya que no es una expresi√≥n, pero se puede utilizar antes de la declaraci√≥n del return para definir variables que luego se utilicen en el JSX. Por ejemplo:

```tsx
export const Greetings: React.FC<Props> = ({ username }) => {
  let greetingMessage;

  if (username) {
    greetingMessage = <p>Welcome back, {username}!</p>;
  } else {
    greetingMessage = <p>Welcome to our website!</p>;
  }

  return <div>{greetingMessage}</div>;
};
```

### Iteraciones: renderizado de listas

Otra funcionalidad com√∫n en los componentes es el renderizado iterativo de listas de elementos a partir de un array de datos. Para ello se puede utilizar el m√©todo `map()` de los arrays para transformar cada elemento del array en un elemento JSX.

#### üßøComponente Menu refactorizado

Podemos verlo refactorizando el componente `Menu`, que recibe un array de opciones de men√∫ como prop, para que itere sobre ellas y renderice din√°micamente los elementos del men√∫:

```tsx
import type { MenuOption } from '../app/App';
import './menu.css';

type Props = {
  options: MenuOption[];
};

export const Menu: React.FC<Props> = ({ options }) => {
  return (
    <nav className="menu">
      <ul>
        {options.map((option) => (
          <li key={option.path}>
            <a href={option.path} className="menu-link">
              {option.label}
            </a>
          </li>
        ))}
      </ul>
    </nav>
  );
};
```

En el primer elemento de la iteraci√≥n, en este caso el `<li>`, se utiliza el atributo `key` para proporcionar una clave √∫nica para cada elemento de la lista. Esto ayuda a React a identificar qu√© elementos han cambiado, se han a√±adido o eliminado, mejorando el rendimiento del renderizado.

### Manejo de Eventos

Los eventos son las acciones que ocurren en la interfaz de usuario, como clics de rat√≥n, pulsaciones de teclas, env√≠os de formularios, etc. Los principales eventos son

- **Click** - El usuario hace clic en un bot√≥n
- **Input** - El usuario escribe en un input
- **Change** - El valor de un input cambia
- **Submit** - Se env√≠a un formulario
- **Hover** - El rat√≥n pasa sobre un elemento

De forma nativa, HTML desencadena los eventos y en JS se pueden registrar las funciones que responden a esos eventos, es decir que los "escuchan", por lo que se denominan event listeners o event handlers, para nosotros **manejadores de eventos**).

En React, **manejadores de eventos** se registran de forma declarativa en el JSX utilizando atributos que corresponden a los eventos, como `onClick`, `onChange`, etc. y asign√°ndoles las funciones que se ejecutan cuando ocurre el evento espec√≠fico en el elemento del DOM indicado.

- Los eventos en React se nombran utilizando camelCase, comenzando por on
- se registran como valores funciones manejadores como callbacks que se invocaran en respuesta al event. Es importante **no invocar la funci√≥n** al asignarla, por lo que no se deben incluir par√©ntesis.

Esa funci√≥n manejadora podr√° ser

- una funci√≥n an√≥nima incluida en la expresi√≥n JSX

  ```tsx
  onClick={() => {console.log("Button clicked!"); }}.
  ```

  Esto √∫ltimo no es recomendable en la mayor√≠a de los casos, ya que puede afectar al rendimiento y a la legibilidad del c√≥digo. Puede hacerse si la funci√≥n es muy simple, una sola l√≠nea, y no va a reutilizarse

- una funci√≥n definida en el componente

```tsx
onClick={handleClick}`
```

Suele nombrarse estas funciones con el prefijo "handle" seguido del nombre del evento, como `handleClick`, `handleChange`, etc.

En react no suele recomendarse que el nombre empiece por "on", ya que puede llevar a confusi√≥n con los nombres de los atributos JSX que registran los manejadores de eventos.

#### üßøComponente PanicButton con funcionalidad

Recuperando el componente que mostraba un bot√≥n de p√°nico, le a√±adimos funcionalidad para manejar el evento de clic en el bot√≥n. Definimos una funci√≥n manejadora `handleClick` dentro del componente y la pasamos como callback en el JSX.

```tsx
export const PanicButton: React.FC = () => {
  const handleClick = (): void => {
    alert('No pudiste evitarlo !!');
  };

  return (
    <Card>
      {/* // Mala pr√°ctica: funci√≥n an√≥nima en el JSX
            <button className={styles.button}
            onClick={() => {console.log("Button clicked!"); }}>{
        */}
      <button className={styles.button} onClick={handleClick}>
        Pulsar en caso de emergencia
      </button>
      <p className={styles.message}>
        ¬°No lo hagas a menos que sea realmente necesario!
      </p>
    </Card>
  );
};
```

La funci√≥n `handleClick` se define dentro del componente `PanicButton`, por lo que puede acceder a sus props y su estado y a otras funciones si es necesario. El componente act√∫a como una **closure** para la funci√≥n que se pasa como manejador de eventos: la funci√≥n handleClick ‚Äúrecuerda‚Äù las variables del √°mbito donde fue creada.

#### Props funcionales

Las props pueden ser cualquier tipo de dato de JavaScript, incluyendo funciones. Esto permite pasar funciones como props a los componentes, lo que es √∫til para manejar eventos o realizar acciones espec√≠ficas dentro del componente. Con frecuencia esas funciones se utilizan para manejar eventos en el componente que las recibe.

#### üßøComponente Button gen√©rico y su uso en PanicButton

Partiendo de nuestro PanicButton, podr√≠amos querer, un componente bot√≥n m√°s gen√©rico, que pudiera recibir como props el texto que muestra y el comportamiento que se debe desencadenar cuando hacemos click:

```tsx
type Props = {
  label: string;
  className?: string;
  onClick: () => void;
  [key: string]: unknown;
};

export const Button: React.FC<Props> = ({ label, className, onClick, ...restOfProps }) => {
  const baseClassName = '.button';

  return (
    <button className={className || baseClassName} onClick={onClick} {...restOfProps}>
      {label}
    </button>
  );
};
```

Este tipo de componentes permite redefinir los elementos nativos de HTML con funcionalidades adicionales y estilos personalizados, manteniendo la flexibilidad de definir su comportamiento a trav√©s de las props. Con ello se construye lo que se conoce como un **design system**, que suele implementarse como una **librer√≠a de componentes** aparte de la aplicaci√≥n.

Gracias a la desestructuraci√≥n de objetos en los par√°metros de la funci√≥n, podemos extraer las props `label`, `className` y `onClick`, y utilizar el operador rest (`...restOfProps`) para capturar cualquier otra prop adicional que se le pase al componente. Estas props adicionales se pasan al elemento `<button>` utilizando el operador spread (`{...restOfProps}`), lo que permite que el componente Button sea flexible y pueda aceptar cualquier otra prop v√°lida para un bot√≥n HTML.

El tipado de las props para permitir cualquier otra prop adicional se logra utilizando un √≠ndice de firma en la interfaz de las props: `[key: string]: unknown;`. Esto indica que el objeto de props puede tener cualquier n√∫mero de propiedades adicionales con claves de tipo string y valores de cualquier tipo (unknown).

Desde nuestro PanicButton podemos utilizar el componente `Button` y pasarle una funci√≥n como prop, de la siguiente manera:

```tsx
import { Button } from '@core/components/button/button';
import { Card } from '@core/components/card/card';
import styles from './panic-button.module.css';

export const PanicButton: React.FC = () => {
  const handleClick = (): void => {
    alert('No pudiste evitarlo !!');
  };

  return (
    <Card>
      <Button
        label="Pulsar en caso de emergencia"
        className={styles.button}
        onClick={handleClick}
      />
      <p className={styles.message}>
        ¬°No lo hagas a menos que sea realmente necesario!
      </p>
    </Card>
  );
};
```

Como la funci√≥n `handleClick` se define dentro del componente `PanicButton`, puede acceder a su estado y otras funciones si es necesario. El componente padre act√∫a como una closure para la funci√≥n que se pasa como prop al componente hijo.

Lo importante no es el ejemplo, sino la idea de funciones como props, que es un patr√≥n muy utilizado en React para pasar comportamientos personalizados a los componentes, de forma que el componente padre pueda utilizar la informaci√≥n generada en los componentes hijos

#### El objeto evento como par√°metro en los manejadores de eventos

Los manejadores de eventos en JS recibe siempre un objeto Evento, que contiene informaci√≥n aportada por es sistema y diversos m√©todos relacionados con los eventos y su flujo.

Entre ellos:

```js
const handleClick = (event) => {
  event.preventDefault(); // Prevenir comportamiento por defecto
  event.stopPropagation(); // Detener propagaci√≥n del evento
  event.target; // Elemento que dispar√≥ el evento
  event.currentTarget; // Elemento al que est√° adjunto el evento
  event.type; // Tipo de evento ('click', 'change', etc.)
};
```

Entre otras cosas, esta informaci√≥n permite

- crear manejadores que respondan a eventos diversos o procedentes de distintos elementos del DOM
- prevenir el comportamiento por defecto de los eventos, por ejemplo, evitar que un enlace navegue a otra p√°gina
- controlar la propagaci√≥n de los eventos en el DOM
- acceder a informaci√≥n adicional sobre el evento, como las coordenadas del rat√≥n, las teclas pulsadas, etc.
- accede a informaci√≥n incluida en los elementos DOM, como el contenido de un formulario o datos almacenados en atributos personalizados, `data-`

#### Objetos de Eventos en React: SyntheticEvent

Sin embargo, en React, el objeto de evento que se pasa a los manejadores de eventos es un **evento sint√©tico** (SyntheticEvent), que es una envoltura alrededor del evento nativo del navegador. Esto proporciona una interfaz consistente para manejar eventos en todos los navegadores y mejora el rendimiento al reutilizar objetos de eventos.

Estos objetos incluyen la propiedad `nativeEvent`, que contiene el evento nativo del navegador, en caso de que se necesite acceder a propiedades o m√©todos espec√≠ficos del evento nativo.

Por ejemplo, para manejar un evento de clic en un bot√≥n y acceder al objeto de evento, se puede hacer de la siguiente manera:

```tsx
interface Props {
  label: string;
  className?: string;
  onClick: (event: React.SyntheticEvent<HTMLButtonElement>) => void;
}
export const Button: React.FC<Props> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>;
};
```

El interface SyntheticEvent es el tipo base para todos los eventos sint√©ticos en React y soporta gen√©ricos que permiten definir que elemento HTML ha sido responsable de generar el evento. En este caso, se indica que el evento ha sido generado por un elemento `<button>`, utilizando `HTMLButtonElement`.

Los objetos de eventos sint√©ticos en React tienen las mismas propiedades y m√©todos que los eventos nativos del navegador, pero con algunas diferencias. Entre eos m√©todos y propiedades se incluyen:

- `currentTarget`: Hace referencia al elemento que est√° escuchando el evento, en este caso, el bot√≥n. Su tipo corresponde al tipo indicado en el gen√©rico del tipo del evento, por lo que en este caso es de tipo `HTMLButtonElement`. Por esa raz√≥n es preferible utilizar `currentTarget` en lugar de `target` cuando se trabaja con eventos en React y no hay problemas de delegaci√≥n de eventos.
- `target`: Hace referencia al elemento que dispar√≥ el evento, que puede ser un elemento hijo del bot√≥n. Siempre es de tipo `EventTarget`, por lo que puede ser necesario hacer un casting para acceder a sus propiedades espec√≠ficas.
- `type`: El tipo de evento que se ha producido, como "click", "change
- `preventDefault()`: M√©todo que se utiliza para prevenir el comportamiento por defecto del evento.
- `stopPropagation()`: M√©todo que se utiliza para detener la propagaci√≥n del evento a otros elementos.

##### [Avanzado] Usos avanzados del tipado de eventos en React

Para eventos espec√≠ficos, como eventos de rat√≥n, teclado, formulario, etc., existen tipos m√°s espec√≠ficos que extienden de SyntheticEvent. Por ejemplo, para un evento de clic en un bot√≥n, se puede utilizar el tipo `React.MouseEvent<HTMLButtonElement>`, que proporciona propiedades espec√≠ficas para eventos de rat√≥n. Por ejemplo:

```tsx
interface Props {
  label: string;
  className?: string;
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;
}
export const Button: React.FC<Props> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>;
};
```

En algunos casos, estos interfaces permiten a TypeScript inferir el tipo correcto del target. No es asi en los casos de `React.MouseEvent` y `React.PointerEvent`, pero si en otros como `React.ChangeEvent` o `React.KeyboardEvent`. Por ejemplo, en un evento de cambio en un campo de formulario, se puede utilizar el tipo `React.ChangeEvent<HTMLInputElement>`, que permite acceder directamente a las propiedades espec√≠ficas del elemento de formulario, como `value` o `checked`. Por ejemplo:

```tsx
interface Props {
  value: string;
  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
}
export const Input: React.FC<Props> = ({ value, onChange }) => {
  return <input type="text" value={value} onChange={onChange} />;
};
```

El componente que utiliza el componente `Input` puede manejar el evento de cambio y acceder al valor del campo de formulario directamente desde el objeto de evento:

```tsx
export const Form: React.FC = () => {
  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const value = event.target.value; // event.target es de tipo HTMLInputElement
    console.log('Input value:', value);
  };

  return <Input value={inputValue} onChange={handleInputChange} />;
};
```

Cuando se accede a `event.target`, y TypeScript no puede inferir correctamente de que tipo es, puede utilizarse la aserci√≥n o casting de tipo para indic√°rselo a TypeScript. Por ejemplo:

```tsx
const handleInputChange = (event: React.SyntheticEvent<HTMLInputElement>) => {
  const value = (event.target as HTMLInputElement).value;
  console.log('Input value:', value);
};
```

##### Par√°metros adicionales

A veces es necesario pasar par√°metros adicionales a las funciones manejadoras de eventos. Para ello, se puede utilizar una funci√≥n an√≥nima o una funci√≥n flecha para envolver la llamada a la funci√≥n manejadora, pasando los par√°metros necesarios. Por ejemplo:

```tsx
interface Props {
  label: string;
  onClick: (event: React.MouseEvent<HTMLButtonElement>, id: number) => void;
  id: number;
}
export const Button: React.FC<ButtonProps> = ({ label, onClick, id }) => {
  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    onClick(event, id);
  };

  return <button onClick={handleClick}>{label}</button>;
};
```

## Hooks

Con la aparici√≥n de los componentes basados en funciones React incorpora tambi√©n los **hooks**: funciones especiales que permiten "engancharse" a las caracter√≠sticas de React desde componentes funcionales y as√≠ utilizar el estado y otras caracter√≠sticas de React sin escribir una clase.

- **hooks nativos** ('built-in') de React: como `useState`, `useEffect`, `useContext`, `useReducer`, etc.
- **hooks personalizados**: funciones que utilizan los hooks nativos para crear funcionalidades reutilizables y espec√≠ficas para una aplicaci√≥n o un conjunto de componentes.

Los Hooks m√°s comunes son `useState` y `useEffect`, responsables respectivamente de gestionar el estado y los efectos secundarios en los componentes funcionales.

### Reglas de los hooks

Los hooks deben seguir ciertas reglas para garantizar su correcto funcionamiento:

1. **Solo se pueden llamar en el nivel superior**: No se deben llamar hooks dentro de bucles, condiciones o funciones anidadas. Deben ser llamados siempre en el nivel superior del componente funcional para asegurar que se llamen en el mismo orden en cada renderizado.
2. **Solo se pueden llamar desde componentes funcionales o hooks personalizados**: No se deben llamar hooks desde funciones regulares de JavaScript. Solo se pueden utilizar dentro de componentes funcionales de React o en otros hooks personalizados.
3. **Nombres de hooks**: Los nombres de los hooks deben comenzar con "use" para que React pueda identificar que se trata de un hook.
4. **Dependencias**: Algunos hooks, como `useEffect`, aceptan un array de dependencias como segundo argumento. Es importante asegurarse de que todas las dependencias necesarias est√©n incluidas en este array para evitar comportamientos inesperados.

### Hooks y Estado: useState

En sus primera versi√≥n, React solo permit√≠a utilizar estado y otras caracter√≠sticas en **componentes de clase**. Con la introducci√≥n de los Hooks en React 16.8 (2019), ahora es posible utilizar estas caracter√≠sticas en componentes funcionales, lo que ha simplificado el desarrollo de aplicaciones React y ha hecho que el c√≥digo sea m√°s f√°cil de entender y mantener. Los componentes basados en clases pr√°cticamente no se utilizan en la actualidad, aunque siguen siendo compatibles.

El estado es como la memoria de un componente, que le permite recordar informaci√≥n entre renderizados y responder a las interacciones del usuario u otros eventos. Cuando el estado de un componente cambia, React vuelve a renderizar el componente para reflejar los cambios en la interfaz de usuario.

#### Componentes sin estado

Si un componente no necesita mantener estado ni utilizar otros hooks, se le denomina **componente sin estado** o **stateless component**. Estos componentes son funciones puras que reciben props y devuelven JSX.

Este es el comportamiento de cualquiera de los componentes creados hasta ahora, como el siguiente ejemplo:

```tsx
interface Props {
  message: string;
}
export const StatelessComponent: React.FC<Props> = ({ message }) => {
  return <div>{message}</div>;
};
```

En un componente de este tipo no es posible que se hagan modificaciones en los valores de una variable que afecten al renderizado del componente, ya que no se dispone de un mecanismo para ello.

##### üßøComponente CounterNoState

As√≠ sucede en el componente contador si eliminamos el estado. Para comprobarlo, movemos el componente `Counter` a la carpeta `counters/click-counters` y lo modificamos para eliminar el uso de `useState`, utilizando una variable local para almacenar el valor del contador:

```tsx
import { Card } from '@core/components/card/card';

export const Counter: React.FC = () => {
  let count = 0;

  const handleClick = (): void => {
    count++;
    console.log('Component NoState', count);
  };
  return (
    <Card>
      <button onClick={handleClick}>count is {count}</button>
      <p>
        Open <code>console</code> and view the count value when clicking the
        button.
      </p>
    </Card>
  );
};
```

Aunque la variable `count` se incrementa cada vez que se hace clic en el bot√≥n, y as√≠ se muestra en la consola, el valor mostrado en el bot√≥n no cambia, ya que React no sabe que debe volver a renderizar el componente. Para que el componente pueda mantener y actualizar su estado, es necesario utilizar el hook `useState`.

#### Componentes con estado: useState

El hook `useState` permite a los componentes funcionales mantener y actualizar su **estado**.

Como todos los hooks, `useState` es una funci√≥n. En este caso

- recibe como argumento el valor inicial del estado
- devuelve un array con dos elementos (una tuple en TypeScript)
  - el valor actual del estado
  - una funci√≥n para actualizar ese valor

Al desestructurar el array, se pueden asignar nombres m√°s significativos a estos elementos, el primero definiendo el estado y el segundo la funci√≥n para actualizarlo (set...).

CVemos un ejemplo en el mismo Counter, pero esta vez recuperamos el estado para que funcione correctamente.

##### üßøComponente Counter: estado

En la carpeta `features/counters/click-counters`, creamos un componente `Counter` que utiliza el hook `useState` para mantener y actualizar el valor del contador cada vez que se hace clic en el bot√≥n:

```tsx
import React, { useState } from 'react';

import { useState } from 'react';
import { Card } from '@core/components/card/card';

export const Counter: React.FC = () => {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    // setCount(count + 1);
    setCount((prevCount) => prevCount + 1);
    console.log('Component State', count);
  };
  return (
    <Card>
      {/* <button onClick={() => setCount((count) => count + 1)}> */}
      <button onClick={handleClick}>count is {count}</button>
      <p>
        Edit <code>src/**/counter.tsx</code> and save to test HMR
      </p>
    </Card>
  );
};
```

El hook `useState` recibe como argumento el valor inicial del estado, que en este caso es `0`. La funci√≥n `setCount` se utiliza para actualizar el valor de `count`.

##### La funci√≥n de estado

La funci√≥n de estado puede recibir como **argumento un valor** directamente, como en `setCount(count + 1)`, o c

Como se ve en el ejemplo anterior, tambi√©n puede recibir como **argumento una funci√≥n** (callback) que devuelve un valor. Esto es √∫til cuando el nuevo valor del estado depende del valor anterior. La funci√≥n devuelve un valor que se utiliza como nuevo estado, nunca modifica el estado anterior.

En cualquier caso, la funci√≥n de estado nunca debe modificar directamente el valor del estado, sino **devolver un nuevo valor**. Por ejemplo, `setCount(count++)` ser√≠a incorrecto, ya intentar√≠a modifica el valor de `count` directamente. En este caso no es posible y dar√≠a un error, por ser una `const` con un valor primitivo, pero con arrays y objetos puede llevar a comportamientos inesperados.

##### Estado local y componentes

Cada componente tiene su propio estado independiente. Cuando se utiliza `useState` dentro de un componente, el estado es local a ese componente y no afecta a otros componentes. Si se renderizan m√∫ltiples instancias del mismo componente, cada una tendr√° su propio estado independiente.

Por ejemplo, si se renderizan dos instancias del componente `Counter`, cada una tendr√° su propio contador independiente:

```tsx
import { Counter } from './counter';
export const App: React.FC = () => {
  return (
    <div>
      <Counter />
      <Counter />
    </div>
  );
};
```

##### Caracter√≠sticas del estado en React

- No manipulamos el DOM manualmente
- El estado y la UI est√°n sincronizados autom√°ticamente
- Cada componente tiene su propio estado independiente
- F√°cil de testear
- Declarativo: describes qu√© quieres, no c√≥mo hacerlo

##### Tipado de estados en TypeScript

Los estados pueden ser de cualquier tipo de dato, incluyendo objetos y arrays. Cuando son primitivos, infieren su tipo a partir del valor inicial. Cuando son valores complejos, es necesario proporcionar un tipo expl√≠cito (anotado) como gen√©rico del hook `useState`. Por ejemplo un array vaci√≥ inferir√≠a el tipo `never[]`, por lo que es necesario indicar el tipo de dato que contendr√°:

```tsx
import React, { useState } from 'react';

export const ArrayComponent: React.FC = () => {
  const [items, setItems] = useState<string[]>([]);

  const addItem = (item: string) => {
    setItems([...items, item]);
  };

  return (
    <div>
      <h2>Array Component</h2>
      <button onClick={() => addItem('New Item')}>Add Item</button>
      <ul>
        {items.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
};
```

El tipo gen√©rico puede ser una uni√≥n de tipos, de forma que el estado pueda variar entre varios tipos de datos, como puede ser un objeto frente a un valor null o undefined. Por ejemplo:

```tsx
import React, { useState } from 'react';

const UnionTypeComponent: React.FC = () => {
  const [value, setValue] = useState<User | null>(null);

  const handleClick = () => {
    setValue({ id: 1, name: 'John Doe' });
  };

  return (
    <div>
      <h2>Union Type Component</h2>
      <button onClick={handleClick}>Set Value</button>
      <p>Current Value: {value}</p>
    </div>
  );
};
```

En caso de que fuera imposible conocer a priory el tipo de los elementos del array, el tipo de `useState` podr√≠a ser `unknown[]`, pero esto no es recomendable, ya que

- permite asignar al estado cualquier tipo de valor, lo que puede llevar a errores en tiempo de ejecuci√≥n,
- no permite utilizar loas valores del array sin un casting (aserci√≥n) de tipo previo.

```tsx sample9.1.state.tsx
const [items, setItems] = useState<unknown[]>([]);
useEffect(() => {
  // Simulate a state change
  setState(['Pepe', 'Luis', 'Juana']);
}, []);

return (
  <div>
    <h1>Sample 9.1</h1>
    <p>State management with useState</p>
    <p>{state.length}</p>
    <ul>
      {state.map((item, index) => (
        <li key={index}>{item as string}</li>
      ))}
    </ul>
  </div>
);
```

#### Estados y renderizaci√≥n

Los estados se definen como una constantes dentro de la funci√≥n del componente.

```tsx
const [count, setCount] = useState(0);
```

Sin embargo, aunque se definen como constantes, su valor puede cambiar a lo largo del ciclo de vida del componente.

- Cada vez que se llama a `setCount`, React **vuelve a renderizar** el componente con el nuevo valor de la constante `count`. Renderizar es el proceso de ejecutar el componente (una funci√≥n) para generar el JSX que se mostrar√° en pantalla. Para ver este proceso, podemos a√±adir un `console.log` en el cuerpo del componente:

```tsx
const Counter: React.FC = () => {
  const [count, setCount] = useState(0);
  console.log('Renderizando Counter, count:', count);

  return {
    /* JSX del componente */
  };
};
```

- La constante con el valor del estado (`count`) solo puede cambiar cuando el componente se renderiza y se vuelve a ejecutar la funci√≥n del componente: en cada renderizado, se crea una **nueva instancia** de esa constante.
- En cada instancia, si no es la primera, el valor actual del estado se obtiene desde la **closure** de la funci√≥n, donde qued√≥ almacenado el valor actualizado en la llamada anterior a `setCount`.

El ciclo de vida del estado en un componente es el siguiente:

1. El componente se renderiza por primera vez, y `useState` inicializa el estado con el valor proporcionado.
2. Cuando se llama a la funci√≥n de actualizaci√≥n del estado (por ejemplo, `setCount`),
   1. Se almacena el nuevo valor del estado en la closure de la funci√≥n.
   2. React programa una nueva renderizaci√≥n del componente.
3. En la siguiente renderizaci√≥n, `useState` devuelve el valor actualizado del estado, obteni√©ndolo desde la closure.
4. Este proceso se repite cada vez que se actualiza el estado.

```plainText
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. Renderizado inicial                    ‚îÇ
‚îÇ     ‚Ä¢ React ejecuta el componente          ‚îÇ
‚îÇ     ‚Ä¢ useState devuelve valor inicial      ‚îÇ
‚îÇ     ‚Ä¢ Se genera JSX                        ‚îÇ
‚îÇ     ‚Ä¢ Se muestra en el DOM                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  2. Usuario interact√∫a                     ‚îÇ
‚îÇ     ‚Ä¢ Hace click en el bot√≥n               ‚îÇ
‚îÇ     ‚Ä¢ Se ejecuta handleClick               ‚îÇ
‚îÇ     ‚Ä¢ Se llama setCount(count + 1)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  3. Re-renderizado                         ‚îÇ
‚îÇ     ‚Ä¢ React ejecuta el componente otra vez ‚îÇ
‚îÇ     ‚Ä¢ useState devuelve el nuevo valor     ‚îÇ
‚îÇ     ‚Ä¢ Se genera nuevo JSX                  ‚îÇ
‚îÇ     ‚Ä¢ React compara con el anterior        ‚îÇ
‚îÇ     ‚Ä¢ Actualiza solo lo que cambi√≥         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

##### Renderizaci√≥n y virtual DOM

Para minimizar el impacto de estos multiples renderizados en el rendimiento de la aplicaci√≥n, React utiliza un sistema llamado **Virtual DOM**.

El Virtual DOM es una representaci√≥n ligera del DOM real que permite a React realizar actualizaciones eficientes.

- Es una copia ligera del DOM real en JavaScript
- Es solo un objeto en memoria (muy r√°pido)
- React lo usa para comparar antes y despu√©s

Cuando el estado de un componente cambia y se produce un nuevo renderizado, React crea una nueva versi√≥n del Virtual DOM y la compara con la versi√≥n anterior utilizando un algoritmo de **diferenciaci√≥n** (diffing). Solo las partes del DOM que han cambiado se actualizan en el DOM real (reconciliation), lo que mejora significativamente el rendimiento de la aplicaci√≥n.

```plaintext
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. Estado actual                            ‚îÇ
‚îÇ     Virtual DOM antiguo:                     ‚îÇ
‚îÇ     <button>Count 0</button>                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  2. Cambio de estado                         ‚îÇ
‚îÇ     setCount(count + 1)                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  3. Nuevo Virtual DOM                        ‚îÇ
‚îÇ     React re-ejecuta el componente           ‚îÇ
‚îÇ     Genera nuevo Virtual DOM:                ‚îÇ
‚îÇ     <button>Count 1</button>                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  4. Comparaci√≥n (Diffing)                    ‚îÇ
‚îÇ     React compara los dos Virtual DOMs       ‚îÇ
‚îÇ     Encuentra las diferencias:               ‚îÇ
‚îÇ     ‚Ä¢ Texto cambi√≥: "Count 0" ‚Üí "Count 1"    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  5. Actualizaci√≥n m√≠nima (Reconciliation)    ‚îÇ
‚îÇ     React actualiza SOLO lo que cambi√≥:      ‚îÇ
‚îÇ     ‚Ä¢ element.textContent = 'Count 1'        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Entre las ventajas del uso del Virtual DOM se incluyen:

- Mejor **rendimiento**: Al minimizar las actualizaciones del DOM real, que son costosas en t√©rminos de rendimiento.
  - **Batch Updates** (Agrupaci√≥n de actualizaciones): React agrupa m√∫ltiples cambios de estado en una sola actualizaci√≥n del DOM, lo que mejora a√∫n m√°s el rendimiento al reducir la cantidad de renderizados necesarios.
- **Eficiencia**: Solo se actualizan las partes del DOM que han cambiado, lo que reduce la cantidad de trabajo que el navegador debe realizar.
  - Previene actualizaciones innecesarias: si se intenta poner el mismo valor, `setCount(count)`, React no volver√° a renderizar el componente.
- **Consistencia**: El Virtual DOM proporciona una representaci√≥n consistente del estado de la interfaz de usuario, lo que facilita la gesti√≥n de cambios y actualizaciones.

##### Props y renderizado

Cuando un componente recibe nuevas props, React tambi√©n vuelve a renderizar el componente para reflejar los cambios en la interfaz de usuario. El proceso es similar al de la actualizaci√≥n del estado:

1. El componente recibe nuevas props.
2. React vuelve a renderizar el componente con las nuevas props.
3. Se genera un nuevo Virtual DOM.
4. React compara el nuevo Virtual DOM con el anterior.
5. Solo las partes del DOM que han cambiado se actualizan en el DOM real.
6. El estado del componente permanece intacto a menos que se actualice expl√≠citamente.
7. El componente puede utilizar las nuevas props para actualizar su estado si es necesario.

Se podr√≠a decir que las props son parte del estado externo del componente.

Las props son inmutables desde el punto de vista del componente que las recibe, ya que no puede modificarlas directamente. Sin embargo, un componente puede utilizar las props para actualizar su estado interno si es necesario.

En typescript, al crear el tipo de las props, es buena pr√°ctica marcar las props como `readonly`, para indicar que no deben modificarse dentro del componente:

```tsx
interface Props {
  readonly label: string;
  readonly initialCount?: number;
}
```

Hay una regla del plugin de React para el Eslint llamada `react/prefer-read-only-props` que sugiere marcar las props como `readonly` para mejorar la seguridad del tipo y evitar modificaciones accidentales. Tambi√©n existe la regla `react/no-unused-prop-types` que avisa si alguna prop no se utiliza en el componente, lo que ayuda a mantener el c√≥digo limpio y evitar props innecesarias.

#### Multiples estados

Un componente puede tener m√∫ltiples estados utilizando varias llamadas a `useState`. Cada llamada a `useState` crea un estado independiente. Son frecuentes estados con valor booleano para manejar visibilidad de elementos, estados de carga, etc.

##### üßøComponente CounterLogin con m√∫ltiples estados

A partir del componente Counter, a√±adimos un segundo estado para manejar si el usuario est√° logueado o no. El contador solo esta disponible para ser incrementado si el usuario est√° logueado.

```tsx
import { useState } from 'react';
import { Card } from '@core/components/card/card';

export const CounterLogin: React.FC = () => {
  const [count, setCount] = useState(0);
  const [loggedIn, setLoggedIn] = useState(false);

  const handleLogin = (): void => {
    setLoggedIn((prev) => !prev);
  };

  const handleClick = (): void => {
    // setCount(count + 1);
    setCount((prevCount) => prevCount + 1);
  };
  return (
    <Card>
      <button onClick={handleClick} disabled={!loggedIn}>
        count is {count}
      </button>
      <button onClick={handleLogin}>{loggedIn ? 'Logout' : 'Login'}</button>
      <p>Login for use the counter</p>
    </Card>
  );
};
```

El estado `loggedIn` se utiliza para habilitar o deshabilitar el bot√≥n del contador y para cambiar el texto del bot√≥n de login/logout. En este caso vemos el uso de una expresi√≥n condicional ternaria para mostrar diferentes textos en el bot√≥n seg√∫n el estado de login.

#### Estados compartidos entre componentes

En React, los estados son locales a cada componente. Sin embargo, a veces es necesario compartir el estado entre varios componentes. Para ello, se pueden utilizar varias t√©cnicas, como:

- **Lifting State Up**: consiste en mover el estado a un componente padre com√∫n y pasar el estado y las funciones para actualizarlo como props a los componentes hijos que lo necesiten.
- **Context API**: permite crear un contexto global que puede ser accedido por cualquier componente en la jerarqu√≠a de componentes, evitando la necesidad de pasar props a trav√©s de m√∫ltiples niveles.
- **State Management Libraries**: como Redux, MobX, Recoil, etc., que proporcionan una forma m√°s estructurada y escalable de manejar el estado global en aplicaciones grandes.

De momento solo vamos a ver el primer m√©todo, lifting state up. Por ejemplo, si tenemos dos componentes que necesitan compartir un estado, podemos mover el estado a un componente padre com√∫n y pasar el estado y las funciones para actualizarlo como props a los componentes hijos. Por ejemplo:

```tsx
interface CounterProps {
  count: number;
  onIncrement: () => void;
}

export const Counter: React.FC<CounterProps> = ({ count, onIncrement }) => {
  return (
    <div>
      <h2>Counter</h2>
      <button onClick={onIncrement}>Count is {count}</button>
    </div>
  );
};
```

##### üßøComponente CounterContainer. Practica: Hooks, Estado y Eventos

Creamos un contenedor de contadores, `CounterContainer`, que contendr√° varios componentes `Counter`, cada uno con su propio estado independiente. El contenedor mostrar√° el n√∫mero total de clicks en los contadores y el valor total de todos los contadores.

Adem√°s, el contenedor tendr√° un bot√≥n para a√±adir nuevos contadores y otro para resetear todos los contadores a cero.

```tsx
import React, { useState } from 'react';
import { Counter } from './Counter';
export const App: React.FC = () => {
  const [count, setCount] = useState(0);

  const handleIncrement = () => {
    setCount((prevCount) => prevCount + 1);
  };

  return (
    <div>
      <h1>Shared State Example</h1>
      <Counter count={count} onIncrement={handleIncrement} />
      <Counter count={count} onIncrement={handleIncrement} />
    </div>
  );
};
```

### Efectos secundarios: useEffect

El hook `useEffect` permite manejar **efectos secundarios** en componentes funcionales, es decir operaciones que afectan algo fuera del componente como

- Llamadas a APIs
- Manipulaci√≥n directa del DOM
- Suscripciones a eventos
- Configuraci√≥n de timers o intervals
- Conexiones a WebSockets

Este hook se ejecuta al menos una vez, despu√©s de que el componente se ha renderizado y en respuesta a determinadas situaciones, que veremos m√°s adelante.

La sintaxis b√°sica es la siguiente:

```tsx
import React, { useEffect } from 'react';

export const EffectComponent: React.FC = () => {
  useEffect(
    () => {
      // C√≥digo del efecto
      return () => {
        // C√≥digo de limpieza (opcional)
      };
    },
    [
      /* dependencias */
    ]
  );

  return <div>Effect Component</div>;
};
```

El primer argumento de `useEffect` es una funci√≥n que contiene el c√≥digo del efecto. Esta funci√≥n puede devolver otra funci√≥n que se ejecutar√° cuando el componente se desmonte o cuando las dependencias cambien, lo que permite limpiar recursos como suscripciones o temporizadores.

#### Ejecuci√≥n del efecto: el array de dependencias

El segundo argumento de `useEffect` es un array de dependencias que indica cu√°ndo debe ejecutarse el efecto.

- Si no se proporciona el array de dependencias, el efecto se ejecutar√° despu√©s de cada renderizado del componente. Es como si el c√≥digo estuviera fuera del efecto, directamente en el componente. No suele emplearse.

- Si se pasa un array vac√≠o `[]`, el efecto solo se ejecutar√° una vez, cuando el componente se monte. Esto √∫ltimo ocurrir√° siempre, con independencia del contenido del array de dependencias.
  Como los componentes funcionales no tienen ciclo de vida como los componentes de clase, se consigue asi el mismo comportamiento en aquellos.
  Se puede decir que un efecto con el array de dependencias vac√≠o es equivalente a `componentDidMount` en componentes de clase, en los que un m√©todo con ese nombre se ejecuta una sola vez cuando el componente se monta.

- Si se a√±aden dependencias, el efecto se ejecutar√° cada vez que alguna de las dependencias cambie de valor. React compara los valores actuales de las dependencias con los valores anteriores utilizando el algoritmo de comparaci√≥n de igualdad estricta (`===`). Si alguno de los valores ha cambiado, el efecto se ejecuta de nuevo.

En Resumen, **reglas de uso** del hook useEffect

1. Siempre se ejecuta al menos una vez, despu√©s del primer renderizado del componente.
2. Las dependencias deben incluir todo lo que uses dentro del efecto que provenga del √°mbito del componente (props, estados, funciones definidas en el componente, etc.)
3. Evita modificar las dependencias dentro del efecto, ya que puede provocar bucles infinitos de renderizado.

#### üßøComponente BasicTimer

Veamos un ejemplo sin dependencia. En la carpeta `features/counters/timers`, creamos un componente `BasicTimer` que utiliza `useEffect` para iniciar un temporizador cuando el componente se monta. El temporizador incrementa un contador cada 100 milisegundos y proporciona un bot√≥n para reiniciar el contador a cero.

```tsx
import { Card } from '@core/components/card/card';
import { useEffect, useState } from 'react';

export const BasicTimer: React.FC = () => {
  const [count, setCount] = useState(0);

  const handleReset: React.MouseEventHandler<HTMLButtonElement> = () => {
    setCount(0);
  };

  useEffect(() => {
    const intervalId = setInterval(() => {
      setCount((prevCount) => prevCount + 1);
    }, 100);
    return (): void => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, []);

  return (
    <Card title="Basic timer">
      <p>
        Counter <output className="timer">{count}</output>
      </p>
      <button onClick={handleReset}>Reset</button>
    </Card>
  );
};
```

Algunos efectos pueden requerir limpieza para evitar fugas de memoria o comportamientos inesperados.

#### Limpieza de efectos

La **funci√≥n de limpieza** se define dentro del efecto como el retorno del hook y se ejecuta cuando el componente se desmonta o antes de que el efecto se vuelva a ejecutar si las dependencias han cambiado.

Los casos en los que es necesario limpiar un efecto incluyen:

- **Suscripciones a eventos**: Si el efecto suscribe a eventos (por ejemplo, eventos del navegador o de un WebSocket), es importante cancelar la suscripci√≥n cuando el componente se desmonte para evitar fugas de memoria.
- **Timers**: Si el efecto crea timers (como `setTimeout` o `setInterval`), es necesario limpiar esos timers para evitar que sigan ejecut√°ndose despu√©s de que el componente se haya desmontado.
- **Recursos externos**: Si el efecto abre conexiones a recursos externos (como bases de datos o APIs), es importante cerrar esas conexiones cuando el componente se desmonte.

En nuestro anterior ejemplo, si se monta un intervalo, es importante limpiarlo cuando el componente se desmonte. Si no, el interval seguir√° ejecut√°ndose en segundo plano, intentando actualizar un componente que ya no existe. Esto es una **fugas de memoria** (**memory leak**).

#### üßøComponente Counter: useEffect con dependencias

`useEffect` no necesita tipado expl√≠cito en TypeScript, pero el uso interno debe ser coherente con los tipos de estado y props, especialmente si el efecto depende de ellos.

En el componente Counter que venimos usando podemos a√±adir un efecto que depende de un estado de tipo `number`, por lo que debemos asegurarnos de que el efecto maneje correctamente ese tipo.

```tsx
import { useState, useEffect } from 'react';

export const Counter = () => {
  const [count, setCount] = useState<number>(0);

  useEffect(() => {
    document.title = `Clicks: ${count}`;
  }, [count]);

  return (
    <button onClick={() => setCount((c) => c + 1)}>Clicks: {count}</button>
  );
};
```

En este caso, el efecto consiste en actualizar el t√≠tulo del documento con el valor del contador cada vez que `count` cambia.

Siempre que usamos dentro del efecto un valor del componente , debemos incluirlo en e array de dependencias, y as√≠ nos lo indica el linter. Como se trate a de un array, podemos tener todas las dependencias que sea necesario

#### üßøComponente Counter: multiples useEffect

Un componente puede tener m√∫ltiples llamadas a `useEffect` para manejar diferentes efectos secundarios. Cada llamada a `useEffect` es independiente y puede tener sus propias dependencias. Por ejemplo, en un caso el array de dependencias est√° vac√≠o, por lo que el efecto se ejecuta solo una vez al montar el componente, y en otro caso depende de una variable de estado, por lo que se ejecuta cada vez que esa variable cambia.

```tsx
import React, { useEffect, useState } from 'react';

export const Counter: React.FC = () => {
  const [count, setCount] = useState<number>(0);

  useEffect(() => {
    console.log(`Inicializaci√≥n del componente`);
  }, []);

  useEffect(() => {
    document.title = `Clicks: ${count}`;
  }, [count]);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>Clicks: {count}</button>
    </div>
  );
};
```

#### üßøComponente FullTimer: ejemplo final de useEffect

```tsx
import { Card } from '@core/components/card/card';
import { useEffect, useState } from 'react';

export const FullTimer: React.FC = () => {
  const [count, setCount] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  const handleStop: React.MouseEventHandler<HTMLButtonElement> = () => {
    setCount(0);
    setIsRunning(false);
  };

  const handleStart = (isRunning: boolean): void => {
    setIsRunning(isRunning);
  };

  useEffect(() => {
    if (!isRunning) {
      return;
    }

    const intervalId = setInterval(() => {
      setCount((prevCount) => prevCount + 1);
    }, 100);
    return (): void => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [isRunning]);

  return (
    <Card title="3 Buttons timer">
      <p>
        Counter <output className="timer">{count}</output>
      </p>
      <button onClick={() => handleStart(true)}>Star</button>
      <button onClick={() => handleStart(false)}>Pause</button>
      <button onClick={handleStop}>Stop</button>
    </Card>
  );
};
```

#### Buenas practicas con los efectos

Evitar usar efectos innecesarios: Solo utilizar `useEffect` cuando sea necesario para manejar efectos secundarios. Si un efecto no tiene dependencias o no realiza ninguna acci√≥n significativa, es mejor evitar su uso.

Situaciones **a evitar**:

- efectos para transformar datos que ya se pueden transformar directamente en el renderizado
- efectos para actualizar el estado con valores derivados de otros estados o props (calcular esos valores directamente en el renderizado)
- efectos para ejecutar funciones que no tienen efectos secundarios (estas funciones se pueden llamar directamente en el renderizado o en respuesta a eventos)
- efectos para inicializar valores (estados) que ya se pueden inicializar directamente en la declaraci√≥n del estado

**Casos de uso** habituales para useEffect:

- llamadas a APIs para obtener datos
- modificar el DOM directamente
- suscripciones a eventos (y limpieza de las mismas)

#### Objetos (arrays, funciones) como dependencias

Si es posible, conviene evitar incluir objetos (o arrays) como dependencias directamente, ya que se crean nuevas referencias en cada renderizado. En su lugar, las alternativas son

- usar valores primitivos, e.g. las propiedades del objeto necesarias
- memoizar (memoize) los objetos/arrays con `useMemo` o `useCallback`.

### Referencias persistentes: useRef, useMemo, useCallback

El hook `useRef` permite crear una referencia mutable que persiste durante todo el ciclo de vida del componente. Son valores que los componentes recuerdan y que se pueden actualizar pero sin provocar render:
es como un estado (useState) pero sin provocar render al cambiar

la refs permiten guardar:

- timeout o interval ids
- referencias a elementos del DOM
- cualquier valor que necesitemos guardar en un componente y que no queramos que cause render

Por ejemplo podemos querer un contador del n√∫mero de renders de un componente. Si creamos una variable dentro del componente, se reiniciar√° a cero en cada render. Si utilizamos useState, cada vez que actualicemos el contador, el componente se volver√° a renderizar, creando un bucle infinito. En cambio, si utilizamos useRef, podemos mantener el valor entre renders sin provocar un nuevo renderizado:

```tsx
export const Render: React.FC = () => {
  let renderCount = 0; // cada render se reinicia
  const renderCountRef = useRef(0); // cada render mantiene el valor previo
  renderCount++;
  renderCountRef.current++;

  const [count, setCount] = useState<number>(0);

  const handleClick = () => {
    // setCount(count + 1);
    setCount((c) => c + 1);
    console.log('Component State', count);
  };

  return (
    <>
      <h2>React with state</h2>
      <div className="card">
        <button onClick={handleClick}>count is {count}</button>
        <p>Render number (var) {renderCount}</p>
        <p>Render number (ref) {renderCountRef.current}</p>
      </div>
    </>
  );
};
```

#### Ref a elementos del DOM

Las ref se utilizan com√∫nmente para acceder directamente a **elementos del DOM**.

- se crea una ref con `useRef` indicando en su gen√©rico el tipo del elemento HTML que se va a referenciar
- se inicializa a `null`.
- se asigna la ref al elemento JSX utilizando el atributo `ref`.

La sintaxis b√°sica es la siguiente:

```tsx
import React, { useRef } from 'react';
export const RefComponent: React.FC = () => {
  const inputRef = useRef<HTMLInputElement>(null);

  const focusInput = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input type="text" ref={inputRef} />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
};
```

##### [Avanzado] Paso de referencias entre componentes: forwardRef

El problema se produce cuando tenemos un componente hijo que tiene que recibir una referencia de un componente padre. En este caso, el componente hijo no puede recibir la referencia directamente, ya que no es un elemento del DOM. Para solucionar esto, se utiliza `forwardRef`, que permite pasar la referencia al componente hijo.

Veamos un ejemplo con un componente `Input` que recibe una referencia y la pasa a un elemento `input` dentro de su implementaci√≥n. El componente padre puede crear la referencia y pasarla al componente hijo.

```tsx
import React, { forwardRef, useRef } from 'react';
type InputProps = React.InputHTMLAttributes<HTMLInputElement>;

// type InputProps ={
//     name: string;
//     // id?: string;
//     // value?: string;
//     // onChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;
//     // onBlur?: (event: React.FocusEvent<HTMLInputElement>) => void;
//     // onFocus?: (event: React.FocusEvent<HTMLInputElement>) => void;
//     // placeholder?: string;
//     // className?: string;
//     // style?: React.CSSProperties;
// };

const Input = forwardRef<HTMLInputElement, InputProps>(({ name }, ref) => {
  return (
    <input
      ref={ref} // Referencia al input
      type="text"
      id="fc2-name"
      name={name}
    />
  );
});
```

El tipado de `InputProps` es el mismo que el de un elemento `input`, pero se puede personalizar para incluir solo los props que se necesiten. En este caso, en los comentarios, se ha dejado solo el `name`, pero se pueden a√±adir m√°s props seg√∫n sea necesario.

El tipado gen√©rico de `forwardRef` es `forwardRef<T, P>`, donde `T` es el tipo del elemento al que se hace referencia y `P` son los props del componente. Curiosamente al rev√©s de como se reciben los par√°metros. En este caso, el tipo de referencia es `HTMLInputElement` y el tipo de props es `InputProps`.

Desde el componente padre, se puede crear una referencia y pasarla al componente hijo. El componente padre puede crear la referencia y pasarla al componente hijo.

```tsx
export const FormFocusDS: React.FC = () => {
  // const inputRef = createRef<HTMLInputElement>();
  const inputRef = useRef<HTMLInputElement>(null);

  const focusInput = (): void => {
    // Enfocar el input
    if (inputRef && inputRef.current) {
      inputRef.current.focus();
    }
  };
  return (
    <form>
      <div>
        <label htmlFor="name">Name</label>
        <Input name="name" ref={inputRef} />
      </div>
      <button type="submit">Submit</button>
      <button type="button" onClick={focusInput}>
        Focus
      </button>
    </form>
  );
};
```

##### [Avanzado] La prop `ref` en React 19

En React 19, se a a√±adido la prop `ref`, que se puede usar directamente en componentes funcionales sin necesidad de `forwardRef`.

```tsx
const Input: React.FC<InputProps> = ({ name, ref }) => {
  return (
    <input
      ref={ref} // Referencia al input
      type="text"
      id="fc3-name"
      name={name}
    />
  );
};
```

#### Referencias inmutables

Pare crear referencias inmutables, que no cambian entre renderizados, se puede utilizar `useRef` sin inicializarlo a `null`. Por ejemplo, para almacenar una configuraci√≥n o un valor constante que no debe cambiar:

```tsx
import React, { useRef } from 'react';
export const ImmutableRefComponent: React.FC = () => {
  const configRef = useRef({
    apiUrl: 'https://api.example.com',
    timeout: 5000,
  });
  return (
    <div>
      <p>API URL: {configRef.current.apiUrl}</p>
      <p>Timeout: {configRef.current.timeout} ms</p>
    </div>
  );
};
```

Otra forma de crear referencias que no pueden ser mutadas por el desarrollador es utilizando `useMemo`, que memoiza (en ingl√©s memoize) un valor y solo lo recalcula si cambian las dependencias. Por ejemplo:

```tsx
import React, { useMemo } from 'react';
export const ImmutableMemoComponent: React.FC = () => {
  const config = useMemo(
    () => ({ apiUrl: 'https://api.example.com', timeout: 5000 }),
    []
  );
  return (
    <div>
      <p>API URL: {config.apiUrl}</p>
      <p>Timeout: {config.timeout} ms</p>
    </div>
  );
};
```

Si en lugar de un objeto queremos una referencia inmutable a una funci√≥n, podemos usar `useCallback`, que memoiza una funci√≥n y solo la recrea si cambian las dependencias. Por ejemplo:

```tsx
import React, { useCallback } from 'react';
export const ImmutableCallbackComponent: React.FC = () => {
  const fetchData = useCallback(() => {
    // L√≥gica para obtener datos
  }, []);
  return (
    <div>
      <button onClick={fetchData}>Fetch Data</button>
    </div>
  );
};
```

## Formularios

### Tipos de formularios en React

En React, existen dos enfoques principales para manejar formularios:

- **formularios controlados**: donde el estado del formulario se gestiona mediante el estado interno del componente
- **formularios no controlados**: donde el estado del formulario se gestiona mediante referencias (refs) a los elementos del DOM.

### Formularios controlados con un campo

En los formularios controlados, el valor de los campos del formulario (como inputs, selects, text-areas) se almacena en el estado interno del componente. Cada vez que el usuario interact√∫a con un campo (por ejemplo, escribe en un input), se actualiza el estado del componente mediante un manejador de eventos (event handler). El valor del campo se establece a partir del estado del componente.

#### üßø Componente SearchForm: formulario controlado

Veamos un **formulario controlado** de React, con un s√≥lo campo, como puede ser un campo de texto, para una b√∫squeda. En la carpeta `features/forms`, creamos un componente `SearchForm`.

En este ejemplo, el formulario tiene un manejador de eventos para el cambio del campo de texto (`onChange`) y otro para el env√≠o del formulario (`onSubmit`)

El valor del campo de texto se almacena en el estado interno del componente formulario y se actualiza cada vez que el campo cambia (el usuario escribe en el campo o selecciona un valor).

```tsx
import { Card } from '@core/components/card/card';
import React, { useState } from 'react';

export const SearchForm: React.FC = () => {
  const [value, setValue] = useState<string>('');

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    setValue(e.target.value);
    console.log('Search submitted with value:', value);
  };

  const handleReset = (): void => {
    setValue('');
  };

  return (
    <Card title="Formulario de b√∫squeda">
      <p>Formulario controlado b√°sico</p>
      <form>
        <input
          type="text"
          placeholder="Escribe tu b√∫squeda"
          value={value}
          onChange={handleChange}
        />
        <button type="reset" onClick={handleReset}>
          Limpiar
        </button>
      </form>
      <p>
        Tu b√∫squeda: <output>{value}</output>
      </p>
    </Card>
  );
};
```

En un formulario controlado, el valor del campo de texto se almacena en el **estado interno** del componente (`value`) y se actualiza cada vez que el campo cambia. Podemos verlo en el \<output> que muestra en todo momento el valor actual de la b√∫squeda.

Esto permite que el componente tenga un control total sobre el valor del campo de texto y se pueda manejar el env√≠o del formulario de manera m√°s eficiente, sin necesitar acceder al target para obtener el valor del campo.

En el manejador de eventos `handleChange`, el evento se tipa como `React.ChangeEvent<HTMLInputElement>`, que es el tipo adecuado para eventos de cambio en elementos de entrada de texto. Esto permite acceder a las propiedades espec√≠ficas del elemento HTML, como `value`, con el tipo correcto.

En este caso, el bot√≥n de env√≠o no es necesario, ya que el formulario se puede enviar autom√°ticamente al cambiar el valor del campo de texto.

Por √∫ltimo, el bot√≥n de **reset**, de tipo `reset` por accesibilidad y sem√°ntica, tiene un manejador de eventos `handleReset` que elimina el valor del estado y como consecuencia
limpia el campo de texto asociado a √©l.

#### [Avanzado] Ejemplos de useRef: foco y debounce

A√±adimos al formulario dos comportamientos que nos van a permitir ver el uso de referencias (refs) en formularios controlados.

- al resetear el formulario, el foco se pone autom√°ticamente en el campo de texto
- se implementa un debounce en el manejador de cambio del campo de texto, para evitar actualizaciones excesivas del estado al escribir r√°pidamente

##### üßø Componente SearchFormPro: debounce y foco

Necesitamos dos referencias:

- una para almacenar el id del timer del debounce, que se crea con `setTimeout` y se limpia con `clearTimeout`
- otra para referenciar el campo de texto, y poder poner el foco en √©l al reset

Y dos estados:

- uno para almacenar el valor actual del campo de texto (`value`), que se actualiza en cada cambio
- otro para almacenar el valor de la b√∫squeda (`textSearch`), que se actualiza con el debounce

```tsx
import { Card } from '@core/components/card/card';
import { useEffect, useRef, useState } from 'react';

export const SearchFormPro: React.FC = () => {
  // const refTimer = useRef<NodeJS.Timeout | null>(null);
  const refTimer = useRef<number>(0);
  const refInput = useRef<HTMLInputElement>(null);
  const [value, setValue] = useState<string>('');
  const [textSearch, setTextSearch] = useState<string>('');

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    if (refTimer) {
      clearTimeout(refTimer.current);
    }
    setValue(e.target.value);

    refTimer.current = window.setTimeout(() => {
      setTextSearch(e.target.value);
      console.log('Search submitted with value:', value);
    }, 500);
  };

  const handleReset = (): void => {
    setValue('');
    refInput.current?.focus();
  };

  useEffect(() => {
    return (): void => {
      if (refTimer) {
        clearTimeout(refTimer.current);
      }
    };
  }, []);

  return (
    <Card title="Formulario de b√∫squeda Pro">
      <p>Formulario controlado con foco y debounce</p>
      <form>
        <input
          type="text"
          placeholder="Escribe tu b√∫squeda"
          value={value}
          onChange={handleChange}
          ref={refInput}
        />
        <button type="reset" onClick={handleReset}>
          Limpiar
        </button>
      </form>
      <p>
        Tu b√∫squeda: <output>{textSearch}</output>
      </p>
    </Card>
  );
};
```

Para el comportamiento de foco, se crea una referencia `refInput` al campo de texto utilizando `useRef<HTMLInputElement>(null)` y se le asigna al elemento input mediante la propiedad `ref`. En el manejador de reset, se utiliza `refInput.current?.focus()` para poner el foco en el campo de texto despu√©s de limpiar el valor.

Para el comportamiento de debounce, se crea una referencia `refTimer` para almacenar el id del timer. En el manejador de cambio (handleChange), se limpia cualquier timer existente con `clearTimeout` antes de crear un nuevo timer con `setTimeout`. Cuando el timer se ejecuta despu√©s del retraso especificado (500 ms en este caso), se actualiza el estado `textSearch` con el valor actual del campo de texto.

### Formularios controlados con m√∫ltiples campos

Al tener varios campos, es com√∫n la siguiente estrategia:

- crear un **tipo** que representa el conjunto de **valores** de todos los campos del formulario
- definir un **objeto** con ese tipo para almacenar los valores en el **estado** del componente
- cada campo del formulario se **asocia** a una propiedad del objeto, haciendo que la propiedad `name` del campo coincida con el nombre de la propiedad del objeto
- se utiliza un manejador de eventos o **handler gen√©rico** para actualizar el valor correspondiente en el estado cuando el usuario interact√∫a con el campo.

```tsx
const handleChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
  const { name, value } = e.target;
  setUserData({ ...userData, [name]: value });
};
```

- extraemos del target del evento el `name` y el `value` del campo que ha cambiado
- actualizamos el estado del formulario creando un nuevo objeto que copia todas las propiedades del objeto actual (`...userData`) y sobrescribe la propiedad correspondiente al campo que ha cambiado (`[name]: value`).

#### üßø Componente LoginForm b√°sico: useId

Veamos un ejemplo de un formulario controlado con 2 campos de texto, donde

- se define como un tipo el objeto que almacena los valores de los campos del formulario, y
- una funci√≥n gen√©rica maneja el cambio de cualquiera de los campos del formulario
- una funci√≥n manejar el env√≠o del formulario (en este caso solo a la consola).

El hook useId se utiliza para generar identificadores √∫nicos para los campos del formulario, lo que luego facilita una mejora de la accesibilidad.

En las etiquetas `label`, se utiliza el atributo `htmlFor` para asociar la etiqueta con el campo de entrada correspondiente mediante el id generado por `useId`. Esto mejora la accesibilidad, ya que permite a los usuarios de tecnolog√≠as asistidas identificar claramente qu√© etiqueta corresponde a qu√© campo de entrada.

Adem√°s vemos un ejemplo de uso de estilos en l√≠nea para alinear las etiquetas y los campos de entrada en el formulario.

```tsx
import { Card } from '@core/components/card/card';
import { useId, useState } from 'react';

type Login = {
  email: string;
  password: string;
};

const initialState: Login = {
  email: '',
  password: '',
};

export const LoginForm: React.FC = () => {
  const [userData, setUserData] = useState<Login>(initialState);

  const emailId = useId();
  const passwordId = useId();

  const handleSubmit = (e: React.FormEvent): void => {
    e.preventDefault();
    console.log('Formulario enviado:', userData);
    setUserData(initialState);
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const { name, value } = e.target;
    setUserData({ ...userData, [name]: value });
  };

  return (
    <Card title="Formulario de Login">
      <p>Formulario controlado b√°sico con 2 campos</p>
      <form onSubmit={handleSubmit}>
        <div className="group-control">
          <label htmlFor={emailId}>
            <span style={{ display: 'inline-block', width: '6rem' }}>
              Email:
            </span>
            <input
              type="email"
              name="email"
              id={emailId}
              placeholder="Dime tu email"
              aria-label="email"
              required
              value={userData.email}
              onChange={handleChange}
            />
          </label>
        </div>
        <div className="group-control">
          <label htmlFor={passwordId}>
            <span style={{ display: 'inline-block', width: '6rem' }}>
              Password:
            </span>
            <input
              type="password"
              name="password"
              id={passwordId}
              placeholder="Dime tu password"
              aria-label="password"
              required
              value={userData.password}
              onChange={handleChange}
            />
          </label>
        </div>
        <div>
          <button type="submit">Enviar</button>
        </div>
      </form>
      <p>Ver el resultado en la consola del navegador</p>
    </Card>
  );
};
```

Para el env√≠o del formulario, creamos el manejador de eventos `handleSubmit` que recibe un evento de tipo `React.FormEvent` correspondiente al evento `submit` que se produce cuando se env√≠a un formulario. Este evento se utiliza para

- evitar el comportamiento por defecto del navegador, que es recargar la p√°gina al enviar el formulario, mediante la llamada a `e.preventDefault()`
- manejar el env√≠o de los datos, en este caso simplemente mostrando el valor actual del campo de texto en la consola.

#### üßø Componente LoginForm con otros controles

Si el formulario incluye un campo de tipo `checkbox`, `radiobutton` o `select`, el evento `ChangeEvent` se tipar√° de forma m√°s extensa, utilizando una uni√≥n de tipos, que incluye el tipo `HTMLInputElement` o `HTMLSelectElement`, dependiendo del tipo de elemento al que se aplica el evento.

Adem√°s el c√≥digo del handler tiene que contemplar el comportamiento de los checkbox, accediendo a la propiedad checked en lugar de al value.

```tsx
const handleChange = (
  ev: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
) => {
  const formControl = ev.target;
  // desestructurar no podr√≠a acceder a .checked si se incluyen selects
  // se accede m√°s adelante gracias a una guarda de tipos
  console.dir(formControl);
  setUserData({
    ...userData,
    [formControl.name]:
      formControl.type === 'checkbox' ? formControl.checked : formControl.value,
  });
};
```

Veamos un ejemplo del formulario controlado de login con 3 campos, donde uno de ellos es un checkbox para recordar al usuario.

```tsx
import { Card } from '@core/components/card/card';
import { useId, useState } from 'react';

type Login = {
  email: string;
  password: string;
  rememberMe: boolean;
};

const initialState: Login = {
  email: '',
  password: '',
  rememberMe: false,
};

export const LoginFormRemember: React.FC = () => {
  const [userData, setUserData] = useState<Login>(initialState);

  const emailId = useId();
  const passwordId = useId();
  const rememberMeId = useId();

  const handleSubmit = (e: React.FormEvent): void => {
    e.preventDefault();
    console.log('Formulario enviado:', userData);
    setUserData(initialState);
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const { name, value, type, checked } = e.target;
    setUserData({
      ...userData,
      [name]: type === 'checkbox' ? checked : value,
    });
  };

  return (
    <Card title="Formulario de Login">
      <p>Formulario controlado b√°sico con 3 campos (1 checkbox)</p>
      <form onSubmit={handleSubmit}>
        <div className="group-control">
          <label htmlFor={emailId}>
            <span style={{ display: 'inline-block', width: '6rem' }}>
              Email:
            </span>
            <input
              type="email"
              name="email"
              id={emailId}
              placeholder="Dime tu email"
              aria-label="email"
              required
              value={userData.email}
              onChange={handleChange}
            />
          </label>
        </div>
        <div className="group-control">
          <label htmlFor={passwordId}>
            <span style={{ display: 'inline-block', width: '6rem' }}>
              Password:
            </span>
            <input
              type="password"
              name="password"
              id={passwordId}
              placeholder="Dime tu password"
              aria-label="password"
              required
              value={userData.password}
              onChange={handleChange}
            />
          </label>
        </div>
        <div>
          <label htmlFor={rememberMeId}>
            <input
              type="checkbox"
              name="rememberMe"
              id={rememberMeId}
              aria-label="rememberMe"
              checked={userData.rememberMe}
              onChange={handleChange}
            />
            <span style={{ marginLeft: '0.5rem' }}>Recu√©rdame</span>
          </label>
        </div>
        <div>
          <button type="submit">Enviar</button>
        </div>
      </form>
    </Card>
  );
};
```

### Validaci√≥n de formularios

Con independencia del tipo de formulario, siembre se puede utilizar la validaci√≥n nativa de HTML5, que incluye atributos como `required`, `minLength`, `maxLength`, `pattern`, etc., en los campos del formulario. El navegador se encargar√° de validar los campos autom√°ticamente al enviar el formulario y mostrar√° mensajes de error si alg√∫n campo no cumple con las reglas de validaci√≥n.

La alternativa es implementar una validaci√≥n personalizada en el manejador de env√≠o del formulario (`handleSubmit`), donde se pueden comprobar los valores de los campos y mostrar mensajes de error si es necesario.

#### üßø Componente LoginForm con validaci√≥n

Veamos un ejemplo del formulario controlado de login con 3 campos, donde, adem√°s de lo anterior,

- se define un tipo para almacenar los errores de validaci√≥n del formulario
- se crea un estado para almacenar los errores de validaci√≥n
- se implementa una funci√≥n de validaci√≥n que comprueba los valores de los campos y actualiza el estado de errores
- se muestra un mensaje de error debajo de cada campo si hay un error de validaci√≥n
- la validaci√≥n se desencadena cuando el usuario intenta enviar el formulario
- los mensajes de error desaparecen cuando el usuario interacciona con los campos (onFocus)

```tsx
import { Card } from '@core/components/card/card';
import { useId, useState } from 'react';

type Login = {
  email: string;
  password: string;
  rememberMe: boolean;
};
type FormErrors = {
  email?: string;
  password?: string;
};

const initialState: Login = {
  email: '',
  password: '',
  rememberMe: false,
};

export const LoginFormValidation: React.FC = () => {
  const [userData, setUserData] = useState<Login>(initialState);
  const [formErrors, setFormErrors] = useState<FormErrors>({});

  const emailId = useId();
  const passwordId = useId();
  const rememberMeId = useId();

  const validate = (userData: Login): boolean => {
    setFormErrors({});
    if (!userData.email) {
      // setFormErrors({ ...formErrors, email: 'El email es obligatorio' });
      setFormErrors((prev) => ({
        ...prev,
        email: 'El email es obligatorio',
      }));
    }
    if (!userData.password) {
      // setFormErrors({
      //     ...formErrors,
      //     password: 'La password es obligatoria',
      // });
      setFormErrors((prev) => ({
        ...prev,
        password: 'La password es obligatoria',
      }));
    }
    console.log(formErrors);
    return Boolean(userData.email && userData.password);
  };

  const handleSubmit = (e: React.FormEvent): void => {
    e.preventDefault();
    if (validate(userData)) {
      setFormErrors({});
      console.log('Formulario enviado:', userData);
    }
  };

  const handleFocus = (): void => {
    setFormErrors({});
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const { name, value, type, checked } = e.target;
    setUserData({
      ...userData,
      [name]: type === 'checkbox' ? checked : value,
    });
  };

  return (
    <Card title="Formulario de Login">
      <p>Formulario controlado b√°sico con 3 campos y validaci√≥n</p>
      <form onSubmit={handleSubmit} noValidate>
        <div className="group-control">
          <label htmlFor={emailId}>
            <span style={{ display: 'inline-block', width: '6rem' }}>
              Email:
            </span>
            <input
              type="email"
              name="email"
              id={emailId}
              placeholder="Dime tu email"
              aria-label="email"
              required
              value={userData.email}
              onChange={handleChange}
              onFocus={handleFocus}
            />
          </label>
        </div>
        {formErrors.email && <p style={{ color: 'red' }}>{formErrors.email}</p>}
        <div className="group-control">
          <label htmlFor={passwordId}>
            <span style={{ display: 'inline-block', width: '6rem' }}>
              Password:
            </span>
            <input
              type="password"
              name="password"
              id={passwordId}
              placeholder="Dime tu password"
              aria-label="password"
              required
              value={userData.password}
              onChange={handleChange}
              onFocus={handleFocus}
            />
          </label>
        </div>
        {formErrors.password && (
          <p style={{ color: 'red' }}>{formErrors.password}</p>
        )}
        <div>
          <label htmlFor={rememberMeId}>
            <input
              type="checkbox"
              name="rememberMe"
              id={rememberMeId}
              aria-label="rememberMe"
              checked={userData.rememberMe}
              onChange={handleChange}
            />
            <span style={{ marginLeft: '0.5rem' }}>Recu√©rdame</span>
          </label>
        </div>
        <div>
          <button type="submit">Enviar</button>
        </div>
      </form>
    </Card>
  );
};
```

Si no se eliminan los atributos de validaci√≥n nativa de HTML5, el navegador mostrar√° sus propios mensajes de error al enviar el formulario, lo que puede interferir con la validaci√≥n personalizada. Por eso se a√±ade el atributo `noValidate` al elemento `<form>` para desactivar la validaci√≥n nativa del navegador.

El m√©todo de validaci√≥n act√∫a sobre el formulario completo, lo que nos permite ver un ejemplo de uso de la funci√≥n `setFormErrors` con una funci√≥n callback, para asegurarnos de que estamos actualizando el estado a partir del estado m√°s reciente.

### Formularios no controlados. FormData

Una alternativa a los formularios controlados son los formularios no controlados, donde el valor los campos (HTMLInput, HTMLSelect o HTMLTextArea) se almacena en el DOM y se accede a ellos solo en el momento de enviar el formulario, sin necesidad de almacenarlos en el estado interno del componente. Esto se puede hacer utilizando una referencia (ref) al elemento del DOM del propio formulario, que se puede obtener del evento submit.

```tsx
  const handleSubmit = (ev: React.FormEvent<HTMLFormElement>): void => {
      ev.preventDefault();
      const form = ev.currentTarget; // EventTarget & HTMLFormElement
      ...
  }
```

A partir de ah√≠ existen diversas posibilidades

- obtener las referencias a los elementos del formulario y acceder a sus valores directamente. Todas las referencias a los controles est√°n incluidas en el HTMLFormElement

- utilizar un FORMData, que es un objeto que representa los datos de un formulario y permite acceder a los valores de los campos del formulario de manera m√°s sencilla.

#### üßø Componente RegisterForm: JSX (casi HTML)

En el elemento retornado por el componente vemos un formulario no controlado con varios tipos de campos: texto, email, password, checkbox, radiobutton y select.

Tambi√©n observamos que apenas hay elementos de React:

- la funci√≥n `handleSubmit` se asocia al evento `onSubmit` del formulario
- se utilizan los ids generados con `useId` para mejorar la accesibilidad del formulario
- se utiliza `defaultValue` y `defaultChecked` para inicializar los valores de los campos del formulario, en lugar de `value` y `checked`, que se utilizan en formularios controlados.

```tsx
return (
  <Card title="Formulario de registro">
    <p>Ejemplo de 'Controlled Form'</p>
    <form onSubmit={handleSubmit}>
      <div className="group-control">
        <input
          type="text"
          placeholder="Dime tu nombre"
          required
          name="userName"
          id={registerIds.userName}
          defaultValue={userDataInitial.userName}
        />
      </div>

      <div className="group-control">
        <input
          type="email"
          placeholder="Dime tu email"
          required
          name="email"
          id={registerIds.email}
          defaultValue={userDataInitial.email}
        />
      </div>

      <div className="group-control">
        <input
          type="password"
          placeholder="Dime tu password"
          required
          name="password"
          id={registerIds.password}
          defaultValue={userDataInitial.password}
        />
      </div>

      <div className="group-control-line">
        <input
          type="checkbox"
          id={registerIds.isOkConditions}
          name="isOkConditions"
          defaultChecked={userDataInitial.isOkConditions}
        />
        <label htmlFor={registerIds.isOkConditions}>
          Acepto las condiciones...
        </label>
      </div>

      <fieldset name="turn">
        <legend>Selecciona un turno</legend>
        <div className="group-control-line">
          <label htmlFor={registerIds.turn + '-m'}>
            <input
              type="radio"
              name="turn"
              id={registerIds.turn + '-m'}
              value="M"
            />
            <span>Ma√±ana</span>
          </label>

          <label htmlFor={registerIds.turn + '-t'}>
            <input
              type="radio"
              name="turn"
              id={registerIds.turn + '-t'}
              value="T"
            />
            <span>Tarde</span>
          </label>
          <label htmlFor={registerIds.turn + '-n'}>
            <input
              type="radio"
              name="turn"
              id={registerIds.turn + '-n'}
              value="N"
            />
            <span>Noche</span>
          </label>
        </div>
      </fieldset>
      <div className="group-control-line">
        <label htmlFor={registerIds.course}>
          <span>Elige un curso</span>
          <select
            name="course"
            id={registerIds.course}
            defaultValue={userDataInitial.course}
          >
            <option value=""></option>
            <option value="A">Angular</option>
            <option value="R">React</option>
            <option value="N">Node</option>
          </select>
        </label>
      </div>
      <div>
        <button type="submit">Enviar</button>
      </div>
    </form>
  </Card>
);
```

El componente no controla los valores de los campos, solo los inicializa. Podemos interactuar con el formulario y cambiar los valores de los campos sin que el componente se entere. S√≥lo en el handleSubmit, cuando se env√≠a el formulario, se accede a los valores de los campos directamente desde el DOM.

#### Accediendo a los valores del formulario

En el m√©todo `handleSubmit`, se puede acceder a los valores de los campos del formulario utilizando las propiedades del objeto `HTMLFormElement`, que es el tipo del elemento del formulario. Esto permite acceder a los valores de los campos del formulario sin necesidad de almacenarlos en el estado interno del componente.

```tsx
const userNameElement = formElements.namedItem('userName') as HTMLInputElement;
const emailElement = formElements.namedItem('email') as HTMLInputElement;
const passwdElement = formElements.namedItem('passwd') as HTMLInputElement;
const isOkConditionsElement = formElements.namedItem(
  'isOkConditions'
) as HTMLInputElement;
const turnElement = formElements.namedItem('turn') as HTMLInputElement;
const courseElement = formElements.namedItem('course') as HTMLSelectElement;
const result = {
  userName: userNameElement.value,
  email: emailElement.value,
  passwd: passwdElement.value,
  // como isOkConditions es un booleano, se obtiene del atributo checked
  isOkConditions: isOkConditionsElement.checked,
  turn: turnElement.value,
  course: courseElement.value,
};
```

Si queremos refactorizar el c√≥digo anterior, obtendr√≠amos algo como esto:

```tsx
const result: Record<string, string | boolean> = {};
for (const key of keys) {
  const element = formElements.namedItem(key) as HTMLInputElement;
  // Si el elemento es un checkbox, se obtiene el valor del atributo checked
  result[key] =
    typeof userData[key] === 'boolean'
      ? element.checked
      : (result[key] = element.value);
}
```

#### FormData

El objeto `FormData` es un objeto que representa los datos de un formulario y permite acceder a los valores de los campos del formulario de manera m√°s sencilla. Se puede crear un objeto `FormData` a partir de un elemento HTML de formulario.
La interfaz FormData proporciona una iterador que permite obtener un conjunto de parejas clave/valor que representan los campos de un formulario y sus valores.

```tsx
  const formData = new FormData(form);
);
```

- accediendo manualmente a cada elemento del formData gracias al m√©todo get y el nombre del campo

```tsx sample6.b.course.register.tsx
const formData = new FormData(form);
const result = {
  userName: formData.get('userName') as string,
  email: formData.get('email') as string,
  passwd: formData.get('passwd') as string,
  // isOkConditions es un booleano, pero FormData devuelve un string
  isOkConditions: formData.get('isCondition') === 'on',
  turn: formData.get('turn') as string,
  course: formData.get('course') as string,
};
return result;
```

- utilizando los m√©todos de la clase Object, como `Object.entries`, `Object.keys` o `Object.values`, se puede obtener un array de pares clave/valor, donde cada par representa un campo del formulario y su valor.

```tsx sample6.b.course.register.tsx
const formData = new FormData(form);
const data: Record<string, FormDataEntryValue> = Object.fromEntries(formData);
const result = {
  userName: data.userName as string,
  email: data.email as string,
  passwd: data.passwd as string,
  // isOkConditions es un booleano, pero FormData devuelve un string
  isOkConditions: data.isCondition === 'on',
  turn: data.turn as string,
  course: data.course as string,
};
return result;
```

En lugar de crear el objeto result de forma manual, convendr√≠a hacerlo en la iteraci√≥n, sustituyendo el uso de `fromEntries` por nuestro propio **bucle for/of**.

Como el formData es un iterable, podemos recorrerlo con un bucle for/of, obteniendo en cada iteraci√≥n un par clave/valor correspondiente a un campo del formulario y su valor.

```tsx
const formData = new FormData(form);
const data: Record<string, FormDataEntryValue | boolean> = { ...user };

for (const [key, value] of formData) {
  if (typeof userDataInitial[key as keyof Register] === 'boolean') {
    data[key] = value === 'on';
  }
}

return data;
```

Dentro de la iteraci√≥n necesitamos comprobar si el campo es de tipo booleano (checkbox) o no, para asignar el valor correcto al objeto data.
El problema de los checkbox es que el formData devuelve un string, que es 'on' si el checkbox est√° marcado y no contiene la propiedad si no lo est√°. Por eso, para los campos booleanos, no es v√°lido comprobar si el valor es 'on'. Las alternativas son

- comprobar si alguna propiedad no esta presente, y asignarle false, y asignar true a los valores "on".
- detectar las propiedades booleanas a partir del objeto inicial userDataInitial, y asignar true o false en funci√≥n de si el valor es "on" o no existe.

#### Funci√≥n para obtener los datos del formData

Este proceso lo podemos encapsular en una funci√≥n que reciba el formulario y el objeto de datos iniciales y devuelva un objeto con los datos del formulario.

```tsx sample6.b.course.register.tsx
const getDataForm = (form: HTMLFormElement, user: Register): Register => {
  const formData = new FormData(form);
  const data: Record<string, FormDataEntryValue | boolean> = { ...user };

  for (const [key, value] of formData) {
    if (typeof user[key as keyof typeof user] === 'boolean') {
      data[key] = value === 'on';
    } else {
      data[key] = value;
    }
  }

  return data as Register;
```

El problema de este m√©todo es que esta acoplado a que la entidad de los datos sea User. Usando gen√©ricos, se puede hacer m√°s gen√©rica y reutilizable.

```tsx
type ValidT<T> = T extends Record<string, FormDataEntryValue | boolean>
  ? T
  : never;
const getDataForm = <T,>(form: HTMLFormElement, entity: ValidT<T>): T => {
  const formData = new FormData(form);
  const data: Record<string, FormDataEntryValue | boolean> = {};

  for (const [key, value] of formData) {
    if (typeof entity[key as keyof T] === 'boolean') {
      data[key] = value === 'on';
    } else if (typeof entity[key as keyof T] === 'string') {
      data[key] = value;
    }
  }

  return data as T;
};
```

### Componentes creados

- Core
  - üßøApp
  - üßøHeader
  - üßøFooter
  - üßøCounter
  - üßøLogos
  - üßøCard
  - üßøMenu
  - üßøLayout
- Features - Home
  - üßøPanicButton [üßøButton opcional]
  - üßøGreetings
- Features - Counters
  - üßøCounterNoState
  - üßøCounter
  - üßøCounterLogin
  - üßøCounterContainer
  - üßøBasicTimer
  - üßøFullTimer
- Features - Forms
  - üßøSearchForm
  - üßøSearchFormPro
  - üßøLoginForm b√°sico
  - üßøLoginFormRemember
  - üßøLoginFormValidation
  - üßøRegisterForm
