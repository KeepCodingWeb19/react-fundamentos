# Asincron칤a y consumo de APIs

- [Asincron칤a y consumo de APIs](#asincron칤a-y-consumo-de-apis)
  - [Consumo de APIs con Fetch. CRUD](#consumo-de-apis-con-fetch-crud)
    - [API Rest](#api-rest)
      - [游깷API de pruebas (Mock API)](#api-de-pruebas-mock-api)
    - [丘뙖잺Servicio fetchProducts](#勇끕ervicio-fetchproducts)
      - [丘뙖잺Read: getAllProducts y getProductsById](#勇read-getallproducts-y-getproductsbyid)
      - [丘뙖잺Create: createProduct](#勇끆reate-createproduct)
      - [丘뙖잺Update: updateProduct](#勇끗pdate-updateproduct)
      - [丘뙖잺Delete: deleteProduct](#勇끇elete-deleteproduct)
  - [Uso de las funciones as칤ncronas en un componente React](#uso-de-las-funciones-as칤ncronas-en-un-componente-react)
    - [Carga de datos. Estados, efectos y asincron칤a: useCallback y useMemo](#carga-de-datos-estados-efectos-y-asincron칤a-usecallback-y-usememo)
      - [Asincron칤a en el servicio](#asincron칤a-en-el-servicio)
      - [丘뙖잺Hook useProducts / 游쮺omponente ProductsList](#勇끋ook-useproducts--componente-productslist)
        - [Asincron칤a en useEffect usando then](#asincron칤a-en-useeffect-usando-then)
        - [Asincron칤a en useEffect usando async/await](#asincron칤a-en-useeffect-usando-asyncawait)
        - [\[Avanzado\] Uso de una funci칩n recibida por par치metros (o props)](#avanzado-uso-de-una-funci칩n-recibida-por-par치metros-o-props)
        - [\[Avanzado\] Uso de una funci칩n externa: posibles problemas](#avanzado-uso-de-una-funci칩n-externa-posibles-problemas)
        - [\[Avanzado\] Uso de una funci칩n externa: memoizaci칩n (memoization) con useCallback](#avanzado-uso-de-una-funci칩n-externa-memoizaci칩n-memoization-con-usecallback)
      - [丘뙖잺Hook useProducts: Estado de la carga y errores](#勇끋ook-useproducts-estado-de-la-carga-y-errores)
      - [游쮺omponente ProductsList: Estado de la carga y errores](#componente-productslist-estado-de-la-carga-y-errores)
    - [Funciones as칤ncronas en manejadores de eventos](#funciones-as칤ncronas-en-manejadores-de-eventos)
      - [游쮺omponente ProductCard: botones editar y borrar](#componente-productcard-botones-editar-y-borrar)
  - [Autenticaci칩n](#autenticaci칩n)

## Consumo de APIs con Fetch. CRUD

Para consumir APIs en React, podemos utilizar la funci칩n `fetch` nativa de JavaScript o librer칤as como Axios.

En cualquiera de los casos el proceso es as칤ncrono, por lo que obtendremos una promesa que resolveremos para obtener los datos. LA gesti칩n de la promesa puede hacerse con `then` o con `async/await`, y siempre es importante manejar los posibles errores que puedan ocurrir durante la llamada a la API.

En React, las llamadas a APIs pueden ocurrir en dos circunstancias principales:

1. Al montar un componente, para cargar datos iniciales.
2. En respuesta a eventos del usuario, como clics en botones o cambios en formularios

Es necesario realizar las llamadas a APIs

- dentro de un efecto (`useEffect`), para que se ejecuten cuando el componente se monta o cuando cambian ciertas dependencias.
- dentro de manejadores de eventos, para que se ejecuten en respuesta a acciones del usuario.

### API Rest

Por otro lado debemos recordar que tanto `fetch` como Axios utilizan el **protocolo HTTP** para comunicarse con las APIs, por lo que es importante entender los conceptos b치sicos de HTTP, como los m칠todos (GET, POST, PUT, DELETE), los c칩digos de estado (200, 404, 500), y los encabezados (headers).

Por otro lado, muchas APIs siguen el estilo arquitect칩nico REST (Representational State Transfer), que define un conjunto de convenciones para dise침ar APIs web. En una **API REST**, los recursos (como usuarios, productos, etc.) se representan mediante URLs y se manipulan utilizando los m칠todos HTTP.

#### 游깷API de pruebas (Mock API)

Para practicar el consumo de APIs, podemos utilizar una API p칰blica de pruebas que proporciona datos de productos falsos en formato JSON y permite realizar operaciones CRUD (Create, Read, Update, Delete) sobre ellos. Ejemplos de estas APIS son:

- [Fake Store API](https://fakestoreapi.com/)
- [JSONPlaceholder](https://jsonplaceholder.typicode.com/)
- [DummyJSON](https://dummyjson.com/)

Otra opci칩n es hacer una instalaci칩n local de una API de pruebas utilizando herramientas como

- [json-server](https://github.com/typicode/json-server).
- [sparest](https://github.com/kasappeal/sparrest.js), basada en la anterior, con funcionalidades de autenticaci칩n y desarrollada por Alberto Casero, coordinador del Bootcamp de Desarrollo Web de Desarrollo Web de KeepCoding.

### 丘뙖잺Servicio fetchProducts

Vamos a crear un servicio que incluya todas los operaciones basadas en fetch para llevar a cabo las operaciones CRUD (Create, Read, Update, Delete) sobre productos.

#### 丘뙖잺Read: getAllProducts y getProductsById

Empezaremos con una funci칩n que obtenga una lista de productos desde una API p칰blica utilizando `fetch`. Este servicio ser치 una funci칩n as칤ncrona que devolver치 una promesa con los datos obtenidos.

```tsx
export const getAllProducts = async (): Promise<Product[]> => {
  const response = await fetch('https://fakestoreapi.com/products');
  if (!response.ok) {
    throw new Error('Network response was not ok');
  }
  const data: Product[] = await response.json();
  return data;
};
```

Esta funci칩n realiza una llamada a la API utilizando `fetch`, verifica si la respuesta es correcta (c칩digo de estado 200-299) y luego convierte la respuesta en formato JSON. Si la respuesta no es correcta, lanza un error que puede ser capturado por el llamador de la funci칩n.

De esta forma unificamos en un 칰nico mecanismo las posibles situaciones en que no obtenemos los datos correctamente:

- errores de red (generados por la funci칩n fetch)
- respuestas no exitosas (generados por nosotros ante c칩digos de estado HTTP fuera del rango 200-299)
- errores al parsear el JSON (generados por el m칠todo `json()`).

Para obtener un producto por su ID, podemos crear otra funci칩n similar, pero tenemos que tener en cuenta la forma de trabajar dela API. Lo correcto en el est치ndar REST es usar la ruta `/products/{id}` para obtener un producto espec칤fico y retornar un solo objeto producto, no un array con un solo elemento. Si el producto no existe, la API deber칤a retornar un c칩digo de estado 404, con o sin alg칰n dato.

Por lo tanto, la funci칩n ser칤a as칤:

```tsx
export const getProductById = async (id: number): Promise<Product> => {
  const response = await fetch(`https://fakestoreapi.com/products/${id}`);
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('Product not found');
    }
    throw new Error('Network response was not ok');
  }
  const data: Product = await response.json();
  return data;
};
```

#### 丘뙖잺Create: createProduct

Para crear un nuevo producto, utilizaremos el m칠todo HTTP POST. La funci칩n `createProduct` enviar치 los datos del nuevo producto en el cuerpo de la solicitud y manejar치 la respuesta de la API.

Para ello usaremos fetch con los siguientes par치metros:

- method: 'POST' para indicar que es una solicitud de creaci칩n.
- headers: para especificar que el contenido es JSON.
- body: para enviar los datos del producto en formato JSON, utilizando `JSON.stringify`.

```tsx
export const createProduct = async (
  product: Omit<Product, 'id'>
): Promise<Product> => {
  const response = await fetch('https://fakestoreapi.com/products', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(product),
  });
  if (!response.ok) {
    throw new Error('Network response was not ok');
  }
  const data: Product = await response.json();
  return data;
};
```

En esta funci칩n, `Omit<Product, 'id'>` se utiliza para indicar que el objeto `product` no debe incluir la propiedad `id`, ya que esta ser치 generada por la API al crear el nuevo producto. La funci칩n env칤a la solicitud POST con los datos del producto y maneja la respuesta de manera similar a las funciones anteriores.

#### 丘뙖잺Update: updateProduct

Para actualizar un producto existente, utilizaremos el m칠todo HTTP PUT. La funci칩n `updateProduct` enviar치 los datos actualizados del producto en el cuerpo de la solicitud y manejar치 la respuesta de la API.

```tsx
export const updateProduct = async (
  id: number,
  product: Omit<Product, 'id'>
): Promise<Product> => {
  const response = await fetch(`https://fakestoreapi.com/products/${id}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(product),
  });
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('Product for update not found');
    }
    throw new Error('Network response was not ok');
  }
  const data: Product = await response.json();
  return data;
};
```

Al utilizar PUT es importante que los datos incluyan todas las propiedades del producto, ya que este m칠todo reemplaza completamente el recurso existente con los nuevos datos proporcionados. Por eso el tipo del par치metro `product` es `Omit<Product, 'id'>`, ya que el ID no debe cambiarse durante una actualizaci칩n.

Una alternativa es usar el m칠todo PATCH, que permite actualizar solo algunas propiedades del producto sin necesidad de enviar todas. En ese caso, el tipo del par치metro `product` podr칤a ser `Partial<Omit<Product, 'id'>>`, indicando que solo algunas propiedades pueden estar presentes.

```tsx
export const patchProduct = async (
  id: number,
  product: Partial<Omit<Product, 'id'>>
): Promise<Product> => {
  const response = await fetch(`https://fakestoreapi.com/products/${id}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(product),
  });
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('Product for patch not found');
    }
    throw new Error('Network response was not ok');
  }
  const data: Product = await response.json();
  return data;
};
```

#### 丘뙖잺Delete: deleteProduct

Para eliminar un producto existente, utilizaremos el m칠todo HTTP DELETE. La funci칩n `deleteProduct` enviar치 una solicitud para eliminar el producto identificado por su ID y manejar치 la respuesta de la API.

```tsx
export const deleteProduct = async (id: number): Promise<void> => {
  const response = await fetch(`https://fakestoreapi.com/products/${id}`, {
    method: 'DELETE',
  });
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('Product for delete not found');
    }
    throw new Error('Network response was not ok');
  }
};
```

Esta funci칩n env칤a una solicitud DELETE a la API para eliminar el producto con el ID especificado. Si la respuesta no es correcta, lanza un error. No es necesario procesar ning칰n dato de respuesta, ya que la eliminaci칩n no devuelve un recurso.

## Uso de las funciones as칤ncronas en un componente React

Como vimos,las llamadas a APIs pueden ocurrir en dos circunstancias principales. Lo mismo sucede con el servicio en el que hemos encapsulado dichas llamadas

1. Al montar un componente, para cargar datos iniciales.
2. En respuesta a eventos del usuario, como clics en botones o cambios en formularios

Es necesario realizar las a nuestro servicio principalmente en dos circunstancias

- dentro de un **efecto** (`useEffect`), para que se ejecuten cuando el componente se monta o cuando cambian ciertas dependencias. Esto suele suceder con los procesos de lectura de datos (Read).
- dentro de **manejadores de eventos**, para que se ejecuten en respuesta a acciones del usuario. Esto suceder치 con los procesos de creaci칩n, actualizaci칩n y eliminaci칩n de datos (Create, Update, Delete), que se desencadenan por eventos del usuario, como el `submit` de un formulario.

### Carga de datos. Estados, efectos y asincron칤a: useCallback y useMemo

Uno de los usos de los efectos es gestionar los procesos as칤ncronos, por ejemplo cuando se de estos depende la carga inicial de los datos en el componente. En estos casos, es com칰n utilizar funciones as칤ncronas dentro de los efectos para realizar llamadas a APIs o cargar datos desde una fuente externa.

Si el proceso no fuera as칤ncrono podr칤amos hacerlo sin necesidad de un efecto, d치ndole el resultado de la funci칩n `getProducts` directamente al valor inicial del estado:

```tsx
export const ProductsList: React.FC = () => {
  const initialProducts = getProducts(); // Synchronous function
  const [products, setProducts] = useState<Product[]>(initialProducts);

  return (
    <ul className="products-list">
      {products.map((item) => (
        <li key={item.id}>
          <ProductsCard item={item} />
        </li>
      ))}
    </ul>
  );
};
```

Como primera aproximaci칩n a lo que haremos en caso de asincron칤a, que ya vimos al crear el componente `ProductsList`, podemos refactorizar el c칩digo para que la obtenci칩n de los datos desde un efecto con el array de dependencias vac칤o, para que solo se ejecute una vez al montar el componente. As칤 tendr칤amos el siguiente c칩digo:

```tsx
export const ProductsList: React.FC = () => {
  const [products, setProducts] = useState<Product[]>([]);

  useEffect(() => {
    const products = getProducts();
    // eslint-disable-next-line react-hooks/set-state-in-effect
    setProducts(products);
  }, []);

  return <div>...</div>;
};
```

#### Asincron칤a en el servicio

Si necesitamos que la obtenci칩n de los datos sea as칤ncrona, por ejemplo porque los datos se obtienen desde una API que aun no est치 disponible, debemos modificar la funci칩n `getProducts` para que devuelva una promesa. Por ejemplo:

```tsx
import type { Product } from '../types/product';
import PRODUCTS from '../data/products.json';

export const getAllProductsMock = async (): Promise<Product[]> => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(PRODUCTS);
    }, 1000);
  });
};
```

En este ejemplo, la funci칩n `getAllProductsMock` simula una llamada as칤ncrona utilizando `setTimeout` para retrasar la resoluci칩n de la promesa durante 1 segundo. Despu칠s de ese tiempo, la promesa se resuelve con los datos de productos.

Alternativamente, podr칤amos usar realmente la funci칩n `fetch` para obtener los datos desde una API p칰blica de pruebas, por medio del servicio `fetchProducts` que ya hemos desarrollado.

#### 丘뙖잺Hook useProducts / 游쮺omponente ProductsList

Podr칤amos usar como ejemplo el componente `ProductsList`, que muestra una lista de productos obtenidos desde una API. Si hemos extra칤do su l칩gica en el hook `useProducts`, el c칩digo que modificaremos ser치 el del hook.

Vamos a modificar el hook (o el componente) para que utilice la funci칩n as칤ncrona `getAllProductsMock` para obtener los datos. En los siguientes apartados veremos diversas formas de manejar la asincron칤a dentro del efecto.

##### Asincron칤a en useEffect usando then

Cuando la obtenci칩n de los datos es un proceso as칤ncrono, como una llamada a una API, no podemos usar el resultado como valor inicial del estado, ya que el valor no estar치 disponible de forma inmediata. En su lugar, debemos utilizar un efecto para llamar a la funci칩n as칤ncrona y actualizar el estado cuando los datos est칠n disponibles. Por ejemplo:

```tsx
export const ProductsList: React.FC = () => {
  const [data, setData] = useState<Product[]>([]);

  useEffect(() => {
    getAllProductsMock().then((data) => setData(data));
  }, []);

  return <div>...</div>;
};
```

##### Asincron칤a en useEffect usando async/await

Si queremos usar el formato `async/await` para manejar la asincron칤a, no podemos hacer que la funci칩n pasada a `useEffect` sea `async`, ya que esto har칤a que devolviera una promesa, y `useEffect` espera que la funci칩n devuelva `void` o una funci칩n de limpieza. En su lugar, podemos definir una funci칩n as칤ncrona dentro del efecto y llamarla inmediatamente. Por ejemplo:

```tsx
import React, { useEffect, useState } from 'react';

// const getData igual que antes

export const ProductsList: React.FC = () => {
  const [data, setData] = useState<Product[]>([]);

  useEffect(() => {
    const load = async (): Promise<void> => {
      const products = await getAllProductsMock();
      setProducts(products);
    };
    load();
  }, []);

  return <div>...</div>;
};
```

La funci칩n `getAllProductsMock` se define fuera del componente, import치ndola del m칩dulo ES que la contiene, por lo que no es necesario incluirla en el array de dependencias del efecto

##### [Avanzado] Uso de una funci칩n recibida por par치metros (o props)

En los ejemplos anteriores, si la funci칩n se recibiera por par치metros/props, ser칤a detectada como una dependencia del efecto, ya que su valor puede cambiar en cada renderizado. Si tenemos correctamente configurado ESLint con el plugin de React, nos avisar치 de que debemos incluirla en el array de dependencias (React Hook useEffect has a missing dependency `getData`).

```tsx
type Props = {
  getData: () => Promise<User[]>;
};

export const UsersAsyncProps1: React.FC<Props> = ({ getData }) => {}
  const [state, setState] = useState<User[]>([]);

  useEffect(() => {
    console.log('Use Effect');
    getData().then(setState);
  }, [getData]);

  // Si no incluimos getData en el array de dependencias, ESLint nos avisar치

  return (
    <div>
      <h2>Users Async from props</h2>
      <p>State management with useState</p>
      <p>{state.length}</p>
      <ul>
        {state.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
};
```

Si queremos usar async/await debemos definir una funci칩n as칤ncrona dentro del efecto, como hemos visto antes.

```tsx

export const useProducts = (
    getData: () => Promise<Product[]>
): UseProductsReturn => {
  const [products, setProducts] = useState<Product[]>([]);

useEffect(() => {
  console.log('Use effect');

  const load = async (): Promise<void> => {
    console.log('Load');
    const products = await getData();
    setProducts(products);
  };

  load();
}, [getData]);
```

##### [Avanzado] Uso de una funci칩n externa: posibles problemas

Para entender los procesos de renderizado,. vamos a suponer que tenemos una funci칩n `load` definida fuera del efecto que llama a la funci칩n `getData` recibida por props.

```tsx
export const UsersAsyncPropsBad: React.FC<Props> = ({ getData }) => {
  const [state, setState] = useState<User[]>([]);

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const load = async (): Promise<void> => {
    const data = await getData();
    setState(data);
  };

  useEffect(() => {
    console.log('Use Effect');
    load();
  }, [load]);
  // Si no incluimos load en el array de dependencias, ESLint nos avisar치
  return <div>...</div>;
};
```

En este caso, la funci칩n `load` se define dentro del componente, por lo que se crea una nueva instancia de la funci칩n en cada renderizado. En versiones previas de React esto hacia que el efecto se ejecutara en cada renderizado, ya que `load` siempre es diferente. De ahi el avisos de ESLint.

Si lo ignoramos, vemos que el efecto se ejecuta 2 veces dentro del ciclo de vida del componente:

- se monta el componente con un array vac칤o en el estado
- se ejecuta el efecto una primera vez, inevitable cuando se monta el componente,
- se llama a la funci칩n `load`, que a su vez llama a `getData` y obtiene los datos as칤ncronamente
- se actualiza el estado con los datos obtenidos, lo que provoca un nuevo renderizado del componente
- se vuelve a ejecutar el efecto, ya que `load` es una nueva funci칩n diferente a la anterior
- de nuevo se llama a `load`, que vuelve a llamar a `getData` y obtiene los datos as칤ncronamente
- se actualiza el estado con los datos obtenidos, pero como son los mismos que antes, no provoca un nuevo renderizado del componente
- el ciclo termina aqu칤

Si React no detectar치 que el estado tiene el mismo valor, se producir칤a un bucle infinito de renderizados. En cada renderizado, al ser `load` una nueva funci칩n, se ejecutar칤a el efecto, que llamar칤a a `load`, que actualizar칤a el estado, provocando un nuevo renderizado, y as칤 sucesivamente, en un bucle infinito de renderizados.

Afortunadamente React actualmente optimiza este proceso y no vuelve a renderizar el componente si el estado no cambia.

La situaci칩n puede ser peor si el servicio devuelve datos diferentes en cada llamada, por ejemplo si obtiene los datos desde una API que cambia constantemente. Para comprobarlo podemos hacer que `getAllProductsMock` devuelva datos diferentes en cada llamada, por ejemplo creando una nueva copia del array:

```tsx
    console.log('Async Products Mock');
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve([...PRODUCTS]);
        }, 1_000);
    });
};
```

En ese caso, cada vez que se actualiza el estado con nuevos datos, se provoca un nuevo renderizado del componente, que a su vez ejecuta el efecto de nuevo, llamando a `load`, que obtiene nuevos datos, actualiza el estado, y as칤 sucesivamente, en un bucle infinito de renderizados.

##### [Avanzado] Uso de una funci칩n externa: memoizaci칩n (memoization) con useCallback

En cualquier caso, incluso si no se desencadenara un bucle infinito, la regla del linter sigue recomendando que:

- la funci칩n est칠 dentro del efecto
- utilicemos el hook `useCallback` para memoizar la funci칩n `load`, de forma que solo se cree una nueva instancia cuando alguna de sus dependencias cambie. Algo similar a esto es lo que hace internamente React 19.

```tsx
import React, { useCallback, useEffect, useState } from 'react';
import type { User } from '../../types/user';

type Props = {
  getData: () => Promise<User[]>;
};

export const UsersAsyncProps: React.FC<Props> = ({ getData }) => {
  const [state, setState] = useState<User[]>([]);

  const load = useCallback(async (): Promise<void> => {
    const data = await getData();
    setState(data);
  }, [getData]);

  useEffect(() => {
    console.log('Use Effect');
    load();
  }, [load]);

  return <div>...</div>;
};
```

En este caso vemos por consola que el efecto solo se ejecuta una vez, al montar el componente. Esto permite actualizar el estado con los nuevos dato y provoca un segundo renderizado, pero en esto no hay nada que desencadene el efecto. Hemos mejorado el rendimiento del componente evitando llamadas innecesarias el efecto y por tanto a la funci칩n `getData`.

El hook `useCallback` recibe como primer argumento la funci칩n que queremos memoizar y como segundo argumento un array de dependencias. La funci칩n solo se volver치 a crear si alguna de las dependencias cambia. En este caso, `load` solo cambiar치 si `getData` cambia.

Este patr칩n es com칰n cuando se trabaja con funciones que se reciben por props y que se utilizan dentro de efectos. Al memoizar la funci칩n con `useCallback`, evitamos que el efecto se ejecute innecesariamente en cada renderizado. Sin embargo esto tiene un coste en rendimiento, ya que `useCallback` tambi칠n tiene un coste de procesamiento. Por lo tanto, es importante evaluar si realmente es necesario memoizar la funci칩n o si el efecto puede ejecutarse en cada renderizado sin problemas.

Este hook es una particularization de `useMemo`, que permite memorizar cualquier valor resultado de una funci칩n, no solo funciones. `useCallback(fn, deps)` es equivalente a `useMemo(() => fn, deps)`. Un ejemplo de uso de `useMemo` ser칤a para memorizar una instancia de una clase, evitando que se cree una nueva instancia en cada renderizado:

```tsx
import React, { useMemo } from 'react';
import { Service } from '../../services/service';

export const ExpensiveComponent: React.FC = () => {
  const instance = useMemo(() => new Service(), []);
  // La instancia de Service solo se crea una vez

  return (
    <div>
      <h2>Expensive Component</h2>
      <p>{instance.getValue()}</p>
    </div>
  );
};
```

#### 丘뙖잺Hook useProducts: Estado de la carga y errores

Continuando con el componente `ProductsList`, y su hook `useProducts`, al cargar datos de forma as칤ncrona desde una API, es importante manejar el estado de la carga y los posibles errores que puedan ocurrir durante la obtenci칩n de los datos desde la API. Para ello, podemos a침adir dos estados adicionales: uno para indicar si los datos est치n siendo cargados (`isLoading`) y otro para almacenar cualquier error que pueda ocurrir (`error`).

```tsx
export const useProducts = (
  getData: () => Promise<Product[]>
): UseProductsReturn => {
  const [products, setProducts] = useState<Product[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  useEffect(() => {
    console.log('Use effect');

    const load = async (): Promise<void> => {
      setIsLoading(true);
      setError(null);
      try {
        const products = await getData();
        setProducts(products);
      } catch (err) {
        setError((err as Error).message);
      } finally {
        setIsLoading(false);
      }
    };

    load();
  }, [getData]);

  return { products, isLoading, error};
```

#### 游쮺omponente ProductsList: Estado de la carga y errores

En el componente `ProductsList`, podemos utilizar los estados `isLoading` y `error` para mostrar mensajes adecuados al usuario durante la carga de datos o en caso de error.

```tsx
if (showForm) {
  return <ProductForm item={activeProduct} onClose={handleCloseForm} />;
}

if (isLoading) {
  return <div>Loading products...</div>;
}

if (error) {
  return (
    <Card>
      <p className="error">Error: {error}</p>
    </Card>
  );
}

return (
  <>
    <button onClick={handleAddForm}>A침adir veh칤culo</button>
    <ul className="products-list">
      {products.map((item) => (
        <li key={item.id}>
          <ProductsCard
            item={item}
            onDelete={handleDeleteProduct}
            onEdit={handleEditForm}
          />
        </li>
      ))}
    </ul>
  </>
);
```

### Funciones as칤ncronas en manejadores de eventos

En React, es com칰n tener funciones as칤ncronas como manejadores de eventos, por ejemplo para manejar el env칤o de formularios o clics en botones que desencadenan operaciones as칤ncronas como llamadas a APIs.

Como los manejadores de eventos pueden ser funciones as칤ncronas, podemos definirlos utilizando la palabra clave `async` y utilizar `await` dentro de ellos para manejar las operaciones as칤ncronas de manera m치s legible.

En este punto, disponemos de las funciones as칤ncronas para crear, actualizar y eliminar productos en nuestro servicio, por lo que podemos utilizarlas en los manejadores de eventos correspondientes en nuestros hook `useProducts`:

- `handleAddProduct` para crear un nuevo producto.
- `handleUpdateProduct` para actualizar un producto existente.
- `handleDeleteProduct` para eliminar un producto.

Cada uno de ellos tiene que compaginar 2 procesos:

1. Llamar a la funci칩n as칤ncrona del servicio para realizar la operaci칩n (create, update, delete).
2. Actualizar de forma s칤ncrona el estado local del hook `useProducts` para reflejar los cambios en la lista de productos.

El orden y la relaci칩n entre estos procesos depende de la estrategia adoptada.

- Estrategia optimista: actualizar el estado local inmediatamente, asumiendo que la operaci칩n en el servidor tendr치 칠xito. Si la operaci칩n falla, revertir los cambios en el estado local.
- Estrategia conservadora: esperar a que la operaci칩n en el servidor tenga 칠xito antes de actualizar el estado local. Si la operaci칩n falla, no se realizan cambios en el estado local.

Veamos la 칰ltima estrategia en los manejadores de eventos del hook `useProducts`:

```tsx


#### 游쮺omponente ProductForm

Por ejemplo, podemos tener un formulario que env칤a datos a una API para poder crear un nuevo producto::

```tsx
export const ProductForm: React.FC = () => {
  const [name, setName] = useState('');
  const [price, setPrice] = useState(0);

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    try {
      const newProduct = { name, price };
      const createdProduct = await createProduct(newProduct);
      console.log('Product created:', createdProduct);
      // Aqu칤 podr칤amos actualizar el estado o redirigir al usuario
    } catch (error) {
      console.error('Error creating product:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Product Name"
      />
      <input
        type="number"
        value={price}
        onChange={(e) => setPrice(Number(e.target.value))}
        placeholder="Product Price"
      />
      <button type="submit">Create Product</button>
    </form>
  );
};
```

#### 游쮺omponente ProductCard: botones editar y borrar

## Autenticaci칩n
