# Asincron칤a y consumo de APIs

- [Asincron칤a y consumo de APIs](#asincron칤a-y-consumo-de-apis)
  - [Consumo de APIs con Fetch. CRUD](#consumo-de-apis-con-fetch-crud)
    - [API Rest](#api-rest)
      - [游깷API de pruebas (Mock API)](#api-de-pruebas-mock-api)
        - [.env](#env)
    - [丘뙖잺Servicio fetchProducts](#勇끕ervicio-fetchproducts)
      - [丘뙖잺Read: getAllProducts y getProductsById](#勇read-getallproducts-y-getproductsbyid)
      - [丘뙖잺Create: createProduct](#勇끆reate-createproduct)
      - [丘뙖잺Update: updateProduct](#勇끗pdate-updateproduct)
      - [丘뙖잺Delete: deleteProduct](#勇끇elete-deleteproduct)
  - [Uso de las funciones as칤ncronas en un componente React](#uso-de-las-funciones-as칤ncronas-en-un-componente-react)
    - [Carga de datos. Estados, efectos y asincron칤a: useCallback y useMemo](#carga-de-datos-estados-efectos-y-asincron칤a-usecallback-y-usememo)
      - [Asincron칤a en el servicio](#asincron칤a-en-el-servicio)
      - [丘뙖잺Hook useProducts / 游쮺omponente ProductsList](#勇끋ook-useproducts--componente-productslist)
        - [Asincron칤a en useEffect usando then](#asincron칤a-en-useeffect-usando-then)
        - [Asincron칤a en useEffect usando async/await](#asincron칤a-en-useeffect-usando-asyncawait)
        - [\[Avanzado\] Uso de una funci칩n recibida por par치metros (o props)](#avanzado-uso-de-una-funci칩n-recibida-por-par치metros-o-props)
        - [\[Avanzado\] Uso de una funci칩n externa: posibles problemas](#avanzado-uso-de-una-funci칩n-externa-posibles-problemas)
        - [\[Avanzado\] Uso de una funci칩n externa: memoizaci칩n (memoization) con useCallback](#avanzado-uso-de-una-funci칩n-externa-memoizaci칩n-memoization-con-usecallback)
      - [丘뙖잺Hook useProducts: Estado de la carga y errores](#勇끋ook-useproducts-estado-de-la-carga-y-errores)
      - [游쮺omponente ProductsList: Estado de la carga y errores](#componente-productslist-estado-de-la-carga-y-errores)
    - [Funciones as칤ncronas en manejadores de eventos](#funciones-as칤ncronas-en-manejadores-de-eventos)
      - [丘뙖잺Hook useProducts (v.3)](#勇끋ook-useproducts-v3)
      - [游쮺omponente ProductList (v.3)](#componente-productlist-v3)
  - [Autenticaci칩n](#autenticaci칩n)
    - [API con autenticaci칩n](#api-con-autenticaci칩n)
    - [Registro](#registro)
      - [丘뙖잺Hook useAuth: m칠todo register](#勇끋ook-useauth-m칠todo-register)
      - [游쮺omponente RegisterForm](#componente-registerform)
    - [Login](#login)
      - [丘뙖잺Hook useAuth: m칠todo login](#勇끋ook-useauth-m칠todo-login)
      - [游쮺omponente LoginForm](#componente-loginform)
    - [JWT: JSON Web Token](#jwt-json-web-token)
      - [丘뙖잺Hook useAuth: m칠todo getUserFromStorage](#勇끋ook-useauth-m칠todo-getuserfromstorage)
    - [游쮺omponente UserLogged](#componente-userlogged)
    - [游쮺omponente UserManager](#componente-usermanager)
    - [Rutas protegidas en el Front](#rutas-protegidas-en-el-front)
    - [Acceso a rutas protegidas del API](#acceso-a-rutas-protegidas-del-api)
  - [Api de Context: Inyecci칩n de dependencias en React](#api-de-context-inyecci칩n-de-dependencias-en-react)
    - [Contextos de React, Hooks y servicios](#contextos-de-react-hooks-y-servicios)
      - [游 Creaci칩n del contexto y del proveedor](#-creaci칩n-del-contexto-y-del-proveedor)
    - [Acceso al contexto](#acceso-al-contexto)
    - [Contexto din치mico](#contexto-din치mico)
      - [游 Theme \& Language Context](#-theme--language-context)
    - [Contexto din치mico y custom Hooks](#contexto-din치mico-y-custom-hooks)
      - [游 User Context](#-user-context)
    - [Contexto en React19. El API `use`](#contexto-en-react19-el-api-use)

## Consumo de APIs con Fetch. CRUD

Para consumir APIs en React, podemos utilizar la funci칩n `fetch` nativa de JavaScript o librer칤as como Axios.

En cualquiera de los casos el proceso es as칤ncrono, por lo que obtendremos una promesa que resolveremos para obtener los datos. LA gesti칩n de la promesa puede hacerse con `then` o con `async/await`, y siempre es importante manejar los posibles errores que puedan ocurrir durante la llamada a la API.

En React, las llamadas a APIs pueden ocurrir en dos circunstancias principales:

1. Al montar un componente, para cargar datos iniciales.
2. En respuesta a eventos del usuario, como clics en botones o cambios en formularios

Es necesario realizar las llamadas a APIs

- dentro de un efecto (`useEffect`), para que se ejecuten cuando el componente se monta o cuando cambian ciertas dependencias.
- dentro de manejadores de eventos, para que se ejecuten en respuesta a acciones del usuario.

### API Rest

Por otro lado debemos recordar que tanto `fetch` como Axios utilizan el **protocolo HTTP** para comunicarse con las APIs, por lo que es importante entender los conceptos b치sicos de HTTP, como los m칠todos (GET, POST, PUT, DELETE), los c칩digos de estado (200, 404, 500), y los encabezados (headers).

Por otro lado, muchas APIs siguen el estilo arquitect칩nico REST (Representational State Transfer), que define un conjunto de convenciones para dise침ar APIs web. En una **API REST**, los recursos (como usuarios, productos, etc.) se representan mediante URLs y se manipulan utilizando los m칠todos HTTP.

#### 游깷API de pruebas (Mock API)

Para practicar el consumo de APIs, podemos utilizar una API p칰blica de pruebas que proporciona datos de productos falsos en formato JSON y permite realizar operaciones CRUD (Create, Read, Update, Delete) sobre ellos. Ejemplos de estas APIS son:

- [Fake Store API](https://fakestoreapi.com/)
- [JSONPlaceholder](https://jsonplaceholder.typicode.com/)
- [DummyJSON](https://dummyjson.com/)

Otra opci칩n es hacer una instalaci칩n local de una API de pruebas utilizando herramientas como

- [json-server](https://github.com/typicode/json-server).
- [sparest](https://github.com/kasappeal/sparrest.js), basada en la anterior, con funcionalidades de autenticaci칩n y desarrollada por Alberto Casero, coordinador del Bootcamp de Desarrollo Web de Desarrollo Web de KeepCoding.

##### .env

La definici칩n de las urls de acceso suele hacerse en el fichero `.env`, junto con valores sensibles que no deban incluirse en el repositorio remoto (e.g. GitHub). Es muy importante que `.gitignore` incluya este fichero para que git lo ignore.

Vite implementa el acceso a .env con dos particularidades:

- Las variables empiezan siempre con `VITE_`
- se accede a ellas mediante `import.meta`

Nestro fichero ser칤a

```tsx
VITE_BASE_URL=http://localhost:8000
VITE_API_URL=http://localhost:8000/api
VITE_AUTH_URL=http://localhost:8000/auth
```

Y accederiamos desde el c칩digo:

```tsx
const productsUrl = import.meta.env.VITE_API_URL + '/products';
```

### 丘뙖잺Servicio fetchProducts

Vamos a crear un servicio que incluya todas los operaciones basadas en fetch para llevar a cabo las operaciones CRUD (Create, Read, Update, Delete) sobre productos.

#### 丘뙖잺Read: getAllProducts y getProductsById

Empezaremos con una funci칩n que obtenga una lista de productos desde una API p칰blica utilizando `fetch`. Este servicio ser치 una funci칩n as칤ncrona que devolver치 una promesa con los datos obtenidos.

```tsx
export const getAllProducts = async (): Promise<Product[]> => {
  const response = await fetch('https://fakestoreapi.com/products');
  if (!response.ok) {
    throw new Error('Network response was not ok');
  }
  const data: Product[] = await response.json();
  return data;
};
```

Esta funci칩n realiza una llamada a la API utilizando `fetch`, verifica si la respuesta es correcta (c칩digo de estado 200-299) y luego convierte la respuesta en formato JSON. Si la respuesta no es correcta, lanza un error que puede ser capturado por el llamador de la funci칩n.

De esta forma unificamos en un 칰nico mecanismo las posibles situaciones en que no obtenemos los datos correctamente:

- errores de red (generados por la funci칩n fetch)
- respuestas no exitosas (generados por nosotros ante c칩digos de estado HTTP fuera del rango 200-299)
- errores al parsear el JSON (generados por el m칠todo `json()`).

Para obtener un producto por su ID, podemos crear otra funci칩n similar, pero tenemos que tener en cuenta la forma de trabajar dela API. Lo correcto en el est치ndar REST es usar la ruta `/products/{id}` para obtener un producto espec칤fico y retornar un solo objeto producto, no un array con un solo elemento. Si el producto no existe, la API deber칤a retornar un c칩digo de estado 404, con o sin alg칰n dato.

Por lo tanto, la funci칩n ser칤a as칤:

```tsx
export const getProductById = async (id: Product['id']): Promise<Product> => {
  const response = await fetch(`https://fakestoreapi.com/products/${id}`);
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('Product not found');
    }
    throw new Error('Network response was not ok');
  }
  const data: Product = await response.json();
  return data;
};
```

#### 丘뙖잺Create: createProduct

Para crear un nuevo producto, utilizaremos el m칠todo HTTP POST. La funci칩n `createProduct` enviar치 los datos del nuevo producto en el cuerpo de la solicitud y manejar치 la respuesta de la API.

Para ello usaremos fetch con los siguientes par치metros:

- method: 'POST' para indicar que es una solicitud de creaci칩n.
- headers: para especificar que el contenido es JSON.
- body: para enviar los datos del producto en formato JSON, utilizando `JSON.stringify`.

```tsx
export const createProduct = async (
  product: Omit<Product, 'id'>
): Promise<Product> => {
  const response = await fetch('https://fakestoreapi.com/products', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(product),
  });
  if (!response.ok) {
    throw new Error('Network response was not ok');
  }
  const data: Product = await response.json();
  return data;
};
```

En esta funci칩n, `Omit<Product, 'id'>` se utiliza para indicar que el objeto `product` no debe incluir la propiedad `id`, ya que esta ser치 generada por la API al crear el nuevo producto. La funci칩n env칤a la solicitud POST con los datos del producto y maneja la respuesta de manera similar a las funciones anteriores.

#### 丘뙖잺Update: updateProduct

Para actualizar un producto existente, utilizaremos el m칠todo HTTP PUT. La funci칩n `updateProduct` enviar치 los datos actualizados del producto en el cuerpo de la solicitud y manejar치 la respuesta de la API.

```tsx
export const updateProduct = async (
  id: Product['id'],
  product: Omit<Product, 'id'>
): Promise<Product> => {
  const response = await fetch(`https://fakestoreapi.com/products/${id}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(product),
  });
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('Product for update not found');
    }
    throw new Error('Network response was not ok');
  }
  const data: Product = await response.json();
  return data;
};
```

Al utilizar PUT es importante que los datos incluyan todas las propiedades del producto, ya que este m칠todo reemplaza completamente el recurso existente con los nuevos datos proporcionados. Por eso el tipo del par치metro `product` es `Omit<Product, 'id'>`, ya que el ID no debe cambiarse durante una actualizaci칩n.

Una alternativa es usar el m칠todo PATCH, que permite actualizar solo algunas propiedades del producto sin necesidad de enviar todas. En ese caso, el tipo del par치metro `product` podr칤a ser `Partial<Omit<Product, 'id'>>`, indicando que solo algunas propiedades pueden estar presentes.

```tsx
export const patchProduct = async (
  id: Product['id'],
  product: Partial<Omit<Product, 'id'>>
): Promise<Product> => {
  const response = await fetch(`https://fakestoreapi.com/products/${id}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(product),
  });
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('Product for patch not found');
    }
    throw new Error('Network response was not ok');
  }
  const data: Product = await response.json();
  return data;
};
```

#### 丘뙖잺Delete: deleteProduct

Para eliminar un producto existente, utilizaremos el m칠todo HTTP DELETE. La funci칩n `deleteProduct` enviar치 una solicitud para eliminar el producto identificado por su ID y manejar치 la respuesta de la API.

```tsx
export const deleteProduct = async (id: Product['id']): Promise<void> => {
  const response = await fetch(`https://fakestoreapi.com/products/${id}`, {
    method: 'DELETE',
  });
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('Product for delete not found');
    }
    throw new Error('Network response was not ok');
  }
};
```

Esta funci칩n env칤a una solicitud DELETE a la API para eliminar el producto con el ID especificado. Si la respuesta no es correcta, lanza un error. No es necesario procesar ning칰n dato de respuesta, ya que la eliminaci칩n no devuelve un recurso.

Una vez completados todos los m칠todos, se pueden exportar por separado o todos juntos en un objeto para facilitar su importaci칩n en otros m칩dulos. Por ejemplo:

```tsx
export type ProductsApiRepo = {
  getAllProducts: () => Promise<Product[]>;
  getProductById: (id: Product['id']) => Promise<Product>;
  createProduct: (product: Omit<Product, 'id'>) => Promise<Product>;
  updateProduct: (
    id: Product['id'],
    product: Omit<Product, 'id'>
  ) => Promise<Product>;
  patchProduct: (
    id: Product['id'],
    product: Partial<Omit<Product, 'id'>>
  ) => Promise<Product>;
  deleteProduct: (id: Product['id']) => Promise<void>;
};

export default {
  getAllProducts,
  getProductById,
  createProduct,
  updateProduct,
  patchProduct,
  deleteProduct,
};
```

## Uso de las funciones as칤ncronas en un componente React

Como vimos,las llamadas a APIs pueden ocurrir en dos circunstancias principales. Lo mismo sucede con el servicio en el que hemos encapsulado dichas llamadas

1. Al montar un componente, para cargar datos iniciales.
2. En respuesta a eventos del usuario, como clics en botones o cambios en formularios

Es necesario realizar las a nuestro servicio principalmente en dos circunstancias

- dentro de un **efecto** (`useEffect`), para que se ejecuten cuando el componente se monta o cuando cambian ciertas dependencias. Esto suele suceder con los procesos de lectura de datos (Read).
- dentro de **manejadores de eventos**, para que se ejecuten en respuesta a acciones del usuario. Esto suceder치 con los procesos de creaci칩n, actualizaci칩n y eliminaci칩n de datos (Create, Update, Delete), que se desencadenan por eventos del usuario, como el `submit` de un formulario.

### Carga de datos. Estados, efectos y asincron칤a: useCallback y useMemo

Uno de los usos de los efectos es gestionar los procesos as칤ncronos, por ejemplo cuando se de estos depende la carga inicial de los datos en el componente. En estos casos, es com칰n utilizar funciones as칤ncronas dentro de los efectos para realizar llamadas a APIs o cargar datos desde una fuente externa.

Si el proceso no fuera as칤ncrono podr칤amos hacerlo sin necesidad de un efecto, d치ndole el resultado de la funci칩n `getProducts` directamente al valor inicial del estado:

```tsx
export const ProductsList: React.FC = () => {
  const initialProducts = getProducts(); // Synchronous function
  const [products, setProducts] = useState<Product[]>(initialProducts);

  return (
    <ul className="products-list">
      {products.map((item) => (
        <li key={item.id}>
          <ProductsCard item={item} />
        </li>
      ))}
    </ul>
  );
};
```

Como primera aproximaci칩n a lo que haremos en caso de asincron칤a, que ya vimos al crear el componente `ProductsList`, podemos refactorizar el c칩digo para que la obtenci칩n de los datos desde un efecto con el array de dependencias vac칤o, para que solo se ejecute una vez al montar el componente. As칤 tendr칤amos el siguiente c칩digo:

```tsx
export const ProductsList: React.FC = () => {
  const [products, setProducts] = useState<Product[]>([]);

  useEffect(() => {
    const products = getProducts();
    // eslint-disable-next-line react-hooks/set-state-in-effect
    setProducts(products);
  }, []);

  return <div>...</div>;
};
```

#### Asincron칤a en el servicio

Si necesitamos que la obtenci칩n de los datos sea as칤ncrona, por ejemplo porque los datos se obtienen desde una API que aun no est치 disponible, debemos modificar la funci칩n `getProducts` para que devuelva una promesa. Por ejemplo:

```tsx
import type { Product } from '../types/product';
import PRODUCTS from '../data/products.json';

export const getAllProductsMock = async (): Promise<Product[]> => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(PRODUCTS);
    }, 1_000);
  });
};
```

En este ejemplo, la funci칩n `getAllProductsMock` simula una llamada as칤ncrona utilizando `setTimeout` para retrasar la resoluci칩n de la promesa durante 1 segundo. Despu칠s de ese tiempo, la promesa se resuelve con los datos de productos.

Alternativamente, podr칤amos usar realmente la funci칩n `fetch` para obtener los datos desde una API p칰blica de pruebas, por medio del servicio `fetchProducts` que ya hemos desarrollado.

#### 丘뙖잺Hook useProducts / 游쮺omponente ProductsList

Podr칤amos usar como ejemplo el componente `ProductsList`, que muestra una lista de productos obtenidos desde una API. Si hemos extra칤do su l칩gica en el hook `useProducts`, el c칩digo que modificaremos ser치 el del hook.

Vamos a modificar el hook (o el componente) para que utilice la funci칩n as칤ncrona `getAllProductsMock` para obtener los datos. En los siguientes apartados veremos diversas formas de manejar la asincron칤a dentro del efecto.

##### Asincron칤a en useEffect usando then

Cuando la obtenci칩n de los datos es un proceso as칤ncrono, como una llamada a una API, no podemos usar el resultado como valor inicial del estado, ya que el valor no estar치 disponible de forma inmediata. En su lugar, debemos utilizar un efecto para llamar a la funci칩n as칤ncrona y actualizar el estado cuando los datos est칠n disponibles. Por ejemplo:

```tsx
export const ProductsList: React.FC = () => {
  const [data, setData] = useState<Product[]>([]);

  useEffect(() => {
    getAllProductsMock().then((data) => setData(data));
  }, []);

  return <div>...</div>;
};
```

##### Asincron칤a en useEffect usando async/await

Si queremos usar el formato `async/await` para manejar la asincron칤a, no podemos hacer que la funci칩n pasada a `useEffect` sea `async`, ya que esto har칤a que devolviera una promesa, y `useEffect` espera que la funci칩n devuelva `void` o una funci칩n de limpieza. En su lugar, podemos definir una funci칩n as칤ncrona dentro del efecto y llamarla inmediatamente. Por ejemplo:

```tsx
import React, { useEffect, useState } from 'react';

// const getData igual que antes

export const ProductsList: React.FC = () => {
  const [data, setData] = useState<Product[]>([]);

  useEffect(() => {
    const load = async (): Promise<void> => {
      const products = await getAllProductsMock();
      setProducts(products);
    };
    load();
  }, []);

  return <div>...</div>;
};
```

La funci칩n `getAllProductsMock` se define fuera del componente, import치ndola del m칩dulo ES que la contiene, por lo que no es necesario incluirla en el array de dependencias del efecto

##### [Avanzado] Uso de una funci칩n recibida por par치metros (o props)

En los ejemplos anteriores, si la funci칩n se recibiera por par치metros/props, ser칤a detectada como una dependencia del efecto, ya que su valor puede cambiar en cada renderizado. Si tenemos correctamente configurado ESLint con el plugin de React, nos avisar치 de que debemos incluirla en el array de dependencias (React Hook useEffect has a missing dependency `getData`).

```tsx
type Props = {
  getData: () => Promise<User[]>;
};

export const UsersAsyncProps1: React.FC<Props> = ({ getData }) => {}
  const [state, setState] = useState<User[]>([]);

  useEffect(() => {
    console.log('Use Effect');
    getData().then(setState);
  }, [getData]);

  // Si no incluimos getData en el array de dependencias, ESLint nos avisar치

  return (
    <div>
      <h2>Users Async from props</h2>
      <p>State management with useState</p>
      <p>{state.length}</p>
      <ul>
        {state.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
};
```

Si queremos usar async/await debemos definir una funci칩n as칤ncrona dentro del efecto, como hemos visto antes.

```tsx

export const useProducts = (
    getData: () => Promise<Product[]>
): UseProductsReturn => {
  const [products, setProducts] = useState<Product[]>([]);

useEffect(() => {
  console.log('Use effect');

  const load = async (): Promise<void> => {
    console.log('Load');
    const products = await getData();
    setProducts(products);
  };

  load();
}, [getData]);
```

##### [Avanzado] Uso de una funci칩n externa: posibles problemas

Para entender los procesos de renderizado,. vamos a suponer que tenemos una funci칩n `load` definida fuera del efecto que llama a la funci칩n `getData` recibida por props.

```tsx
export const UsersAsyncPropsBad: React.FC<Props> = ({ getData }) => {
  const [state, setState] = useState<User[]>([]);

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const load = async (): Promise<void> => {
    const data = await getData();
    setState(data);
  };

  useEffect(() => {
    console.log('Use Effect');
    load();
  }, [load]);
  // Si no incluimos load en el array de dependencias, ESLint nos avisar치
  return <div>...</div>;
};
```

En este caso, la funci칩n `load` se define dentro del componente, por lo que se crea una nueva instancia de la funci칩n en cada renderizado. En versiones previas de React esto hacia que el efecto se ejecutara en cada renderizado, ya que `load` siempre es diferente. De ahi el avisos de ESLint.

Si lo ignoramos, vemos que el efecto se ejecuta 2 veces dentro del ciclo de vida del componente:

- se monta el componente con un array vac칤o en el estado
- se ejecuta el efecto una primera vez, inevitable cuando se monta el componente,
- se llama a la funci칩n `load`, que a su vez llama a `getData` y obtiene los datos as칤ncronamente
- se actualiza el estado con los datos obtenidos, lo que provoca un nuevo renderizado del componente
- se vuelve a ejecutar el efecto, ya que `load` es una nueva funci칩n diferente a la anterior
- de nuevo se llama a `load`, que vuelve a llamar a `getData` y obtiene los datos as칤ncronamente
- se actualiza el estado con los datos obtenidos, pero como son los mismos que antes, no provoca un nuevo renderizado del componente
- el ciclo termina aqu칤

Si React no detectar치 que el estado tiene el mismo valor, se producir칤a un bucle infinito de renderizados. En cada renderizado, al ser `load` una nueva funci칩n, se ejecutar칤a el efecto, que llamar칤a a `load`, que actualizar칤a el estado, provocando un nuevo renderizado, y as칤 sucesivamente, en un bucle infinito de renderizados.

Afortunadamente React actualmente optimiza este proceso y no vuelve a renderizar el componente si el estado no cambia.

La situaci칩n puede ser peor si el servicio devuelve datos diferentes en cada llamada, por ejemplo si obtiene los datos desde una API que cambia constantemente. Para comprobarlo podemos hacer que `getAllProductsMock` devuelva datos diferentes en cada llamada, por ejemplo creando una nueva copia del array:

```tsx
    console.log('Async Products Mock');
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve([...PRODUCTS]);
        }, 1_000);
    });
};
```

En ese caso, cada vez que se actualiza el estado con nuevos datos, se provoca un nuevo renderizado del componente, que a su vez ejecuta el efecto de nuevo, llamando a `load`, que obtiene nuevos datos, actualiza el estado, y as칤 sucesivamente, en un bucle infinito de renderizados.

##### [Avanzado] Uso de una funci칩n externa: memoizaci칩n (memoization) con useCallback

En cualquier caso, incluso si no se desencadenara un bucle infinito, la regla del linter sigue recomendando que:

- la funci칩n est칠 dentro del efecto
- utilicemos el hook `useCallback` para memoizar la funci칩n `load`, de forma que solo se cree una nueva instancia cuando alguna de sus dependencias cambie. Algo similar a esto es lo que hace internamente React 19.

```tsx
import React, { useCallback, useEffect, useState } from 'react';
import type { User } from '../../types/user';

type Props = {
  getData: () => Promise<User[]>;
};

export const UsersAsyncProps: React.FC<Props> = ({ getData }) => {
  const [state, setState] = useState<User[]>([]);

  const load = useCallback(async (): Promise<void> => {
    const data = await getData();
    setState(data);
  }, [getData]);

  useEffect(() => {
    console.log('Use Effect');
    load();
  }, [load]);

  return <div>...</div>;
};
```

En este caso vemos por consola que el efecto solo se ejecuta una vez, al montar el componente. Esto permite actualizar el estado con los nuevos dato y provoca un segundo renderizado, pero en esto no hay nada que desencadene el efecto. Hemos mejorado el rendimiento del componente evitando llamadas innecesarias el efecto y por tanto a la funci칩n `getData`.

El hook `useCallback` recibe como primer argumento la funci칩n que queremos memoizar y como segundo argumento un array de dependencias. La funci칩n solo se volver치 a crear si alguna de las dependencias cambia. En este caso, `load` solo cambiar치 si `getData` cambia.

Este patr칩n es com칰n cuando se trabaja con funciones que se reciben por props y que se utilizan dentro de efectos. Al memoizar la funci칩n con `useCallback`, evitamos que el efecto se ejecute innecesariamente en cada renderizado. Sin embargo esto tiene un coste en rendimiento, ya que `useCallback` tambi칠n tiene un coste de procesamiento. Por lo tanto, es importante evaluar si realmente es necesario memoizar la funci칩n o si el efecto puede ejecutarse en cada renderizado sin problemas.

Este hook es una particularization de `useMemo`, que permite memorizar cualquier valor resultado de una funci칩n, no solo funciones. `useCallback(fn, deps)` es equivalente a `useMemo(() => fn, deps)`. Un ejemplo de uso de `useMemo` ser칤a para memorizar una instancia de una clase, evitando que se cree una nueva instancia en cada renderizado:

```tsx
import React, { useMemo } from 'react';
import { Service } from '../../services/service';

export const ExpensiveComponent: React.FC = () => {
  const instance = useMemo(() => new Service(), []);
  // La instancia de Service solo se crea una vez

  return (
    <div>
      <h2>Expensive Component</h2>
      <p>{instance.getValue()}</p>
    </div>
  );
};
```

#### 丘뙖잺Hook useProducts: Estado de la carga y errores

Continuando con el componente `ProductsList`, y su hook `useProducts`, al cargar datos de forma as칤ncrona desde una API, es importante manejar el estado de la carga y los posibles errores que puedan ocurrir durante la obtenci칩n de los datos desde la API. Para ello, podemos a침adir dos estados adicionales: uno para indicar si los datos est치n siendo cargados (`isLoading`) y otro para almacenar cualquier error que pueda ocurrir (`error`).

```tsx
export const useProducts = (
  getData: () => Promise<Product[]>
): UseProductsReturn => {
  const [products, setProducts] = useState<Product[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  useEffect(() => {
    console.log('Use effect');

    const load = async (): Promise<void> => {
      setIsLoading(true);
      setError(null);
      try {
        const products = await getData();
        setProducts(products);
      } catch (err) {
        setError((err as Error).message);
      } finally {
        setIsLoading(false);
      }
    };

    load();
  }, [getData]);

  return { products, isLoading, error};
```

#### 游쮺omponente ProductsList: Estado de la carga y errores

En el componente `ProductsList`, podemos utilizar los estados `isLoading` y `error` para mostrar mensajes adecuados al usuario durante la carga de datos o en caso de error.

```tsx
if (showForm) {
  return <ProductForm item={activeProduct} onClose={handleCloseForm} />;
}

if (isLoading) {
  return <div>Loading products...</div>;
}

if (error) {
  return (
    <Card>
      <p className="error">Error: {error}</p>
    </Card>
  );
}

return (
  <>
    <button onClick={handleAddForm}>A침adir veh칤culo</button>
    <ul className="products-list">
      {products.map((item) => (
        <li key={item.id}>
          <ProductsCard
            item={item}
            onDelete={handleDeleteProduct}
            onEdit={handleEditForm}
          />
        </li>
      ))}
    </ul>
  </>
);
```

### Funciones as칤ncronas en manejadores de eventos

En React, es com칰n tener funciones as칤ncronas como manejadores de eventos, por ejemplo para manejar el env칤o de formularios o clics en botones que desencadenan operaciones as칤ncronas como llamadas a APIs.

Como los manejadores de eventos pueden ser funciones as칤ncronas, podemos definirlos utilizando la palabra clave `async` y utilizar `await` dentro de ellos para manejar las operaciones as칤ncronas de manera m치s legible.

En este punto, disponemos de las funciones as칤ncronas para crear, actualizar y eliminar productos en nuestro servicio, por lo que podemos utilizarlas en los manejadores de eventos correspondientes en nuestros hook `useProducts`:

- `handleAddProduct` para crear un nuevo producto.
- `handleUpdateProduct` para actualizar un producto existente.
- `handleDeleteProduct` para eliminar un producto.

Cada uno de ellos tiene que compaginar 2 procesos:

1. Llamar a la funci칩n as칤ncrona del servicio para realizar la operaci칩n (create, update, delete).
2. Actualizar de forma s칤ncrona el estado local del hook `useProducts` para reflejar los cambios en la lista de productos.

El orden y la relaci칩n entre estos procesos depende de la estrategia adoptada.

- Estrategia optimista: actualizar el estado local inmediatamente, asumiendo que la operaci칩n en el servidor tendr치 칠xito. Si la operaci칩n falla, revertir los cambios en el estado local.
- Estrategia conservadora: esperar a que la operaci칩n en el servidor tenga 칠xito antes de actualizar el estado local. Si la operaci칩n falla, no se realizan cambios en el estado local.

#### 丘뙖잺Hook useProducts (v.3)

Veamos la estrategia on optimista en los manejadores de eventos del hook `useProducts`:

```tsx
const handleAddProduct = (newProduct: Omit<Product, 'id'>): void => {
  // Parte as칤ncrona: llamada al API (apiRepo)
  apiRepo.createProduct(newProduct).then((createdProduct) => {
    // Parte s칤ncrona: actualizaci칩n del estado local
    setProducts((prevProducts) => [createdProduct, ...prevProducts]);
  });
};

const handleUpdateProduct = (updatedProduct: Product): void => {
  apiRepo
    .updateProduct(updatedProduct.id, updatedProduct)
    .then((updatedProductFromApi) => {
      setProducts((prevProducts) =>
        prevProducts.map((product) =>
          product.id === updatedProductFromApi.id
            ? updatedProductFromApi
            : product
        )
      );
    });
};
const handleDeleteProduct = (id: Product['id']): void => {
  apiRepo.deleteProduct(id).then(() => {
    setProducts((prevProducts) =>
      prevProducts.filter((product) => product.id !== id)
    );
  });
};
```

#### 游쮺omponente ProductList (v.3)

Obtenemos el estado y sus manejadores del nuevo hook `useProducts`, pasandole la versi칩n real del repositorio, y los usamos en el componente `ProductsList`:

```tsx
import productsApiRepo from '@features/products/services/products-api-repo';

// Resto del c칩digo del componente...

const {
  products,
  isLoading,
  error,
  handleAddProduct,
  handleUpdateProduct,
  handleDeleteProduct,
} = useProducts(productsApiRepo);
```

En el cierre del formulario, si se trasta de a침adir un elemento, nos eliminamos el id (que vendr치 vac칤o desde el formulario), para respetar el tipo `Omit<Product, 'id'>` esperado por el servicio:

```tsx
const handleCloseForm = (product: Product | null): void => {
  setShowForm('');
  setActiveProduct(null);
  if (product) {
    if (showForm === 'edit') {
      handleUpdateProduct(product);
    } else if (showForm === 'add') {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { id, ...dtoProduct } = product;
      handleAddProduct(dtoProduct);
    }
  }
};
```

## Autenticaci칩n

Desde el punto de vista del front los procesos relacionados con la autenticaci칩n de usuarios son los siguientes:

- Registro (sign up)
  - se crea una nueva cuenta de usuario.
  - petici칩n POST a la API /auth/register con los datos del usuario.
- Login (sign in)
  - se autentica un usuario existente.
  - petici칩n POST a la API /auth/login con las credenciales del usuario.
  - recepci칩n de un token de autenticaci칩n (JWT en nuestro caso).
  - almacenamiento del token en el almacenamiento local (localStorage o sessionStorage).
- Logout (sign out)
  - se cierra la sesi칩n del usuario.
  - eliminaci칩n del token de autenticaci칩n del almacenamiento local
- Protecci칩n de rutas y componentes
  - se restringe el acceso a ciertas rutas o componentes solo a usuarios autenticados.
  - verificaci칩n de la existencia y validez del token de autenticaci칩n.
- Uso de tokens en las llamadas a APIs
  - inclusi칩n del token de autenticaci칩n en los encabezados (headers) de las solicitudes a la API.
- Gesti칩n de tokens (renovaci칩n, expiraci칩n)
  - se renueva el token antes de que expire, si la API lo permite.
  - se maneja la expiraci칩n del token y se redirige al usuario al login si es necesario.

### API con autenticaci칩n

Utilizaremos una API local de pruebas que ya hemos mencionado, [sparest](https://github.com/kasappeal/sparrest.js), basada en json-server, con funcionalidades de autenticaci칩n y desarrollada por Alberto Casero, coordinador del Bootcamp de Desarrollo Web de Desarrollo Web de KeepCoding.

- Permite **registrar** usuarios con los campos username y password, junto con cualquier otro campo. Al crear un registro devuelve el objeto con los datos, incluyendo un id num칠rico, y excluyendo la password, que almacena encriptada.
- Permite hacer **login** proporcionando nombre de usuario y contrase침a. Devuelve un **token JWT** cuyo payload incluye el username y el userId
- Permite obtener la informaci칩n del usuario logado, enviando el token al endpoint /auth/me
- Permite proteger las operaciones en los endpoint /api distinguiendo lectura (R) y modificaci칩n (CUD)

Adaptaremos nuestros tipos al funcionamiento del API

```ts
// DTO para hacer un registro
export type RegisterDTO = {
  username: string;
  password: string;
  // El resto es opcional,
  // Lo mantenemos porque ya estaba en el formulario de registro
  email: string;
  isOkConditions: boolean;
  turn: string;
  course: string;
};

// DTO para hacer un login
export type LoginDTO = {
  username: string;
  password: string;
  // El resto es opcional y  no se usa para nada,
  // Lo mantenemos porque ya estaba en el formulario de registro
  rememberMe: boolean;
};

// Respuesta del Login
export type UserLogin = {
  id: number;
  username: string;
  // El token puede guardarse al margen del User
  token: string;
};

export type User = {
  id: number;
  username: string;
  email: string;
  isOkConditions: boolean;
  turn: string;
  course: string;
};
```

### Registro

En el formulario que ya ten칤amos, podr칤amos a침adir el proceso de registro en el submit. En lugar de hacerlo directamente creamos un custom hook `useAuth`.

#### 丘뙖잺Hook useAuth: m칠todo register

El custom hook `useAuth` implementar치 una funci칩n register y la exportar치 com parte de un objeto.

El proceso de registro de cara al back es una petici칩n HTTP

- con el m칠todo POST a la url definida en la API (/auth/register)
- con los datos a registrar en el body, serializados com string
- con una cabecera (header) que indica que estamos usando JSON

```tsx
const AUTH_API = 'http://localhost:8000/auth';

type UseUserType = {
  register(userData: RegisterDTO): Promise<User>;
};

export const useAuth = (): UseUserType => {
  const register = (userData: RegisterDTO): Promise<User> => {
    return fetch(AUTH_API + '/register', {
      method: 'POST',
      body: JSON.stringify(userData),
      headers: {
        'content-type': 'application/json',
      },
    })
      .then((response) => {
        if (!response.ok) {
          throw new Error('Login incorrecto');
        }
        return response.json();
      })
      .then((data: User & { password?: string }) => {
        delete data.password;
        return data;
      });
  };

  return { register, login, getUserFromStorage };
};
```

De la respuesta eliminamos la password para ajustarnos al tipo User, devolviendo el resultado en forma de promesa

#### 游쮺omponente RegisterForm

Utilizamos el formulario creado en clases anteriores como ejemplo de formulario no controlado.

Para ser m치s realistas, podemos cambiar los controles turno y curso por algo m치s acorde con nuestro proyecto actual, como tipo de cuenta (b치sica, pro, premium...), forma de pago preferida....

Tambi칠n podemos convertir el formulario al modo controlado por React.

Todo esto no influir치 en lo que ahora estamos aprendiendo

A침adimos el m칠todo que nos proporciona el custom hook y lo ejecutamos en el submit del formulario.

```tsx
type Props = {
  onSelectForm: (state: 'loginPending' | 'registerPending') => void;
};

export const RegisterForm: React.FC<Props> = ({ onSelectForm }) => {
  const { register } = useAuth();

  const handleSubmit = (ev: React.FormEvent<HTMLFormElement>): void => {
    ev.preventDefault();
    const form = ev.currentTarget;
    const formData = new FormData(form);
    const result = generateData(formData, userDataInitial);

    register(result).then((response) => {
      console.log(response);
      onSelectForm('loginPending');
    });
  };

  return {
    /* JSX */
  };
};
```

Es buena pr치ctica que el final del registro, aunque sea correcto no haga Login autom치tico.
Es preferible que el usuario reci칠n registrado tenga que hacer manualmente el acceso. Opcionalmente puede ser necesario que antes confirme el registro, por ejemplo respondiendo a un correo

El componente recibe por props una funci칩n (`onSelectForm`) y la ejecuta en el submit. Veremos m치s adelante su significado en relaci칩n con el estado en el componente padre.

### Login

Como en el caso del registro, incluiremos la l칩gica en el hook `useAuth` y lo utilizaremos desde el formulario de login, que ya tenemos

#### 丘뙖잺Hook useAuth: m칠todo login

El proceso de Login no crea nada en el API, pero como se necesita enviar datos sensibles, suele codificarse en el backend utilizando el m칠todo POST, que permite incluir los datos en el body para que sean encriptados por el protocolo https. As칤 lo hace nuestro backend, que nos ofrece un endpoint `auth/login` para el m칠todo POST.

```tsx
const AUTH_API = 'http://localhost:8000/auth';
//process.env.AUTH_URL ||

type UseUserType = {
  register(userData: RegisterDTO): Promise<User>;
  login: (loginData: LoginDTO) => Promise<void>;
  getUserFromStorage: () => UserLogin | null;
};

type AccessToken = string;

export const useAuth = (): UseUserType => {
  const login = (loginData: LoginDTO): Promise<void> => {
    return fetch(AUTH_API + '/login', {
      method: 'POST',
      body: JSON.stringify(loginData),
      headers: {
        'content-type': 'application/json',
      },
    })
      .then((response) => {
        if (!response.ok) {
          throw new Error('Login incorrecto');
        }
        return response.json();
      })
      .then(({ accessToken }: { accessToken: AccessToken }) => {
        // Guardamos el token en localStorage
        // Mas adelante puede ser en el contexto
        localStorage.setItem('products-token', accessToken);
      });
  };
  return { register, login };
};
```

Si el login es correcto recibimos un **token JWT**. Es un string que guardaremos en **localStorage**. En unas l칤neas hablaremos de este token, pero antes terminaremos lo referido al proceso de Login

#### 游쮺omponente LoginForm

De nuevo utilizamos el formulario creado en clases anteriores, esta vez como ejemplo de formulario controlado.

A침adimos el m칠todo que nos proporciona el custom hook y lo ejecutamos en el submit del formulario.

```tsx
type Props = {
  onSelectForm: (state: 'loginPending' | 'registerPending') => void;
  onLogin: () => void;
};

export const LoginForm: React.FC<Props> = ({ onSelectForm, onLogin }) => {
  const [userData, setUserData] = useState<LoginDTO>(initialState);
  const { login } = useAuth();

  const handleGoTo = (): void => {
    onSelectForm('registerPending');
  };

  const handleSubmit = (e: React.FormEvent): void => {
    e.preventDefault();
    console.log('Formulario enviado:', userData);
    setUserData(initialState);

    const loginData = {
      ...userData,
      username: userData.username.toLowerCase(),
    };

    login(loginData).then(() => {
      onLogin();
    });
  };

  return {
    /* JSX */
  };
};
```

Como el m칠todo del hook guarda el token en localStorage, por ahora no es necesario hacer nada en caso de respuesta correcta. Nos limitamos a un console.log.

El componente recibe por props las funciones `onSelectForm` y `onLogin`.

Como el m칠todo del hook guarda el token en localStorage, en caso de respuesta correcta en el submit nos limitamos a ejecutar `onLogin`. En el handle del bot칩n cancelar ejecutamos `onSelectForm`. Veremos m치s adelante el significado de estas funciones en relaci칩n con el estado en el componente padre.

### JWT: JSON Web Token

**JSON Web Token** [JWT](https://www.jwt.io/introduction#what-is-json-web-token-structure) es un est치ndar abierto (RFC 7519) que define una forma compacta y aut칩noma de transmitir informaci칩n de forma segura entre partes como un objeto JSON.

En el proceso de autenticaci칩n, si todo es correcto, el backend crea un token que incluye

- informaci칩n sobre el usuario (PayLoad)
- use firma codificada de acuerdo con alg칰n algoritmo (por defecto SHA256) que m치s adelante permitir치 comprobar la validez del token.

Desde el punto de vista del front nos interesan dos operaciones

- podemos extraer del token la informaci칩n incluida en el payload
- podemos incluir el token eln las cabeceras de las peticiones HTTP para que sea validado en el back, y conseguir as칤 acceso a endpoints protegidos

Para el primero de estos procesos podemos instalar una librer칤a, [jwt-decode](https://www.npmjs.com/package/jwt-decode)

```shell
npm i jwt-decode
```

El proceso de decodificaci칩n lo incluiremos en un nuevo m칠todo de nuestro hook `useAuth`

#### 丘뙖잺Hook useAuth: m칠todo getUserFromStorage

Con el API que estamos utilizando, la informaci칩n incluida en el token corresponde al siguiente tipo

```tsx
type JwtPayload = {
  exp: number;
  iat: number;
  userId: number;
  username: string;
};
```

A침adimos un m칠todo al hook que lea el token de localStorage, lo decodifique y nos devuelva la informaci칩n correspondiente a nuestro tipo de dato UserLogin

```tsx
export type UserLogin = {
  id: number;
  username: string;
  token: string;
};
```

El m칠todo `getUserFromStorage` del hook utiliza la funci칩n jwtDecode de la librer칤a jwt-decode que hemos instalado

```tsx
const AUTH_API = 'http://localhost:8000/auth';

type UseUserType = {
  register(userData: RegisterDTO): Promise<User>;
  login: (loginData: LoginDTO) => Promise<void>;
  getUserFromStorage: () => UserLogin | null;
};

export const useAuth = (): UseUserType => {
  const getUserFromStorage = useCallback((): UserLogin | null => {
    const accessToken = localStorage.getItem('products-token');
    if (!accessToken) return null;
    const { userId, username } = jwtDecode<JwtPayload>(accessToken);
    const user: UserLogin = {
      id: userId,
      username: username,
      token: accessToken,
    };
    return user;
  }, []);

  return { register, login, getUserFromStorage };
};
```

### 游쮺omponente UserLogged

Cuando el usuario est치 logado, debemos mostrarle la opci칩n de logout, y opcionalmente alguna informaci칩n sobre 칠l

```tsx
type Props = {
  user: UserLogin;
  onLogout: () => void;
};
export const UserLogged: React.FC<Props> = ({ user, onLogout }) => {
  const handleLogout = (): void => {
    onLogout();
  };

  return (
    <Card title={`User - ${user?.id}`}>
      <p>Hola {user?.username}</p>
      <button onClick={handleLogout}>Logout</button>
    </Card>
  );
};
```

El handle del bot칩n logout ejecuta la prop `onLogout` de la que hablaremos a continuaci칩n

### 游쮺omponente UserManager

Los componentes RegisterForm, LoginForm y UserLogged tienen que compartir el estado en relaci칩n con los procesos de login y registro. Una manera de hacerlo que ya conocemos es el **Lifting State Up**:

- mover el estado a un componente padre com칰n y pasar el estado y las funciones para actualizarlo como props a los componentes hijos que lo necesiten.

En nuestro caso crearemos el componente UserManager Para este fin, definiendo dos estados:

- userState: 'loginPending' | 'logged' | 'registerPending'
- user: UserLogin | null

El primero permitir치 mostrar login o registro
El segundo guarda la informaci칩n si hay un usuario logado, y permite mostrarle el componente que incluye el bot칩n de logout

El renderizado ser칤a el siguiente:

```tsx
return (
  <>
    {userState === 'loginPending' && (
      <LoginForm onSelectForm={handleSelectForm} onLogin={handleLogin} />
    )}
    {userState === 'registerPending' && (
      <RegisterForm onSelectForm={handleSelectForm} />
    )}
    {user != null && <UserLogged user={user} onLogout={handleLogout} />}
  </>
);
```

Los componente reciben por props los manejadores de estado, com vimos al hablar de ellos. Su c칩digo quedar칤a como sigue:

```tsx
const handleLogout = (): void => {
  setUserState('loginPending');
  setUser(null);
  localStorage.removeItem('products-token');
};

const handleLogin = (): void => {
  const user = getUserFromStorage();
  setUser(user);
  setUserState('logged');
  console.log('Logged', user);
};

const handleSelectForm = (
  state: 'loginPending' | 'registerPending'
  // Extract<UserStates, 'logged'>
): void => {
  setUserState(state);
};
```

Finalmente, cuando accedemos a la p치gina, necesitamos comprobar si hay un usuario logado, y actualizar los estados en consecuencia, para lo que necesitamos un efecto utilizando la funci칩n que definimos en el hook useAuth para leer los datos de localStorage

```tsx
const { getUserFromStorage } = useAuth();

useEffect(() => {
  const checkInitialState = (): void => {
    const user = getUserFromStorage();
    if (user) {
      setUser(user);
      setUserState('logged');
    }
  };
  checkInitialState();
}, [getUserFromStorage]);
```

La funci칩n es una dependencia del efecto, lo que provoca un bucle infinito, que debemos evitar a침adiendo un useCallback al crearla en el hook.

### Rutas protegidas en el Front

En el roputer debemos evitar que un usuario no logado acceda a rutas que consideramos protegidas

- por su naturaleza
- porque depende dee informaci칩n del back a la que solo pueden acceder usuarios logados

Utilizando el modo data de Rect-Router, tan solo necesitamos definir un loader en la ruta que compruebe si estamos logados o no

```tsx
const protectedRoute = (): Response | undefined => {
    const token = localStorage.getItem('products-token');
    if (!token) {
        return redirect('/');
    }
};

///

  {
    path: '/products',
    loader: protectedRoute,
    // ...
  }
```

La funci칩n comprueba si existe un token en localStorage; si no es as칤 nos redirige a la Home.

En cada ruta que queramos proteger, a침adimos el loader

### Acceso a rutas protegidas del API

En los APIS REST que utilizan JWT, el modo est치ndar de identificarnos como usuarios autorizados es a침adir a la petici칩n HTTP una cabecera `"Authentication"`, pas치ndole como valor un string `"Bearer \<token>"`

- **Bearer** indica el est치ndar que estamos utilizado, y despu칠s de un espacio se a침ade el token-
- el backen lo validara y si es correcto procesar치 nuestra petici칩n HTTP y nos enviar치 los resultados.

La forma m치s simple de hacerlo es a침adir al cabecear a cada una de las peticiones generadas en nuestro servicio que act칰a como **repositorio**.

```tsx
const createAuthHeader = (): { Authorization: string } | null => {
  const heather = localStorage.getItem('products-token')
    ? {
        Authorization: 'Bearer ' + localStorage.getItem('products-token'),
      }
    : null;
  return heather;
};

export const getAllProducts = async (): Promise<Product[]> => {
  const authHeather = createAuthHeader();
  if (!authHeather) throw new Error('Not authorized');
  const response = await fetch(PRODUCTS_API_URL, {
    headers: authHeather,
  });
  if (!response.ok) {
    throw new Error('Network response was not ok');
  }
  const data: Product[] = await response.json();
  return data;
};
```

Vemos el ejemplo con la petici칩n GET de todos los productos, donde a침adimos la cabecera con la autenticaci칩n.

El proceso se repetir칤a para todos los productos.

Para evitar esto 칰ltimo tenemos una alternativa: a침adir a la ruta un **interceptor**, que captura todas las peticiones http antes de enviarlas y permite incluir la cabecera de autenticaci칩n. Por ejemplo, la librer칤a `Axios` incluye la definici칩n de un interceptor con este prop칩sito. En React-Router modo data, los **middleware** ser칤an un concepto equivalente.

## Api de Context: Inyecci칩n de dependencias en React

El contexto de React es una forma de inyecci칩n de dependencias controlada por React, que permite compartir datos entre componentes sin necesidad de pasar props manualmente a trav칠s de cada nivel del 치rbol de componentes.

En el caso de los servicios, es especialmente util si muchos componentes comparten el mismo servicio, y como cualquiera de los patrones de inyecci칩n de dependencias, permite desacoplar el servicio del componente y facilita la prueba y el mantenimiento del c칩digo.

### Contextos de React, Hooks y servicios

El Contexto (React.Context) es una **API nativa de React** que permite compartir valores entre componentes sin necesidad de pasarlos manualmente a trav칠s de props en cada nivel del 치rbol de componentes (lo que se conoce como prop drilling).

Fue introducido para solucionar el problema de compartir datos globales 닦omo temas, idiomas, usuarios autenticados o servicios sin romper la composici칩n de componentes.

El contexto se crea con la funci칩n factory `createContext`, que devuelve un objeto de la clase `React.Context` con los m칠todos `Provider` y `Consumer`. Por tanto un Contexto es un objeto que contiene dos componentes:

- **Provider**: m칠todo correspondiente a un componente de React que proporciona el valor del contexto a los componentes hijos.
- **Consumer**: el m칠todo que consume el valor proporcionado por el Provider. Desde la versi칩n 16.8, con la introducci칩n de los Hooks, se recomienda usar el hook `useContext` para consumir el contexto acceder internamente al Consumer y a los valores del contexto.

El Contexto es, en esencia, una forma sencilla y eficaz de aplicar **inyecci칩n de dependencias** en el entorno funcional de React, no necesariamente ligada a la programaci칩n orientada a objetos.:

- El proveedor (Provider) act칰a como el contenedor que proporciona la dependencia.
- El consumidor (useContext) inyecta esa dependencia dentro del componente.

Esto permite desacoplar componentes de las implementaciones concretas, y facilitar su reutilizaci칩n y testeo.

#### 游 Creaci칩n del contexto y del proveedor

El tipo del contexto se define como una interfaz que describe la forma del objeto que se va a compartir. En este caso, el contexto es un servicio de usuario.

```tsx
type ContextType = {
  name: string | null;
  isLogged: boolean;
};
```

El contexto, como objeto que puede ser accedido desde cualquier parte de la aplicaci칩n se crea con la funci칩n `createContext`, que recibe como par치metro el valor por defecto del contexto. Este valor se usar치 si no hay un proveedor (Provider) en la jerarqu칤a de componentes.

```tsx
export const Context = createContext<ContextType>({
  name: null,
  isLogged: false,
});
```

El proveedor (Provider) es un componente que envuelve a los componentes que necesitan acceder al contexto. Este componente recibe como prop el valor del contexto y lo proporciona a todos los componentes hijos.

```tsx

const contextValue: ContextType = {
    name: "Javier",
    isLogged: true,
};

type Props = {
    children: React.ReactNode;
};

export const ContextProvider: React.FC<Props> = ({ children }) => {
    return <Context.Provider value={contextValue}>{children}</context.Provider>;
};
```

En este caso el contexto solo proporciona un valor est치tico, pero como veremos m치s adelante, el valor del contexto se suele actualizar din치micamente, por ejemplo, a trav칠s de un servicio de autenticaci칩n.

Lo habitual es que el contexto y el provider se implementen en ficheros separados. En caso contrario habr치 que desactivar la regla de eslint `react-refresh/only-export-components`

### Acceso al contexto

PAra que el contexto sea accesible de debe hacer uso del `Provider` en el 치rbol de componentes, envolviendo los componentes que necesitan acceder al contexto. Si toda la aplicaci칩n tiene que tener acceso al contexto, esto se hace en el fichero main.tsx, donde se renderiza el componente ra칤z de la aplicaci칩n.

```tsx
import React from "react";
import ReactDOM from "react-dom/client";

import { App } from "./App";
import { ContextProvider } from "./context";

const root = ReactDOM.createRoot(document.getElementById("root")!);
root.render(
  <React.StrictMode>
    <ContextProvider>
      <App />
    </ContextProvider>
  </React.StrictMode>
);
```

A partir de aqu칤, cualquier componente que est칠 dentro del `ContextProvider` puede acceder al contexto.
Para acceder al contexto, se utiliza el hook `useContext`, que recibe como par치metro el contexto creado con `createContext`. Este hook devuelve el valor del contexto, que se puede usar directamente en el componente.

```tsx
import { useContext } from "react";
import { context } from "./context";

export const UserProfile: React.FC = () => {
  const { name, isLogged } = useContext(context);

  return (
    <div>
      {isLogged ? <p>Hola, {name}</p> : <p>Por favor, inicia sesi칩n</p>}
    </div>
  );
};
```

### Contexto din치mico

El objetivo mas habitual del contexto es compartir un **estado global**, es decir valor que puede cambiar a lo largo del tiempo, junto con la l칩gica para modificarlo. Es el caso de como el estado de autenticaci칩n de un usuario o el tema de la aplicaci칩n.

Como el provider no deja de ser un componente, puede hacer uso de cualquier hook de React, como `useState` o `useReducer`, para gestionar el estado del contexto. En este caso, el valor del contexto se define como un objeto que contiene tanto el valor del contexto como la funci칩n para actualizarlo.

#### 游 Theme & Language Context

Un ejemplo ser칤a un contexto que gestiona el tema de la aplicaci칩n (claro u oscuro) y el idioma (espa침ol o ingl칠s).

```tsx
type ThemeState = "dark" | "light";
type LanguageState = "es" | "en";

type Context = {
  theme: ThemeState;
  setTheme: React.Dispatch<React.SetStateAction<ThemeState>>;
  language: LanguageState;
  setLanguage: React.Dispatch<React.SetStateAction<LanguageState>>;
};

const defaultContext: Context = {
  theme: "light",
  setTheme: (state) => state,
  language: "es",
  setLanguage: (state) => state,
};

export const ThemeContext = createContext<Context>(defaultContext);
```

El proveedor del contexto se encarga de crear el estado y la funci칩n para actualizarlo, y lo proporciona a todos los componentes hijos.

```tsx
type Props = {
  children: React.ReactNode;
};

export const ThemeProvider: React.FC<Props> = ({ children }) => {
  const [theme, setTheme] = useState<ThemeState>("light");
  const [language, setLanguage] = useState<LanguageState>("es");

  return (
    <ThemeContext.Provider
      value={{
        theme,
        setTheme,
        language,
        setLanguage,
      }}
    >
      {children}
    </ThemeContext.Provider>
  );
};
```

El valor del contexto se puede leer y actualizar desde cualquier componente que consuma el contexto, lo segundo utilizando la funci칩n `setTheme` o `setLanguage` proporcionada por el proveedor.

### Contexto din치mico y custom Hooks

En situaciones m치s complejas, es posible que necesitemos encapsular la l칩gica del provider del contexto en un custom hook. Esto permite simplificar el provider y encapsular la l칩gica de negocio relacionada con el contexto.

#### 游 User Context

Para el ejemplo del contexto de usuario, que gestiona la autenticaci칩n y la informaci칩n del usuario, recuperamos el custom hook [`useUser`](#-inyecci칩n-manual-de-servicios-hook-useuser) que encapsula la l칩gica de carga y actualizaci칩n del usuario.

```tsx


export const useUser: UseUserHook = ({ id = 1, repo }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);

  const load = useCallback(async (): Promise<void> => {...}, []);

  return { user, loading, error, load };
};
```

El contexto se crea en funci칩n del tipo proporcionado por el custom hook

```tsx
type Context = {
  userContext: ReturnType<typeof useUser>;
};

const defaultContext: Context = {} as Context;

// eslint-disable-next-line react-refresh/only-export-components
export const UserContext = createContext<Context>(defaultContext);
```

El provider se encarga de crear la instancia del hook, inyectarle la instancia del repository y con el resultado, proporcionar el valor del contexto.

```tsx
type Props = {
  children: React.ReactNode;
};
export const UserProvider: React.FC<Props> = ({ children }) => {
  const repo = useMemo(() => new ApiUserRepository(), []);
  const userContext = useUser({ repo });

  return (
    <UserContext.Provider
      value={{
        userContext,
      }}
    >
      {children}
    </UserContext.Provider>
  );
};
```

### Contexto en React19. El API `use`

React 19 incluye dos cambios en relaci칩n con el contexto:

- El API `use` permite acceder a datos as칤ncronos directamente en el componente, sin necesidad de usar `useEffect` o `useState`.
- El API `use` adem치s permite acceder a datos de contexto directamente en el componente, sin necesidad de usar `useContext`.
- En el API de `Context` ya no es necesario utilizar el m칠todo `Provider` para crear el wrapper que proporciona el valor del contexto.

```tsx
type Props = {
  children: React.ReactNode;
};
export const UserProvider: React.FC<Props> = ({ children }) => {
  const repo = new ApiUserRepository();
  const userContext = useUser({ repo });

  return (
    <UserContext
      value={{
        userContext,
      }}
    >
      {children}
    </UserContext>
  );
};
```

Al consumir el contexto, se puede acceder directamente al valor del contexto sin necesidad de usar `useContext`.

```tsx
export const UserProfile: React.FC = () => {
  const { userContext } = use(UserContext);

  return (
    <div>
      {userContext.loading ? (
        <p>Cargando...</p>
      ) : userContext.error ? (
        <p>Error: {userContext.error.message}</p>
      ) : (
        <p>Hola, {userContext.user?.name}</p>
      )}
    </div>
  );
};
```

